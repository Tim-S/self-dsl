{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to self-dsl\n\n\nThis is a tutorial site for the creation of domain specific languages.\n\n\n\n\n\n\nMotivation\n:\n    Why using a DSL? What is the value of it? What is MDSD?\n\n\n\n\n\n\nBasics of meta modeling\n\n    What is meta modeled?\n\n\n\n\n\n\nTutorial-like topics for Xtext and TextX (see sidebar).\n\n\n\n\n\n\nReferences\n\n\n\n\n\n\nEmployed software to generate this documentation\n\n\n\n\nWe use \nMkDocs\n to build these\npages (using the \nRead the Docs\n\ntheme).\n\n\nWe employ \nPlantUML\n to produce UML graphics\n(together with a \nplugin\n\nworking together with  \nMkDocs\n).",
            "title": "Welcome to self-dsl"
        },
        {
            "location": "/#welcome-to-self-dsl",
            "text": "This is a tutorial site for the creation of domain specific languages.    Motivation :\n    Why using a DSL? What is the value of it? What is MDSD?    Basics of meta modeling \n    What is meta modeled?    Tutorial-like topics for Xtext and TextX (see sidebar).    References",
            "title": "Welcome to self-dsl"
        },
        {
            "location": "/#employed-software-to-generate-this-documentation",
            "text": "We use  MkDocs  to build these\npages (using the  Read the Docs \ntheme).  We employ  PlantUML  to produce UML graphics\n(together with a  plugin \nworking together with   MkDocs ).",
            "title": "Employed software to generate this documentation"
        },
        {
            "location": "/motivation/",
            "text": "Motivation\n\n\nThe problem to be solved is two-fold: avoid problems with\n\ncommunication\n and \nconsistency\n.\nA \ncommon language\n will be defined to ease \ncommunication\n within and\nbetween teams. A \nsingle source\n of information implies \nconsistency\n,\nand in turn, prevents misunderstandings.\n\n\n\n\nA very good introduction to domain modeling is\n\n(Tomassetti, 2017)\n.\n\n\nMDSD and DSLs\n\n\nModel driven software development (MDSD)\n allows\nintroducing a supplementary layer of\nabstraction above the code: This additional complexity can be employed to\nreplace traditional model traditional model based design approaches, and\nthus represents a significant design element of a software architecture.\nSuch model driven approaches often also refer to\n\ndomain specific languages (DSL)\n.\nThese languages make the design easy to communicate (defined language at\ndesign level) and at the same time the design itself constitutes of actual\nsoftware artefacts, since code is directly generated from it (single\nsource of information).\n\n\nMeta-model, model, and all that\n\n\nThe meta modeling toolsets utilized on this site typically allow to define\n\n(1) a meta model definition\n, which defines what is modeled, e.g.,\nthe basic layout of a data structure in terms of structures which have\nattributes. This meta model can be compared to a \ndata base layout\n.\nIt also can be compared to \nglossary\n for a given domain.\nUsing the meta model \n(2) model data\n can be defined by a user.\nThis model data represents the concrete \ndata structures for a given domain\n.\n\n(3) Validation\n: importantly, the meta model definition allows to validate\nand check concrete models. Finally, \n(4) code generators and\nmodel transformations\n represent primary end user tools to allow mass\nproduction based on a \nsingle source\n of information (the model).\n\n\nReal value for a project\n\n\nNotably, if a model represents a real abstraction of a software\naspect - something people talk about and which hides important\ndetails - we get a big impact in productivity. From the one and\nsingle source of specification (the model data) we can extract\ndocumentation, plan and archive changes (in the models) and at\nthe same time guarantee the consistency of model and multiple code artefacts.\n\n\nThe \nreal value\n in terms of working hours is not the meta model, the code\ngenerator or the editor of a model, but the \nmodel data\n itself. The\nrest of the employed toolset and definitions (e.g. the meta model) further\nincrease this value, by allowing to validate, transform or\nevaluate the model data.\n\n\nKeeping this in mind, one should keep in  mind to be able to parse and\nunderstand the model data in, say, 10 years. Also think about wht happens if\nmultiple users create conflicts in model files. One should be able to repair\nsuch situations. This is easier if the model stored on disk resembles the\nmodel entered by the user, than if an alternative representation is used\nwith, e.g., binary data representations or machine generated IDs which are\ndifficult to understand. Such a simple representation on disk also allows to\neasily analyze a model with a traditional text search tool (grep) and to\nmake quick modifications to the model with a simple editor.\n\n\nMoreover, the interoperability of employed toolsets is of crucial importancy:\nthe ability to define inter-model relations eases large scale model\ndriven approaches and the IDE integration increases end user acceptance.",
            "title": "Motivation"
        },
        {
            "location": "/motivation/#motivation",
            "text": "The problem to be solved is two-fold: avoid problems with communication  and  consistency .\nA  common language  will be defined to ease  communication  within and\nbetween teams. A  single source  of information implies  consistency ,\nand in turn, prevents misunderstandings.   A very good introduction to domain modeling is (Tomassetti, 2017) .",
            "title": "Motivation"
        },
        {
            "location": "/motivation/#mdsd-and-dsls",
            "text": "Model driven software development (MDSD)  allows\nintroducing a supplementary layer of\nabstraction above the code: This additional complexity can be employed to\nreplace traditional model traditional model based design approaches, and\nthus represents a significant design element of a software architecture.\nSuch model driven approaches often also refer to domain specific languages (DSL) .\nThese languages make the design easy to communicate (defined language at\ndesign level) and at the same time the design itself constitutes of actual\nsoftware artefacts, since code is directly generated from it (single\nsource of information).",
            "title": "MDSD and DSLs"
        },
        {
            "location": "/motivation/#meta-model-model-and-all-that",
            "text": "The meta modeling toolsets utilized on this site typically allow to define (1) a meta model definition , which defines what is modeled, e.g.,\nthe basic layout of a data structure in terms of structures which have\nattributes. This meta model can be compared to a  data base layout .\nIt also can be compared to  glossary  for a given domain.\nUsing the meta model  (2) model data  can be defined by a user.\nThis model data represents the concrete  data structures for a given domain . (3) Validation : importantly, the meta model definition allows to validate\nand check concrete models. Finally,  (4) code generators and\nmodel transformations  represent primary end user tools to allow mass\nproduction based on a  single source  of information (the model).",
            "title": "Meta-model, model, and all that"
        },
        {
            "location": "/motivation/#real-value-for-a-project",
            "text": "Notably, if a model represents a real abstraction of a software\naspect - something people talk about and which hides important\ndetails - we get a big impact in productivity. From the one and\nsingle source of specification (the model data) we can extract\ndocumentation, plan and archive changes (in the models) and at\nthe same time guarantee the consistency of model and multiple code artefacts.  The  real value  in terms of working hours is not the meta model, the code\ngenerator or the editor of a model, but the  model data  itself. The\nrest of the employed toolset and definitions (e.g. the meta model) further\nincrease this value, by allowing to validate, transform or\nevaluate the model data.  Keeping this in mind, one should keep in  mind to be able to parse and\nunderstand the model data in, say, 10 years. Also think about wht happens if\nmultiple users create conflicts in model files. One should be able to repair\nsuch situations. This is easier if the model stored on disk resembles the\nmodel entered by the user, than if an alternative representation is used\nwith, e.g., binary data representations or machine generated IDs which are\ndifficult to understand. Such a simple representation on disk also allows to\neasily analyze a model with a traditional text search tool (grep) and to\nmake quick modifications to the model with a simple editor.  Moreover, the interoperability of employed toolsets is of crucial importancy:\nthe ability to define inter-model relations eases large scale model\ndriven approaches and the IDE integration increases end user acceptance.",
            "title": "Real value for a project"
        },
        {
            "location": "/basics/",
            "text": "Basics of meta modeling for domain models\n\n\nIn this section we describe typical meta modeling tasks.\nMeta modeling is the creation of a meta model.\nThis defines what can be modeled in a model for that given meta model.\n\n\nAll aspects identified here can be found in a tutorial style\nin corresponding sections for TextX and Xtext of this documentation.\n\n\nIntroductory example\n\n\nAn example: A meta model for a programming language defines that, e.g.,\nvariables can be defined. The model, in turn, is a concrete programm\nwith many variable definitions.\n\n\nA meta model may, thus, be sketched as follows:\n\n\n\n\nA program (domain model) may look as follows:\n\n\n\n\nOverview: aspects of meta modeling\n\n\nA summary of different aspects to be specified by the meta model is given\nas follows. This list is inspired by the grammar based toolset\n\nXtext\n\nand \nTextX\n.\n\n\n\n\nWhich \ndomain objects\n exist (\nglossary\n)?\n\n\nHow are objects identified (\nnamed\n)?\n\n\nWhich \nattributes\n do objects have?\n\n\nWhat objects are \ncomposed\n of other objects?\n\n\nWhat objects \naggregates\n other objects?\n\n\nHow do objects \nreference\n each other (including context effects/\nscoping\n)?\n\n\nHow can I \nspecialize\n objects?\n\n\nHow can I \nconnect\n objects?\n\n\nModularization\n: How can an object reference another object from another model\n    (form the same meta model or a different one)?\n\n\nInteroperability\n: How can an object reference something from outside\n    the toolset scope (inter-tool operability)?\n\n\nValidation\n: How can custom rules be checked automatically?\n\n\n\n\nDomain objects: identification and attributes\n\n\nDomain objects represent a central part of a \nglossary\n. Thus,\ndefining such objects is a central part of any software specification\nand must be using through its design.\n\n\nDomain objects\n can represent things, like \"Customers\", \"Computers\",\n\"State machines\". In our context they can also represent activities\nand relationships,  like \"owns\" (a customers owns a computer) or\n\"runs\" (a computer runs a state machine).\nDomain objects may have \nattributes\n, some of them optional. These attributes\nmay have a \nscalar\n value or represent a \nlist\n of entries. The value of the\nattributes can be specified to represent some \nbasic type\n (like a string or a\nnumber) or \nother domain\n objects.\n\n\nImportantly, some domain objects need to be identified by a name (like a\n\"Customer\"), while other objects do not (like the \"Birthday\" in our\nexample below).\n\n\n\n\nNote: Domain objects in the meta model represent a blueprint or a class of a\nconcrete instances of such objects in a concrete model.\n\n\nComposing objects\n\n\nDomain objects may be composed of other domain objects. Such a relationship\ncan be described by an attribute with a domain object type (like in the last\nsection). An alternative representation is illustrated as follows, but\ndescribes exactly the same thing:\n\n\n\n\nNote: in this example, a Customer is composed of a Birthday object.\nThe Birthday object cannot exist without the Customer. This relationship\nis called \ncomposition\n and has clear \nownership\n semantics.\n\n\nReferences and Aggregation\n\n\nSome domain objects need to reference identifiable objects without\nhaving their ownership. This happens, e.g.,\nwhen describing domain object relationships within the model (e.g. a\nCustomer owns a Computer; relationship \"own\"). Such relationships themselves\ncan own additional attributes (e.g. \"owns since date\").\n\n\n\n\nNote: non-owning knowlegde of other objects is called \naggregation\n. Simple\nrelationships can be presented by a simple link (without attributes and without\nown rule/class definition).\n\n\nScoping\n\n\nScoping is relevant to \ndescribe what objects are identifiable\n when \nreferencing\nother objects\n. This is especially of importance, when some default visibility\nis not valid (most default scoping mechanisms allow all identifiable objects to be\nreferenced globally).\n\n\nAssume the following meta model snippet, where a \"Scenario\" is composed of\n\"Configurations\" and a \"Testcase\" references \"Scenarios\" and \"Configurations\":\n\n\n\n\nIn this case, we want that \nonly \"Configurations\" of the \"Scenario\"\nreferenced by a \"Testcase\" are visible to the \"Testcase\"\n. This\nrestriction is context specific (to the context of the \"Testcase\" described\nby the referenced \"Scenario\"). Scoping mechanisms allow to define this scope.\n\n\nSpecialization (base classes/base rules)\n\n\nSometimes it happens that some domain object is too generic and needs to\nbe specialized. This may happen when the language evolves.\nDuring the initial design commonalities are identified which lead to\nthe same pattern (base class and specialization).\n\n\n\n\nModularization\n\n\nThis happens when a model is splitted  in multiple submodels\n(e.g., different files).\n\n\n\n\nCombining meta models\n\n\nTo foster modularization, meta models can be splitted and still allow to\nreference domain objects of one meta model from the other meta model. In our last example\nwe could define a meta model for \"Testcases\" and one meta model for\n\"Scenarios\". This feature is more demanding to the underlying technology but\nallows a \nmodularization of the meta model and, thus, the glossary\n.\n\n\nInteroperability with other toolsets or software components\n\n\nIn larger projects external databases or models may need to be referenced.\nSuch external sources of information may be, e.g., am existing database of\nrequirements, some JSON or XML file or similar things. Interoperability with\nthese sources of information allow to link the model to that source.\n\n\n\n\n Validation\n\n\nThe validation of a model consists of \nadditional checks on top of structural\nconsistency\n defined by the grammar and scoping.\n\n\n\n\nError in the structure\n    result in classical syntax errors (\"\nexpected\n 'XY' instead of 'AB'\").\n\n\nScoping, in turn, defines the possible references in some context and,\n    thus, yields errors of the catergory \"referenced element 'XY' \nnot found\n.\".\n\n\nThe \nvalidation\n described in this section is about additional\n    \nlogical checks\n, once the model is correctly parsed and all\n    references resolved. This additional checks typically have a\n    \nstrong relation to the domain\n.\n\n\n\n\nExample:\n Assume a model where \"testcases\" reference \"configurations of\nscenarios\" which have certain \"aspects\". On the other hand a \"testcase\" may\nneed certain aspects. If any of the \"Aspects\" required by a \"testcase\" is not\navailabe in the referenced \"configuration\", a logical error is reported\n(validation error).\n\n\nRationale\n for choosing a validation over a scoping solution in this case:\nWhen modeling a situation where a \"configuration\" is chosen by a \"testcase\"\nwithout providing the correct \"aspects\", one would not like to get a\n\"configuration not found\", which would result if only \"configurations\" with matching\n\"aspects\" are defined in the \nscope\n of a \"testcase\". In contrast, the\n\nvalidation\n will allow all \"configurations\" of the selected \"scenario\" of\na \"testcase\" to be visible, but some of them will produce a\n\nmeaningful domain error\n, such as\n\"configuration 'config_B' does not provide the aspect 'aspect_X' required\nby testcase 'test_T1'\".\n\n\nThe structure defined in the meta model is shown as follows:\n\n\n\n\nA model with validation error (\n\"configuration 'config_B' does not provide the aspect 'aspect_X' required\nby testcase 'test_T1'\"\n) is shown as follows:\n\n\nscenario\n \nscenario_001\n \n{\n\n    \nconfiguration\n \nconfig_A\n \nhas\n \n{\naspect_X\n}\n\n    \nconfiguration\n \nconfig_B\n \nhas\n \n{\naspect_Y\n}\n\n\n}\n\n\ntestcase\n \ntest_T1\n \n{\n\n    \nuse\n \nscenario_001\n \nwith\n \nconfig_B\n\n    \nand\n \nneeds\n \n{\naspect_X\n}\n\n\n}\n\n\n\n\n\n\n\n\nA model without validation error is shown as follows:\n\n\nscenario\n \nscenario_001\n \n{\n\n    \nconfiguration\n \nconfig_A\n \nhas\n \n{\naspect_X\n}\n\n    \nconfiguration\n \nconfig_B\n \nhas\n \n{\naspect_Y\n,\n \naspect_X\n}\n\n\n}\n\n\ntestcase\n \ntest_T1\n \n{\n\n    \nuse\n \nscenario_001\n \nwith\n \nconfig_B\n\n    \nand\n \nneeds\n \n{\naspect_X\n}\n\n\n}",
            "title": "Basics of meta modeling for domain models"
        },
        {
            "location": "/basics/#basics-of-meta-modeling-for-domain-models",
            "text": "In this section we describe typical meta modeling tasks.\nMeta modeling is the creation of a meta model.\nThis defines what can be modeled in a model for that given meta model.  All aspects identified here can be found in a tutorial style\nin corresponding sections for TextX and Xtext of this documentation.",
            "title": "Basics of meta modeling for domain models"
        },
        {
            "location": "/basics/#introductory-example",
            "text": "An example: A meta model for a programming language defines that, e.g.,\nvariables can be defined. The model, in turn, is a concrete programm\nwith many variable definitions.  A meta model may, thus, be sketched as follows:   A program (domain model) may look as follows:",
            "title": "Introductory example"
        },
        {
            "location": "/basics/#overview-aspects-of-meta-modeling",
            "text": "A summary of different aspects to be specified by the meta model is given\nas follows. This list is inspired by the grammar based toolset Xtext \nand  TextX .   Which  domain objects  exist ( glossary )?  How are objects identified ( named )?  Which  attributes  do objects have?  What objects are  composed  of other objects?  What objects  aggregates  other objects?  How do objects  reference  each other (including context effects/ scoping )?  How can I  specialize  objects?  How can I  connect  objects?  Modularization : How can an object reference another object from another model\n    (form the same meta model or a different one)?  Interoperability : How can an object reference something from outside\n    the toolset scope (inter-tool operability)?  Validation : How can custom rules be checked automatically?",
            "title": "Overview: aspects of meta modeling"
        },
        {
            "location": "/basics/#domain-objects-identification-and-attributes",
            "text": "Domain objects represent a central part of a  glossary . Thus,\ndefining such objects is a central part of any software specification\nand must be using through its design.  Domain objects  can represent things, like \"Customers\", \"Computers\",\n\"State machines\". In our context they can also represent activities\nand relationships,  like \"owns\" (a customers owns a computer) or\n\"runs\" (a computer runs a state machine).\nDomain objects may have  attributes , some of them optional. These attributes\nmay have a  scalar  value or represent a  list  of entries. The value of the\nattributes can be specified to represent some  basic type  (like a string or a\nnumber) or  other domain  objects.  Importantly, some domain objects need to be identified by a name (like a\n\"Customer\"), while other objects do not (like the \"Birthday\" in our\nexample below).   Note: Domain objects in the meta model represent a blueprint or a class of a\nconcrete instances of such objects in a concrete model.",
            "title": "Domain objects: identification and attributes"
        },
        {
            "location": "/basics/#composing-objects",
            "text": "Domain objects may be composed of other domain objects. Such a relationship\ncan be described by an attribute with a domain object type (like in the last\nsection). An alternative representation is illustrated as follows, but\ndescribes exactly the same thing:   Note: in this example, a Customer is composed of a Birthday object.\nThe Birthday object cannot exist without the Customer. This relationship\nis called  composition  and has clear  ownership  semantics.",
            "title": "Composing objects"
        },
        {
            "location": "/basics/#references-and-aggregation",
            "text": "Some domain objects need to reference identifiable objects without\nhaving their ownership. This happens, e.g.,\nwhen describing domain object relationships within the model (e.g. a\nCustomer owns a Computer; relationship \"own\"). Such relationships themselves\ncan own additional attributes (e.g. \"owns since date\").   Note: non-owning knowlegde of other objects is called  aggregation . Simple\nrelationships can be presented by a simple link (without attributes and without\nown rule/class definition).",
            "title": "References and Aggregation"
        },
        {
            "location": "/basics/#scoping",
            "text": "Scoping is relevant to  describe what objects are identifiable  when  referencing\nother objects . This is especially of importance, when some default visibility\nis not valid (most default scoping mechanisms allow all identifiable objects to be\nreferenced globally).  Assume the following meta model snippet, where a \"Scenario\" is composed of\n\"Configurations\" and a \"Testcase\" references \"Scenarios\" and \"Configurations\":   In this case, we want that  only \"Configurations\" of the \"Scenario\"\nreferenced by a \"Testcase\" are visible to the \"Testcase\" . This\nrestriction is context specific (to the context of the \"Testcase\" described\nby the referenced \"Scenario\"). Scoping mechanisms allow to define this scope.",
            "title": "Scoping"
        },
        {
            "location": "/basics/#specialization-base-classesbase-rules",
            "text": "Sometimes it happens that some domain object is too generic and needs to\nbe specialized. This may happen when the language evolves.\nDuring the initial design commonalities are identified which lead to\nthe same pattern (base class and specialization).",
            "title": "Specialization (base classes/base rules)"
        },
        {
            "location": "/basics/#modularization",
            "text": "This happens when a model is splitted  in multiple submodels\n(e.g., different files).",
            "title": "Modularization"
        },
        {
            "location": "/basics/#combining-meta-models",
            "text": "To foster modularization, meta models can be splitted and still allow to\nreference domain objects of one meta model from the other meta model. In our last example\nwe could define a meta model for \"Testcases\" and one meta model for\n\"Scenarios\". This feature is more demanding to the underlying technology but\nallows a  modularization of the meta model and, thus, the glossary .",
            "title": "Combining meta models"
        },
        {
            "location": "/basics/#interoperability-with-other-toolsets-or-software-components",
            "text": "In larger projects external databases or models may need to be referenced.\nSuch external sources of information may be, e.g., am existing database of\nrequirements, some JSON or XML file or similar things. Interoperability with\nthese sources of information allow to link the model to that source.",
            "title": "Interoperability with other toolsets or software components"
        },
        {
            "location": "/xtext_eclipse/",
            "text": "Xtext and Eclipse\n\n\nXtext is integrated in Eclispe.\nTo run this tutorial (using Xtext) you need to install Eclipse with the appropriate\nplugins (current version: Oxygen).\n\n\nNote: The parser \"Antlr\" is not distributed with eclipse. You need to install\nit manually \n(itemis update site)\n,\nelse it will be downloaded for every Xtext project you create.\n\n\nDownload and install\n\n\nDownload the package\n\n\"Eclipse Modeling\"\n.\nUnpack the archive to make eclipse available.\n\n\nroot@xtext:~/Download# ls\neclipse-modeling-oxygen-3a-linux-gtk-x86_64.tar.gz\nroot@xtext:~/Download# tar xzf eclipse-modeling-oxygen-3a-linux-gtk-x86_64.tar.gz\nroot@xtext:~/Download# mv eclipse /opt/\nroot@xtext:~/Download# /opt/eclipse/eclipse \n&\n\n\n\n\n\n\nTo complete the installation you need \"Install Modeling Components\" from the\n\"Help\" menu entry. Select the \"Xtext\" entry and \"Finish\" the installation by\nrestarting eclipse.",
            "title": "Eclipse"
        },
        {
            "location": "/xtext_eclipse/#xtext-and-eclipse",
            "text": "Xtext is integrated in Eclispe.\nTo run this tutorial (using Xtext) you need to install Eclipse with the appropriate\nplugins (current version: Oxygen).  Note: The parser \"Antlr\" is not distributed with eclipse. You need to install\nit manually  (itemis update site) ,\nelse it will be downloaded for every Xtext project you create.",
            "title": "Xtext and Eclipse"
        },
        {
            "location": "/xtext_eclipse/#download-and-install",
            "text": "Download the package \"Eclipse Modeling\" .\nUnpack the archive to make eclipse available.  root@xtext:~/Download# ls\neclipse-modeling-oxygen-3a-linux-gtk-x86_64.tar.gz\nroot@xtext:~/Download# tar xzf eclipse-modeling-oxygen-3a-linux-gtk-x86_64.tar.gz\nroot@xtext:~/Download# mv eclipse /opt/\nroot@xtext:~/Download# /opt/eclipse/eclipse  &   To complete the installation you need \"Install Modeling Components\" from the\n\"Help\" menu entry. Select the \"Xtext\" entry and \"Finish\" the installation by\nrestarting eclipse.",
            "title": "Download and install"
        },
        {
            "location": "/xtext_project_setup/",
            "text": "Xtext Project Setup\n\n\nCreate a new Xtext Project\n\n\nIn Eclipse\n\n\n\n\nSelect in the menu \"File\" - \"New\" - \"Project\".\n\n\nSelect \"Xtext Project\" and click \"Next\"\n\n\nSpecify the project name:\n\n\n\"\nProject name\n\": \"course.xtext.dataflow\"\n\n\n\"\nName\n\": \"course.xtext.dataflow.DataFlowDsl\"\n\n\n\"\nExtension\n\": \"dataflow\"\nthen click \"\nNext\n\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn the next step can configure your project.\n    Select \"Maven\" as \"Prefered Build System\".\n\n\n\n\nDo not ignore warnings concerning \"Maven integration for eclipse (m2e)\".\nIf neccessary install \"m2e\" via \"Help\" - \"Install New Software\"\n- \"All Availabe Sites\" and restart Eclipse.\n\n\n\n\n\n\nFinally, some projects are created in your workspace, from which we will\nonly use a few of them at the moment (details: see \n(Mooij et al, 2017a)\n).\nAn example grammar definition is created and opened in the editor.\n\n\n\n\nCompile and Run the Project\n\n\nIn Eclipse (e.g., after a new project is created)\n\n\n\n\nIn the grammar editor right click \"Run As\" / \"Generate Xtext Artifacts\"\n\n\nIn the menu: \"\nRun\n\" - \"\nDebug Configurations\n\"...\n\n\nselect \"\nEclipse Application\n\"\n\n\nclick Icon \"\nNew Launch Configuration\n\"\n\n\noptional: specify configuration \nname\n and \nlocation\n of workspace.\n    (the Xtext create language plugin will run in a new Eclipse instance)\n\n\nclick \"\nDebug\n\"\n\n\n\n\n\n\n\n\nIn the new Eclipse instance the new language can be used:\n\n\n\n\nIn the \"\nPackage Explorer\n\" click \"\nNew Project\n\".\n\n\nSelect \"\nJava Project\n\u201c to create a new Java Project\n    (You can also choose, e.g., a C++ or an Empty Project).\n\n\nCreate a folder \"model\" in this project.\n\n\nIn this folder create a model file: \"\nNew\n\" - \"\nFile\n\"\n    with \"\nFile Name\n\"=\"test1\n.dataflow\n\" (+\"\nFinish\n\").\n    \nNote\n: the file ending is important and must match the file ending\n    specified for your language.\n\n\nClick \"\nYes\n\" when you are prompted\n    \"Do you want to convert ... to an Xtext Project\".\n\n\n\n\nNow you can play with your new language (type CTRL-Space to get auto\ncompletion). Enter the following example:\n\n\nHello Pierre!\n\n\nHello Tim!\n\n\nHello Markus!\n\n\n\n\n\n\nThe grammar for this example (automatically created after project\ninitialization) may look as follows. A \"Model\" contains \"Greetings\".\nEvery \"Greeting\" consists of the Text 'Hello' and a name followed by '!'\n(details later).\n\n\ngrammar\n \norg.xtext.example.mydsl.MyDsl\n \nwith\n \norg.eclipse.xtext.common.Terminals\n\n\ngenerate\n \nmyDsl\n \n\"http\n:\n//www.xtext.org/example/mydsl/MyDsl\"\n\n\nModel\n:\n\n\n    \ngreetings\n+=\nGreeting\n*\n;\n\n\nGreeting\n:\n\n\n    \n'Hello'\n \nname\n=\nID\n \n'!'\n;",
            "title": "Xtext Project Setup"
        },
        {
            "location": "/xtext_project_setup/#xtext-project-setup",
            "text": "",
            "title": "Xtext Project Setup"
        },
        {
            "location": "/xtext_project_setup/#create-a-new-xtext-project",
            "text": "In Eclipse   Select in the menu \"File\" - \"New\" - \"Project\".  Select \"Xtext Project\" and click \"Next\"  Specify the project name:  \" Project name \": \"course.xtext.dataflow\"  \" Name \": \"course.xtext.dataflow.DataFlowDsl\"  \" Extension \": \"dataflow\"\nthen click \" Next \"        In the next step can configure your project.\n    Select \"Maven\" as \"Prefered Build System\".   Do not ignore warnings concerning \"Maven integration for eclipse (m2e)\".\nIf neccessary install \"m2e\" via \"Help\" - \"Install New Software\"\n- \"All Availabe Sites\" and restart Eclipse.    Finally, some projects are created in your workspace, from which we will\nonly use a few of them at the moment (details: see  (Mooij et al, 2017a) ).\nAn example grammar definition is created and opened in the editor.",
            "title": "Create a new Xtext Project"
        },
        {
            "location": "/xtext_project_setup/#compile-and-run-the-project",
            "text": "In Eclipse (e.g., after a new project is created)   In the grammar editor right click \"Run As\" / \"Generate Xtext Artifacts\"  In the menu: \" Run \" - \" Debug Configurations \"...  select \" Eclipse Application \"  click Icon \" New Launch Configuration \"  optional: specify configuration  name  and  location  of workspace.\n    (the Xtext create language plugin will run in a new Eclipse instance)  click \" Debug \"     In the new Eclipse instance the new language can be used:   In the \" Package Explorer \" click \" New Project \".  Select \" Java Project \u201c to create a new Java Project\n    (You can also choose, e.g., a C++ or an Empty Project).  Create a folder \"model\" in this project.  In this folder create a model file: \" New \" - \" File \"\n    with \" File Name \"=\"test1 .dataflow \" (+\" Finish \").\n     Note : the file ending is important and must match the file ending\n    specified for your language.  Click \" Yes \" when you are prompted\n    \"Do you want to convert ... to an Xtext Project\".   Now you can play with your new language (type CTRL-Space to get auto\ncompletion). Enter the following example:  Hello Pierre!  Hello Tim!  Hello Markus!   The grammar for this example (automatically created after project\ninitialization) may look as follows. A \"Model\" contains \"Greetings\".\nEvery \"Greeting\" consists of the Text 'Hello' and a name followed by '!'\n(details later).  grammar   org.xtext.example.mydsl.MyDsl   with   org.eclipse.xtext.common.Terminals  generate   myDsl   \"http : //www.xtext.org/example/mydsl/MyDsl\"  Model :       greetings += Greeting * ;  Greeting :       'Hello'   name = ID   '!' ;",
            "title": "Compile and Run the Project"
        },
        {
            "location": "/xtext_a_first_grammar/",
            "text": "A First Grammar\n\n\nThe goal of this exercise is to define a grammar for a structure as sketched in\nthe image below: A \nModel\n shall contain \nPackages\n. Every \nPackage\n\ncan contain \nComponent\n definitions and \nService\n definitions.\nA Service can \ninstantiate\n the Components.\nMoreover shall a Component definition contain \ninput ports\n\nand \noutput ports\n.\n\n\nAll \nbold\n elements in the text above will be defined in our the grammar of\nour meta model.\n\n\n\n\nFirst steps after project initialization\n\n\nA grammar describes the syntax (more or less without semantic) of our\ndomain language describing domain models.\nInternally, Xtext deduces an ecore model from the grammar, which can be used\nto display the structure of the grammar (like the image in the first part of this\npage).\nThe grammar remains the master (for maintenance) and the ecore model is recreated\nafter every change.\n\n\nNote: Is is also possible to create a grammar based on an ecore model\n(via Eclipse Wizard).\n\n\nAdditional information can be found in the \nreferences list\n or\nin the offline help of Eclipse: \"Help\" - \"Help Contents\".\n\n\nRoot node of a model\n\n\nTake a look at the grammar initially created for our project:\n\n\nModel\n:\n\n\n    \ngreetings\n+=\nGreeting\n*\n;\n\n\nGreeting\n:\n\n\n    \n'Hello'\n \nname\n=\nID\n \n'!'\n;\n\n\n\n\n\n\n\n\nA grammar conists of \nrules\n, starting with the name of the rule,\n    followed by a colon \":\" and the rule itself,\n    and is terminated by a semicolon \";\".\n\n\nThe first rule in the grammar (e.g. \"Model\") is the root of the model.\n\n\nInstead of adding elements to the model of type \"\nGreeting\n\", we will\n    add elements of type \"\nKPackage\n\" (change the name \"Greeting\" to \"KPackage\").\n\n\nSee also \n(Mooij et al, 2017a)\n\n\n\n\nAttributes, Composition\n\n\nA \"KPackage\" element, in turn, shall be composed of \"KComponent\" and \"KService\"\nelements:\n\n\n\n\nThe syntax for the composition is given as follows:\n\n\nKPackage\n:\n \n'package'\n \nname\n=\nID\n \n'{'\n\n\n        \n(\n\n\n            \ncomponents\n \n+=\n \nKComponent\n \n|\n\n\n            \nservices\n \n+=\n \nKService\n\n\n        \n)*\n\n\n    \n'}'\n\n\n;\n\n\n\n\n\n\n\n\n'package', '{', '}'\n\n\nrepresent \nkeywords\n of our language.\n\n\n\n\n\n\nname=ID\n\n\n\"name\" is an \nattribute\n in the meta mode (the attribute \"name\" has\n   a special meaning: it is used to \nindentify\n elements).\n\n\n\"=\" means: this is a scalar value (no list of values).\n\n\nID\n is a \nterminal\n (see grammar, and click \"F3\" on\n  \"org.eclipse.xtext.common.Terminals\" to see definition).\n\n\n\n\n\n\ncomponents += KComponent\n\n\n\"components\" is an attribute in the meta model.\n\n\n\"+=\" means, this is a \nlist of values\n (add one element to this list here)\n\n\n\"KComponent\" and \"KService\" are \nrule definitions\n like \"KPackage\"\n  (need to be added)\n\n\n\n\n\n\n( ... | ... )*\n\n\nEverything with the brackets can be repeated  0 to n times (\"+\" instead\n  of \"*\" means 1 to n times).\n\n\n\"|\" is a logical OR.\n\n\n\n\n\n\n\n\nModify the grammar to allow to enter the following model. Test the\ngrammar with this example (run the grammar as described\n\nin the previous section\n): \"Run As\" -\n\"Xtext Artifacts\". The new Eclipse instance can easily be\nstarted via the Debug icon).\n\n\npackage\n \ntest1\n \n{\n\n    \nComponent\n \nPC\n \n{\n\n    \n}\n\n    \nComponent\n \nDF\n \n{\n\n    \n}\n\n    \nservice\n \nMyService\n \n{\n\n    \n}\n\n\n}\n\n\n\n\n\n\nReferences\n\n\n\n\nKInstance\n:\n \n'instance'\n \nname\n=\nID\n \n':'\n \ntype\n=\n[\nKComponent\n];\n\n\n\n\n\n\n\n\ntype=[KComponent]\n\n\n\"type\" is an attribute in the meta model.\n\n\n\"[KComponent]\" is a \nreference\n to a \"KComponent\" element.\n\n\nFor more inforamtion see the \nreferences list\n.\n\n\n\n\n\n\n\n\nSpecialization\n\n\n\n\nKPort\n:\n\n\n    \nKPortIn\n|\nKPortOut\n\n\n;\n\n\nKPortIn\n:\n\n\n    \n'port_in'\n \nname\n=\nID\n \n'{'\n\n\n    \n'}'\n\n\n;\n\n\nKPortOut\n:\n\n\n    \n'port_out'\n \nname\n=\nID\n \n'{'\n\n\n    \n'}'\n\n\n;\n\n\n\n\n\n\n\n\nBase: SpecialA|SpecialB;\n\n\nDefines a base class (base rule) for the specializations separated\n   by \"|\".\n\n\nCommon attributes are availabe in the base class (here: \"name\")\n\n\nFor more inforamtion see the \nreferences list\n.\n\n\n\n\n\n\n\n\nEditor\n\n\nAfter adding \nports\n (\"KPort\") to the \ncomponents\n (\"KComponent\")\nand \ninstances\n (\"KInstance\") to the \nservices\n (\"KService\"), you can test\nyour langauge with the following snippet:\n\n\npackage\n \ntest1\n \n{\n\n    \nComponent\n \nPC\n \n{\n\n        \nport_in\n \nin\n \n{}\n\n        \nport_out\n \nout\n \n{}\n\n    \n}\n\n    \nComponent\n \nDF\n \n{\n\n        \nport_in\n \nin\n \n{}\n\n        \nport_out\n \nout\n \n{}\n\n        \nport_out\n \ndebug\n \n{}\n\n    \n}\n\n    \nservice\n \nMyService\n \n{\n\n        \ninstance\n \npc\n \n:\n \nPC\n\n        \ninstance\n \ndf\n \n:\n \nDF\n\n    \n}\n\n\n}\n\n\n\n\n\n\nYou can also edit the model with a \ntree editor\n:\nopen wthe file with \"Open With...\" - \"Sample Ecore Model Editor\".\n\n\n (Tree Editor):\n\n\n\n\nWhen editing the model graph, the model text is changed accordingly: \nsee \nAuto Formatting\n.\n\n\nMore grammar stuff...\n\n\nThere is much more not covered here. You can start with\n\n(Mooij et al, 2017a)\n.\n\n\nOf special interest could be\n  * Optional parts of the grammar with \"?\".\n  * Enums (initially set to the first enum state).\n\n\nVisualize the meta model\n\n\nThe ecore model deduced from the grammar can be visualized:\nsee \n(Mooij et al, 2017a)\n,\nsection \"Optional: Ecore diagram\" (\u201eInitialize Ecore Diagram ...\u201c).\nMoreover a syntax tree can be rendered from the grammar:\nsee \n(Mooij et al, 2017a)\n,\nsection \"Optional: View Diagram of Xtext Grammar\"\n(Window/Show View/Other.../Xtext/Xtext Syntax Graph).",
            "title": "A First Grammar"
        },
        {
            "location": "/xtext_a_first_grammar/#a-first-grammar",
            "text": "The goal of this exercise is to define a grammar for a structure as sketched in\nthe image below: A  Model  shall contain  Packages . Every  Package \ncan contain  Component  definitions and  Service  definitions.\nA Service can  instantiate  the Components.\nMoreover shall a Component definition contain  input ports \nand  output ports .  All  bold  elements in the text above will be defined in our the grammar of\nour meta model.",
            "title": "A First Grammar"
        },
        {
            "location": "/xtext_a_first_grammar/#first-steps-after-project-initialization",
            "text": "A grammar describes the syntax (more or less without semantic) of our\ndomain language describing domain models.\nInternally, Xtext deduces an ecore model from the grammar, which can be used\nto display the structure of the grammar (like the image in the first part of this\npage).\nThe grammar remains the master (for maintenance) and the ecore model is recreated\nafter every change.  Note: Is is also possible to create a grammar based on an ecore model\n(via Eclipse Wizard).  Additional information can be found in the  references list  or\nin the offline help of Eclipse: \"Help\" - \"Help Contents\".",
            "title": "First steps after project initialization"
        },
        {
            "location": "/xtext_a_first_grammar/#root-node-of-a-model",
            "text": "Take a look at the grammar initially created for our project:  Model :       greetings += Greeting * ;  Greeting :       'Hello'   name = ID   '!' ;    A grammar conists of  rules , starting with the name of the rule,\n    followed by a colon \":\" and the rule itself,\n    and is terminated by a semicolon \";\".  The first rule in the grammar (e.g. \"Model\") is the root of the model.  Instead of adding elements to the model of type \" Greeting \", we will\n    add elements of type \" KPackage \" (change the name \"Greeting\" to \"KPackage\").  See also  (Mooij et al, 2017a)",
            "title": "Root node of a model"
        },
        {
            "location": "/xtext_a_first_grammar/#attributes-composition",
            "text": "A \"KPackage\" element, in turn, shall be composed of \"KComponent\" and \"KService\"\nelements:   The syntax for the composition is given as follows:  KPackage :   'package'   name = ID   '{'           (               components   +=   KComponent   |               services   +=   KService           )*       '}'  ;    'package', '{', '}'  represent  keywords  of our language.    name=ID  \"name\" is an  attribute  in the meta mode (the attribute \"name\" has\n   a special meaning: it is used to  indentify  elements).  \"=\" means: this is a scalar value (no list of values).  ID  is a  terminal  (see grammar, and click \"F3\" on\n  \"org.eclipse.xtext.common.Terminals\" to see definition).    components += KComponent  \"components\" is an attribute in the meta model.  \"+=\" means, this is a  list of values  (add one element to this list here)  \"KComponent\" and \"KService\" are  rule definitions  like \"KPackage\"\n  (need to be added)    ( ... | ... )*  Everything with the brackets can be repeated  0 to n times (\"+\" instead\n  of \"*\" means 1 to n times).  \"|\" is a logical OR.     Modify the grammar to allow to enter the following model. Test the\ngrammar with this example (run the grammar as described in the previous section ): \"Run As\" -\n\"Xtext Artifacts\". The new Eclipse instance can easily be\nstarted via the Debug icon).  package   test1   { \n     Component   PC   { \n     } \n     Component   DF   { \n     } \n     service   MyService   { \n     }  }",
            "title": "Attributes, Composition"
        },
        {
            "location": "/xtext_a_first_grammar/#references",
            "text": "KInstance :   'instance'   name = ID   ':'   type = [ KComponent ];    type=[KComponent]  \"type\" is an attribute in the meta model.  \"[KComponent]\" is a  reference  to a \"KComponent\" element.  For more inforamtion see the  references list .",
            "title": "References"
        },
        {
            "location": "/xtext_a_first_grammar/#specialization",
            "text": "KPort :       KPortIn | KPortOut  ;  KPortIn :       'port_in'   name = ID   '{'       '}'  ;  KPortOut :       'port_out'   name = ID   '{'       '}'  ;    Base: SpecialA|SpecialB;  Defines a base class (base rule) for the specializations separated\n   by \"|\".  Common attributes are availabe in the base class (here: \"name\")  For more inforamtion see the  references list .",
            "title": "Specialization"
        },
        {
            "location": "/xtext_a_first_grammar/#editor",
            "text": "After adding  ports  (\"KPort\") to the  components  (\"KComponent\")\nand  instances  (\"KInstance\") to the  services  (\"KService\"), you can test\nyour langauge with the following snippet:  package   test1   { \n     Component   PC   { \n         port_in   in   {} \n         port_out   out   {} \n     } \n     Component   DF   { \n         port_in   in   {} \n         port_out   out   {} \n         port_out   debug   {} \n     } \n     service   MyService   { \n         instance   pc   :   PC \n         instance   df   :   DF \n     }  }   You can also edit the model with a  tree editor :\nopen wthe file with \"Open With...\" - \"Sample Ecore Model Editor\".   (Tree Editor):   When editing the model graph, the model text is changed accordingly: \nsee  Auto Formatting .",
            "title": "Editor"
        },
        {
            "location": "/xtext_a_first_grammar/#more-grammar-stuff",
            "text": "There is much more not covered here. You can start with (Mooij et al, 2017a) .  Of special interest could be\n  * Optional parts of the grammar with \"?\".\n  * Enums (initially set to the first enum state).",
            "title": "More grammar stuff..."
        },
        {
            "location": "/xtext_a_first_grammar/#visualize-the-meta-model",
            "text": "The ecore model deduced from the grammar can be visualized:\nsee  (Mooij et al, 2017a) ,\nsection \"Optional: Ecore diagram\" (\u201eInitialize Ecore Diagram ...\u201c).\nMoreover a syntax tree can be rendered from the grammar:\nsee  (Mooij et al, 2017a) ,\nsection \"Optional: View Diagram of Xtext Grammar\"\n(Window/Show View/Other.../Xtext/Xtext Syntax Graph).",
            "title": "Visualize the meta model"
        },
        {
            "location": "/xtext_auto_formatting/",
            "text": "Auto Formatting\n\n\nWhen you change the model (e.g. using the \n\n(Tree Editor)\n)\nand you save your changes, you will notice that the\nmodel text is updated, but does not contain any line breaks.\nAlso, when invooking the auto-formatter of Eclipse \n(CTRL-SHIFT-F in the text editor of Eclipse), the same\neffect occurs. This behavior can be controlled in Xtext\nwith a special Xtext Formatter.\n\n\nXtext Formatter\n\n\nCreate a new class \"kurs.xtext.dataflow.formatting.MyFormatter\"\nin your Xtext project, which inherits from\n\"org.eclipse.xtext.formatting.impl.AbstractDeclarativeFormatter\".\n\n\n\n\nIn this class you can control, e.g., the formatting\naround '{' and '}'. More Information: e.g., \n\nJavaDoc of FormattingConfig\n.\n\n\nimport\n \norg.eclipse.xtext.Keyword\n;\n\n\nimport\n \norg.eclipse.xtext.formatting.impl.AbstractDeclarativeFormatter\n;\n\n\nimport\n \norg.eclipse.xtext.formatting.impl.FormattingConfig\n;\n\n\nimport\n \norg.eclipse.xtext.util.Pair\n;\n\n\n\nimport\n \nkurs.xtext.dataflow.services.DataFlowDslGrammarAccess\n;\n\n\n\npublic\n \nclass\n \nMyFormatter\n \nextends\n \nAbstractDeclarativeFormatter\n \n{\n\n\n    \n@Override\n\n    \nprotected\n \nvoid\n \nconfigureFormatting\n(\nFormattingConfig\n \nconfig\n)\n \n{\n\n\n        \nDataFlowDslGrammarAccess\n \nga\n \n=\n \n(\nDataFlowDslGrammarAccess\n)\n \ngetGrammarAccess\n();\n\n\n        \nfor\n \n(\nPair\n<\nKeyword\n,\n \nKeyword\n>\n \npair\n \n:\n \nga\n.\nfindKeywordPairs\n(\n\"{\"\n,\n \n\"}\"\n))\n \n{\n\n            \nconfig\n.\nsetLinewrap\n().\nafter\n(\npair\n.\ngetFirst\n());\n\n            \nconfig\n.\nsetIndentationIncrement\n().\nafter\n(\npair\n.\ngetFirst\n());\n\n            \nconfig\n.\nsetLinewrap\n().\nbefore\n(\npair\n.\ngetSecond\n());\n\n            \nconfig\n.\nsetIndentationDecrement\n().\nbefore\n(\npair\n.\ngetSecond\n());\n\n            \nconfig\n.\nsetLinewrap\n().\nafter\n(\npair\n.\ngetSecond\n());\n\n        \n}\n       \n        \nconfig\n.\nsetLinewrap\n(\n1\n,\n \n1\n,\n \n1\n).\nafter\n(\nga\n.\ngetKInstanceRule\n());\n       \n    \n}\n\n\n\n}\n\n\n\n\n\n\nThis new formatter must be registered for your meta model:\nedit the *RuntimeModule\"-file\n\"kurs.xtext.dataflow.DataFlowDslRuntimeModule.xtend\" \nand add the following code:\n\n\noverride\n \nbindIFormatter\n()\n \n{\n\n    \nMyFormatter\n\n\n}\n\n\n\n\n\n\n(Note: Xtend is a language which translates to Java.\nThus, every Xtend class can also be written in Java.)\n\n\nRestart your Eclipse Runtime Workbench and test the new \nformatter (CTRL-SHIFT-F).",
            "title": "Auto Formatting"
        },
        {
            "location": "/xtext_auto_formatting/#auto-formatting",
            "text": "When you change the model (e.g. using the  (Tree Editor) )\nand you save your changes, you will notice that the\nmodel text is updated, but does not contain any line breaks.\nAlso, when invooking the auto-formatter of Eclipse \n(CTRL-SHIFT-F in the text editor of Eclipse), the same\neffect occurs. This behavior can be controlled in Xtext\nwith a special Xtext Formatter.",
            "title": "Auto Formatting"
        },
        {
            "location": "/xtext_auto_formatting/#xtext-formatter",
            "text": "Create a new class \"kurs.xtext.dataflow.formatting.MyFormatter\"\nin your Xtext project, which inherits from\n\"org.eclipse.xtext.formatting.impl.AbstractDeclarativeFormatter\".   In this class you can control, e.g., the formatting\naround '{' and '}'. More Information: e.g.,  JavaDoc of FormattingConfig .  import   org.eclipse.xtext.Keyword ;  import   org.eclipse.xtext.formatting.impl.AbstractDeclarativeFormatter ;  import   org.eclipse.xtext.formatting.impl.FormattingConfig ;  import   org.eclipse.xtext.util.Pair ;  import   kurs.xtext.dataflow.services.DataFlowDslGrammarAccess ;  public   class   MyFormatter   extends   AbstractDeclarativeFormatter   { \n\n     @Override \n     protected   void   configureFormatting ( FormattingConfig   config )   { \n\n         DataFlowDslGrammarAccess   ga   =   ( DataFlowDslGrammarAccess )   getGrammarAccess (); \n\n         for   ( Pair < Keyword ,   Keyword >   pair   :   ga . findKeywordPairs ( \"{\" ,   \"}\" ))   { \n             config . setLinewrap (). after ( pair . getFirst ()); \n             config . setIndentationIncrement (). after ( pair . getFirst ()); \n             config . setLinewrap (). before ( pair . getSecond ()); \n             config . setIndentationDecrement (). before ( pair . getSecond ()); \n             config . setLinewrap (). after ( pair . getSecond ()); \n         }        \n         config . setLinewrap ( 1 ,   1 ,   1 ). after ( ga . getKInstanceRule ());        \n     }  }   This new formatter must be registered for your meta model:\nedit the *RuntimeModule\"-file\n\"kurs.xtext.dataflow.DataFlowDslRuntimeModule.xtend\" \nand add the following code:  override   bindIFormatter ()   { \n     MyFormatter  }   (Note: Xtend is a language which translates to Java.\nThus, every Xtend class can also be written in Java.)  Restart your Eclipse Runtime Workbench and test the new \nformatter (CTRL-SHIFT-F).",
            "title": "Xtext Formatter"
        },
        {
            "location": "/xtext_model_validation/",
            "text": "Model Validation\n\n\nA model can be validated according certain validation rules.\nThese rules have to be define by the meta modeller\nin the meta model. Error and warning messages can be reported\nand attached to model elements or text location. These\nmessages are displayed in the Eclipse model text editor.\nMore Information, see \n(Mooij et al, 2017a)\n.\n\n\n(Rentz-Reichert, 2017)\n\nsuggested to put as little as possible semantics into\nthe grammar (e.g. \"+\" instead of \"*\") and to add this \nsemantics to the validation code. This often allows\nto generate more meaningful domain errors.\n\n\nValidation Example\n\n\nOpen the *Validator.xtend\" file (automatically generated for\na new project), e.g., \n\"kurs.xtext.dataflow.validation.DataFlowDslValidator.xtend\".\nActivate the commented code and modify it:\n\n\npackage\n \nkurs\n.\nxtext\n.\ndataflow\n.\nvalidation\n\n\n\nimport\n \norg.eclipse.xtext.validation.Check\n\n\nimport\n \nkurs.xtext.dataflow.dataFlowDsl.KComponent\n\n\nimport\n \nkurs.xtext.dataflow.dataFlowDsl.DataFlowDslPackage\n\n\n\nclass\n \nDataFlowDslValidator\n \nextends\n \nAbstractDataFlowDslValidator\n \n{\n\n\n    \npublic\n \nstatic\n \nval\n \nINVALID_NAME\n \n=\n \n'invalidName'\n\n\n    \n@Check\n\n    \ndef\n \ncheckComponentStartsWithCapital\n(\nKComponent\n \nc\n)\n \n{\n\n        \nif\n \n(!\nCharacter\n.\nisUpperCase\n(\nc\n.\nname\n.\ncharAt\n(\n0\n)))\n \n{\n\n            \nwarning\n(\n'Name should start with a capital'\n,\n \n                    \nDataFlowDslPackage\n.\nLiterals\n.\nKCOMPONENT__NAME\n,\n\n                    \nINVALID_NAME\n)\n\n        \n}\n\n    \n}\n   \n\n}\n\n\n\n\n\n\nTry your validator for your language in the Eclipse Runtime model editor.\n\n\n\nNotes:\n\n\n\n\nA validation rule is marked as such with the annotation \"@Check\". \n     The argument is a model element of the type to be checked.\n\n\nThe rule is checked during typing in the editor \n     (@Check allows to control if a rule is checked during \n     typing, when saving, or upon explicit request\n     (see: org.eclipse.xtext.validation.CheckType; \n     press \"F3\" when having the cursor on @Check)\n\n\nThe rule above checks elements of type \"KComponent\". \n     Errors/warning, if present, are attached to this model element.\n\n\nA rule can generate \"errors\", \"warnings\" und \"infos\".\n     The ID (in our case \"INVALID_NAME\") allows a rule to \n     be identified later, e.g., when\n     implementing HotFixes for specific validation violations.",
            "title": "Model Validation"
        },
        {
            "location": "/xtext_model_validation/#model-validation",
            "text": "A model can be validated according certain validation rules.\nThese rules have to be define by the meta modeller\nin the meta model. Error and warning messages can be reported\nand attached to model elements or text location. These\nmessages are displayed in the Eclipse model text editor.\nMore Information, see  (Mooij et al, 2017a) .  (Rentz-Reichert, 2017) \nsuggested to put as little as possible semantics into\nthe grammar (e.g. \"+\" instead of \"*\") and to add this \nsemantics to the validation code. This often allows\nto generate more meaningful domain errors.",
            "title": "Model Validation"
        },
        {
            "location": "/xtext_model_validation/#validation-example",
            "text": "Open the *Validator.xtend\" file (automatically generated for\na new project), e.g., \n\"kurs.xtext.dataflow.validation.DataFlowDslValidator.xtend\".\nActivate the commented code and modify it:  package   kurs . xtext . dataflow . validation  import   org.eclipse.xtext.validation.Check  import   kurs.xtext.dataflow.dataFlowDsl.KComponent  import   kurs.xtext.dataflow.dataFlowDsl.DataFlowDslPackage  class   DataFlowDslValidator   extends   AbstractDataFlowDslValidator   { \n\n     public   static   val   INVALID_NAME   =   'invalidName' \n\n     @Check \n     def   checkComponentStartsWithCapital ( KComponent   c )   { \n         if   (! Character . isUpperCase ( c . name . charAt ( 0 )))   { \n             warning ( 'Name should start with a capital' ,  \n                     DataFlowDslPackage . Literals . KCOMPONENT__NAME , \n                     INVALID_NAME ) \n         } \n     }     }   Try your validator for your language in the Eclipse Runtime model editor.  Notes:   A validation rule is marked as such with the annotation \"@Check\". \n     The argument is a model element of the type to be checked.  The rule is checked during typing in the editor \n     (@Check allows to control if a rule is checked during \n     typing, when saving, or upon explicit request\n     (see: org.eclipse.xtext.validation.CheckType; \n     press \"F3\" when having the cursor on @Check)  The rule above checks elements of type \"KComponent\". \n     Errors/warning, if present, are attached to this model element.  A rule can generate \"errors\", \"warnings\" und \"infos\".\n     The ID (in our case \"INVALID_NAME\") allows a rule to \n     be identified later, e.g., when\n     implementing HotFixes for specific validation violations.",
            "title": "Validation Example"
        },
        {
            "location": "/xtext_quickfixes/",
            "text": "Quickfixes\n\n\nOpen the *QuickfixProvider.xtend file of your ui-project, e.g.,\n\"kurs.xtext.dataflow.ui.quickfix.DataFlowDslQuickfixProvider.xtend\".\nHere you can implement Quickfixes.\n\n\nThe example provided as commented code can be activated\nfor our \ninitial example\n more or\nless without modifications:\n\n\n@Fix\n(\nDataFlowDslValidator\n.\nINVALID_NAME\n)\n\n\ndef\n \ncapitalizeName\n(\nIssue\n \nissue\n,\n \nIssueResolutionAcceptor\n \nacceptor\n)\n \n{\n\n    \nacceptor\n.\naccept\n(\nissue\n,\n \n'Capitalize name'\n,\n \n'Capitalize the name.'\n,\n \n'upcase.png'\n)\n \n[\n\n        \ncontext\n \n|\n\n        \nval\n \nxtextDocument\n \n=\n \ncontext\n.\nxtextDocument\n\n        \nval\n \nfirstLetter\n \n=\n \nxtextDocument\n.\nget\n(\nissue\n.\noffset\n,\n \n1\n)\n\n        \nxtextDocument\n.\nreplace\n(\nissue\n.\noffset\n,\n \n1\n,\n \nfirstLetter\n.\ntoUpperCase\n)\n\n    \n]\n\n\n}\n\n\n\n\n\n\nThe \nID of the validation\n \n(here \"INVALID_NAME\") allows to identify the type of the\nissue to be fixed. \n\n\nIn the last example, the Quickfix uses direct access\nto the model text. Alternatively, the model itself can\nbe modified:\n\n\n@Fix\n(\nDataFlowDslValidator\n.\nINVALID_NAME\n)\n\n\ndef\n \ncapitalizeName2\n(\nIssue\n \nissue\n,\n \nIssueResolutionAcceptor\n \nacceptor\n)\n \n{\n\n    \nacceptor\n.\naccept\n(\nissue\n,\n \n'Capitalize name 2'\n,\n \n'Capitalize the name.'\n,\n \n'upcase.png'\n)\n \n[\n\n        \nelement\n,\n \ncontext\n \n|\n\n        \nval\n \nc\n=\nelement\n \nas\n \nKComponent\n\n        \nc\n.\nname\n \n=\n \nc\n.\nname\n.\ntoFirstUpper\n\n    \n]\n\n\n}\n\n\n\n\n\n\nThe annotation \"@Fix\" marks a method as Quickfix-method and\ncontrols the mapping to the validation ID.\n\n\nNote: relevant details concerning Xtend are discussed in\n\nthis section\n\n(e.g., the meaning of \u201eval\u201c, \u201eas\u201c, etc.).",
            "title": "Quickfixes"
        },
        {
            "location": "/xtext_quickfixes/#quickfixes",
            "text": "Open the *QuickfixProvider.xtend file of your ui-project, e.g.,\n\"kurs.xtext.dataflow.ui.quickfix.DataFlowDslQuickfixProvider.xtend\".\nHere you can implement Quickfixes.  The example provided as commented code can be activated\nfor our  initial example  more or\nless without modifications:  @Fix ( DataFlowDslValidator . INVALID_NAME )  def   capitalizeName ( Issue   issue ,   IssueResolutionAcceptor   acceptor )   { \n     acceptor . accept ( issue ,   'Capitalize name' ,   'Capitalize the name.' ,   'upcase.png' )   [ \n         context   | \n         val   xtextDocument   =   context . xtextDocument \n         val   firstLetter   =   xtextDocument . get ( issue . offset ,   1 ) \n         xtextDocument . replace ( issue . offset ,   1 ,   firstLetter . toUpperCase ) \n     ]  }   The  ID of the validation  \n(here \"INVALID_NAME\") allows to identify the type of the\nissue to be fixed.   In the last example, the Quickfix uses direct access\nto the model text. Alternatively, the model itself can\nbe modified:  @Fix ( DataFlowDslValidator . INVALID_NAME )  def   capitalizeName2 ( Issue   issue ,   IssueResolutionAcceptor   acceptor )   { \n     acceptor . accept ( issue ,   'Capitalize name 2' ,   'Capitalize the name.' ,   'upcase.png' )   [ \n         element ,   context   | \n         val   c = element   as   KComponent \n         c . name   =   c . name . toFirstUpper \n     ]  }   The annotation \"@Fix\" marks a method as Quickfix-method and\ncontrols the mapping to the validation ID.  Note: relevant details concerning Xtend are discussed in this section \n(e.g., the meaning of \u201eval\u201c, \u201eas\u201c, etc.).",
            "title": "Quickfixes"
        },
        {
            "location": "/xtext_code_generation_xtend/",
            "text": "Code Generation (with Xtend)\n\n\nXtend is highly optimized to be used\nfor code generation. It has a optimzed template engine (e.g., with\nautomatic indentation support) and\nis fully integrated in the Eclipse IDE (auto completition\nfor model data).\n\n\nSimple Example\n\n\nOpen the *Generator.xtend file in your project, e.g.,\nkurs.xtext.dataflow.generator.DataFlowDslGenerator.xtend. \nHere, you can implement your first code generator:\nYou have model access (parameter \"resource\") and file system access\n(parameter \"fsa\").\n\n\noverride\n \nvoid\n \ndoGenerate\n(\nResource\n \nresource\n,\n \nIFileSystemAccess2\n \nfsa\n,\n \n        \nIGeneratorContext\n \ncontext\n)\n \n{\n\n    \n// -------------------------------------------\n\n    \n// Option 1:\n\n    \nvar\n \ntxt\n \n=\n \n\"\"\n\n    \nfor\n \n(\nobj:\n \nresource\n.\nallContents\n.\ntoIterable\n)\n \n{\n\n        \nif\n \n(\nobj\n \ninstanceof\n \nKComponent\n)\n \n{\n \n// inside this \"if\" obj is a KComponent\n\n            \nif\n \n(\ntxt\n.\nlength\n>\n0\n)\n \ntxt\n \n=\n \ntxt\n \n+\n \n\", \"\n\n            \ntxt\n \n=\n \ntxt\n \n+\n \nobj\n.\nname\n;\n\n        \n}\n\n    \n}\n\n    \nfsa\n.\ngenerateFile\n(\n'Components1.txt'\n,\n \n'Component declarations: '\n \n+\n \ntxt\n);\n\n\n    \n// -------------------------------------------\n\n    \n// Option 2:\n\n    \nfsa\n.\ngenerateFile\n(\n'Components2.txt'\n,\n \n'Component declarations: '\n \n+\n \n        \nresource\n.\nallContents\n\n            \n.\nfilter\n[\n \nobj\n \n|\n \nobj\n \ninstanceof\n \nKComponent\n]\n\n            \n.\nmap\n[\n \nobj\n \n|\n \nreturn\n \n(\nobj\n \nas\n \nKComponent\n).\nname\n \n]\n\n            \n.\njoin\n(\n', '\n))\n\n\n    \n// -------------------------------------------\n\n    \n// Option 3:\n\n    \nfsa\n.\ngenerateFile\n(\n'Components3.txt'\n,\n \n'Component declarations: '\n \n+\n \n        \nresource\n.\nallContents\n.\nfilter\n(\nKComponent\n).\nmap\n[\nname\n].\njoin\n(\n', '\n))\n\n\n}\n\n\n\n\n\n\nIn the last example we generate a text describing a list of components on \nthree different manners.\n\n\n\n\nA traditional for-each loop\n\n\nNote: \"auto-casting\" happens; this mean if a type of an inctance is \n  checked (if \u201einstanceof\u201c), \n  the object is automatically casted to that type within the \n  body of the if.\n\n\nSemicolons are optional.\n\n\n\"var\" und \"val\" are used to declare variable (val: final variables).\n\n\n\n\n\n\nA filter/map/join combination with explicit lambda (\u201e[ param | code ]\u201c)\n\n\nThe lambda function is directly defined with square brackets '['...']'.\n\n\nThe brackets '('...')' of the function call are omitted.\n\n\nThe parameter of the lambda function are stated before the \"|\"\n  within the '['..']'.\n\n\n\n\n\n\nA filter/map/join combination with compact lambdas and class filters: \n\n\nfilter(Class) filters according to the passed class \"Class\".\n\n\nmap: here, the parameter is implizit defined (and can be addressed \n  with the name \"it\": e.g., it.name). \n  Moreover, the implicit name of the parameter can be omitted,\n  thus, \"name\" corresponds to \"it.name\" here: \n  \"[a | a.name]\" \u2192 \"[name]\" oder \"[it.name]\"\n\n\n\"return\" can be omitted: The last expression is the return value.\n\n\n\n\n\n\n\n\nThe generated files contain the text:\n\n\nComponent declarations: PC, DF\n\n\n\n\n\n\nXtend template engine\n\n\nXtext and Xtend provide a powerful template engine. With this engine\noutput text and code can be easily mixed. Moreover, indentations\nin this mixed code are separated between output indentation and logical\ntemplate code indentation (see example: the indentation from the nested\nFOR statement are ignored in the output).\n\n\n    ::xtend\n    // -------------------------------------------\n    // Option 4:\n    val model = resource.contents.get(0) as Model\n    fsa.generateFile('Components4.txt', '''\n    The Components of the model are:\n    \u00abFOR p: model.packages\u00bb\n        Package \u00abp.name\u00bb\n        \u00abFOR c: p.components\u00bb\n            KComponent \u00abc.name\u00bb\n            \u00abFOR port: c.ports SEPARATOR \", \"\u00bb \n            - with port \u00abport.name\u00bb\n            \u00abENDFOR\u00bb\n        \u00abENDFOR\u00bb\n    \u00abENDFOR\u00bb\n    ''');\n\n\n\n\n\nSuch templates are defined with a multi line string bounded by\nthree single qutation marks.\nWithin the template special commands (like FOR-loops) can be \nexpressed with text bounded by french quotes.\nThe editor supports many features, such as automatic completition of model\ndata and displaying the actual indentation. \n\n\nNote:\n  * This example als illustrates how to get the\n    root of the model (val model=...).\n  * It also shows how to cast an object: \u201eobj as Type\u201c.\n\n\nOutput (generated artefact; note the indentation in the template is omitted):\n\n\nThe Components of the model are:\n\n\nPackage test1\n\n\nKComponent PC\n\n\n- with port in, \n\n\n- with port out\n\n\nKComponent DF\n\n\n- with port in, \n\n\n- with port out, \n\n\n- with port debug",
            "title": "Code Generation (with Xtend)"
        },
        {
            "location": "/xtext_code_generation_xtend/#code-generation-with-xtend",
            "text": "Xtend is highly optimized to be used\nfor code generation. It has a optimzed template engine (e.g., with\nautomatic indentation support) and\nis fully integrated in the Eclipse IDE (auto completition\nfor model data).",
            "title": "Code Generation (with Xtend)"
        },
        {
            "location": "/xtext_code_generation_xtend/#simple-example",
            "text": "Open the *Generator.xtend file in your project, e.g.,\nkurs.xtext.dataflow.generator.DataFlowDslGenerator.xtend. \nHere, you can implement your first code generator:\nYou have model access (parameter \"resource\") and file system access\n(parameter \"fsa\").  override   void   doGenerate ( Resource   resource ,   IFileSystemAccess2   fsa ,  \n         IGeneratorContext   context )   { \n     // ------------------------------------------- \n     // Option 1: \n     var   txt   =   \"\" \n     for   ( obj:   resource . allContents . toIterable )   { \n         if   ( obj   instanceof   KComponent )   {   // inside this \"if\" obj is a KComponent \n             if   ( txt . length > 0 )   txt   =   txt   +   \", \" \n             txt   =   txt   +   obj . name ; \n         } \n     } \n     fsa . generateFile ( 'Components1.txt' ,   'Component declarations: '   +   txt ); \n\n     // ------------------------------------------- \n     // Option 2: \n     fsa . generateFile ( 'Components2.txt' ,   'Component declarations: '   +  \n         resource . allContents \n             . filter [   obj   |   obj   instanceof   KComponent ] \n             . map [   obj   |   return   ( obj   as   KComponent ). name   ] \n             . join ( ', ' )) \n\n     // ------------------------------------------- \n     // Option 3: \n     fsa . generateFile ( 'Components3.txt' ,   'Component declarations: '   +  \n         resource . allContents . filter ( KComponent ). map [ name ]. join ( ', ' ))  }   In the last example we generate a text describing a list of components on \nthree different manners.   A traditional for-each loop  Note: \"auto-casting\" happens; this mean if a type of an inctance is \n  checked (if \u201einstanceof\u201c), \n  the object is automatically casted to that type within the \n  body of the if.  Semicolons are optional.  \"var\" und \"val\" are used to declare variable (val: final variables).    A filter/map/join combination with explicit lambda (\u201e[ param | code ]\u201c)  The lambda function is directly defined with square brackets '['...']'.  The brackets '('...')' of the function call are omitted.  The parameter of the lambda function are stated before the \"|\"\n  within the '['..']'.    A filter/map/join combination with compact lambdas and class filters:   filter(Class) filters according to the passed class \"Class\".  map: here, the parameter is implizit defined (and can be addressed \n  with the name \"it\": e.g., it.name). \n  Moreover, the implicit name of the parameter can be omitted,\n  thus, \"name\" corresponds to \"it.name\" here: \n  \"[a | a.name]\" \u2192 \"[name]\" oder \"[it.name]\"  \"return\" can be omitted: The last expression is the return value.     The generated files contain the text:  Component declarations: PC, DF",
            "title": "Simple Example"
        },
        {
            "location": "/xtext_code_generation_xtend/#xtend-template-engine",
            "text": "Xtext and Xtend provide a powerful template engine. With this engine\noutput text and code can be easily mixed. Moreover, indentations\nin this mixed code are separated between output indentation and logical\ntemplate code indentation (see example: the indentation from the nested\nFOR statement are ignored in the output).      ::xtend\n    // -------------------------------------------\n    // Option 4:\n    val model = resource.contents.get(0) as Model\n    fsa.generateFile('Components4.txt', '''\n    The Components of the model are:\n    \u00abFOR p: model.packages\u00bb\n        Package \u00abp.name\u00bb\n        \u00abFOR c: p.components\u00bb\n            KComponent \u00abc.name\u00bb\n            \u00abFOR port: c.ports SEPARATOR \", \"\u00bb \n            - with port \u00abport.name\u00bb\n            \u00abENDFOR\u00bb\n        \u00abENDFOR\u00bb\n    \u00abENDFOR\u00bb\n    ''');  Such templates are defined with a multi line string bounded by\nthree single qutation marks.\nWithin the template special commands (like FOR-loops) can be \nexpressed with text bounded by french quotes.\nThe editor supports many features, such as automatic completition of model\ndata and displaying the actual indentation.   Note:\n  * This example als illustrates how to get the\n    root of the model (val model=...).\n  * It also shows how to cast an object: \u201eobj as Type\u201c.  Output (generated artefact; note the indentation in the template is omitted):  The Components of the model are:  Package test1  KComponent PC  - with port in,   - with port out  KComponent DF  - with port in,   - with port out,   - with port debug",
            "title": "Xtend template engine"
        },
        {
            "location": "/xtext_xtend/",
            "text": "Xtend: Selected Aspects\n\n\nIn addition to the features sketched in the\n\n\"code generation with Xtend\" section\n\nthis section provides some selected aspects we found useful for our work.\n\n\nExtension mechanism\n\n\nXtend has its name from the the fact that it allows to extend classes of\nthe language without using inheritance. There are different possibilities\nto achieve this task. One simple example of such an extended class \nis java.lang.String, which was extended by Xtend to provide \na method \"toFirstUpper\".\n\n\nA simple possibility to achieve such an extension is to define a locally\nvisible method \"\nf(\nTypeX x, \n...)\n\" (see \nXtend documentation\n).\nWith this, TypeX is extened by a method \nf(...)\n.\n\n\ndef\n \nprintNTimes\n(\nString\n \ns\n,\n \nint\n \nn\n)\n \n{\n\n    \nfor\n(\nvar\n \ni\n=\n0\n;\ni\n<\nn\n;\ni\n++)\n \nprintln\n(\ns\n)\n\n\n}\n\n\n\n...\n     \n    \n\"Hello\"\n.\nprintNTimes\n(\n3\n)\n\n\n...\n\n\n\n\n\n\nOther possibilities (see \nXtend documentation\n) \nallow to use static methods in a similar way (\"extension imports\") which can\nbe imported by other modules: \n\"import static extension package.Type.printNTimes\".\n\n\nDispatch methods\n\n\nA method (used as extension of not) can be marked with the keyword \n\"\ndispatch\n\". If such a method is defined multiple times with different \nspecialized types as argument, the correct version of the method if called\ndepending what object is passed (runtime polymorphy). The code behaves if\nan \"if obj instanceof TYPE\" is called to determine which version has to be called.\n\n\nMisc\n\n\n\n\n\u201e==\u201c vs. \u201e===\u201c (analog \u201e!=\u201c vs. \u201e!==\u201c):\n\n\n\u201e==\u201c uses the method \"equals\" to determine the result.\n\n\n\u201e===\u201c checks if the identical object is referenced (like a pointer comparison).\n\n\n\n\n\n\nIt is posisble to check if an optional modell element is present or not\n    by comparing it to null.\n\n\nIt is possible to check if a model element is not yet loaded\n    (eIsProxy==true).\n\n\n\n\nEMF Parent Relationship (model mavigation)\n\n\nSometimes (while generating code or validating the model)\nit is useful to navigate to the parent of a model object.\nThis can be done with the attribute \"eContainer\" of every model\nelement. It may be necessary to cast this parent to an appropriate type\n(this can also happen via a dispatch method).",
            "title": "Xtend: Selected Aspects"
        },
        {
            "location": "/xtext_xtend/#xtend-selected-aspects",
            "text": "In addition to the features sketched in the \"code generation with Xtend\" section \nthis section provides some selected aspects we found useful for our work.",
            "title": "Xtend: Selected Aspects"
        },
        {
            "location": "/xtext_xtend/#extension-mechanism",
            "text": "Xtend has its name from the the fact that it allows to extend classes of\nthe language without using inheritance. There are different possibilities\nto achieve this task. One simple example of such an extended class \nis java.lang.String, which was extended by Xtend to provide \na method \"toFirstUpper\".  A simple possibility to achieve such an extension is to define a locally\nvisible method \" f( TypeX x,  ...) \" (see  Xtend documentation ).\nWith this, TypeX is extened by a method  f(...) .  def   printNTimes ( String   s ,   int   n )   { \n     for ( var   i = 0 ; i < n ; i ++)   println ( s )  }  ...      \n     \"Hello\" . printNTimes ( 3 )  ...   Other possibilities (see  Xtend documentation ) \nallow to use static methods in a similar way (\"extension imports\") which can\nbe imported by other modules: \n\"import static extension package.Type.printNTimes\".",
            "title": "Extension mechanism"
        },
        {
            "location": "/xtext_xtend/#dispatch-methods",
            "text": "A method (used as extension of not) can be marked with the keyword \n\" dispatch \". If such a method is defined multiple times with different \nspecialized types as argument, the correct version of the method if called\ndepending what object is passed (runtime polymorphy). The code behaves if\nan \"if obj instanceof TYPE\" is called to determine which version has to be called.",
            "title": "Dispatch methods"
        },
        {
            "location": "/xtext_xtend/#misc",
            "text": "\u201e==\u201c vs. \u201e===\u201c (analog \u201e!=\u201c vs. \u201e!==\u201c):  \u201e==\u201c uses the method \"equals\" to determine the result.  \u201e===\u201c checks if the identical object is referenced (like a pointer comparison).    It is posisble to check if an optional modell element is present or not\n    by comparing it to null.  It is possible to check if a model element is not yet loaded\n    (eIsProxy==true).",
            "title": "Misc"
        },
        {
            "location": "/xtext_xtend/#emf-parent-relationship-model-mavigation",
            "text": "Sometimes (while generating code or validating the model)\nit is useful to navigate to the parent of a model object.\nThis can be done with the attribute \"eContainer\" of every model\nelement. It may be necessary to cast this parent to an appropriate type\n(this can also happen via a dispatch method).",
            "title": "EMF Parent Relationship (model mavigation)"
        },
        {
            "location": "/textx_intro/",
            "text": "TextX Intro\n\n\nTextX is a Python library to allow an easy creation of\nDSL validators and artifact generators:\n\n\n\n\nReading model files (grammar based parsing, reference resolution and post processing).\n\n\nValidating the model.\n\n\nGenerating output artifacts (e.g., code).\n\n\n\n\nA fundamental difference to Xtext is that the\nmeta model classes (describing the model elements)\nare dynamically generated instead of generating code\nfrom them. Thus, a grammar in TextX in interpreted dynamically \nand not compiled.\n\n\nTextX has only few dependencies and very compact \nprojects can be created. Details see\n\n(Dejanovi\u0107 et al. 2017)\n\nand the \"TextX project page\", see \n(TextX)\n.\n\n\nNormally, a similar modularization as for Xtext projects \nis employed to separate different responsibilities across\nsoftware modules (e.g. modules for the \ngrammar, validation, and code generation). \nHowever, it is possible to put an entire project\nincluding grammar and the validation into one file:\nthe following code illustrates a meta model with an example model\nwhich is validated (similar to the example in the \n\nintroductory example of validation\n).\n\n\n\n\nfrom\n \ntextx\n \nimport\n \nmetamodel_from_str\n\n\nfrom\n \ntextx.scoping.providers\n \nimport\n \nRelativeName\n,\n \nFQN\n\n\nfrom\n \ntextx.export\n \nimport\n \nmodel_export\n\n\n# ------------------------------------\n\n\n# GRAMMAR\n\n\n#\n\n\nmeta_model\n \n=\n \nmetamodel_from_str\n(\n'''\n\n\n    Model: aspects+=Aspect scenarios+=Scenario testcases+=Testcase;\n\n\n    Scenario: 'SCENARIO' name=ID 'BEGIN' \n\n\n        configs+=Config\n\n\n    'END';\n\n\n    Config: 'CONFIG' name=ID 'HAS' '(' haves*=[Aspect] ')';\n\n\n    Aspect: 'ASPECT' name=ID;\n\n\n    Testcase: 'TESTCASE' name=ID 'BEGIN'\n\n\n        'USES' scenario=[Scenario] 'WITH' config=[Config]\n\n\n        'NEEDS' '(' needs*=[Aspect] ')'\n\n\n    'END';\n\n\n    Comment: /\\/\\/.*/;\n\n\n'''\n)\n\n\n\n# ------------------------------------\n\n\n# SCOPING\n\n\n#\n\n\nmeta_model\n.\nregister_scope_providers\n({\n\n    \n'*.*'\n:\n \nFQN\n(),\n\n    \n'Testcase.config'\n:\n \nRelativeName\n(\n'scenario.configs'\n)\n\n\n})\n\n\n\n# ------------------------------------\n\n\n# VALIDATION\n\n\n#\n\n\ndef\n \ncheck_testcase\n(\ntestcase\n):\n\n    \n\"\"\"\n\n\n    checks that the config used by the testcase fulfills its needs\n\n\n    \"\"\"\n\n    \nfor\n \nneed\n \nin\n \ntestcase\n.\nneeds\n:\n\n        \nif\n \nneed\n \nnot\n \nin\n \ntestcase\n.\nconfig\n.\nhaves\n:\n\n            \nraise\n \nException\n(\n\"{}: {} not found in {}.{}\"\n.\nformat\n(\n\n                    \ntestcase\n.\nname\n,\n\n                    \nneed\n.\nname\n,\n \n                    \ntestcase\n.\nscenario\n.\nname\n,\n\n                    \ntestcase\n.\nconfig\n.\nname\n\n                    \n))\n\n\n\nmeta_model\n.\nregister_obj_processors\n({\n\n        \n'Testcase'\n:\n \ncheck_testcase\n\n\n})\n\n\n\n# ------------------------------------\n\n\n# EXAMPLE\n\n\n#\n\n\nmodel\n \n=\n \nmeta_model\n.\nmodel_from_str\n(\n'''\n\n\n    ASPECT NetworkTraffic\n\n\n    ASPECT FileAccess\n\n\n    SCENARIO S001 BEGIN\n\n\n        CONFIG HeavyNetworkTraffic HAS (NetworkTraffic)\n\n\n        CONFIG NoNetworkTraffic HAS ()\n\n\n    END\n\n\n    SCENARIO S002 BEGIN\n\n\n        CONFIG WithFileAccess HAS (NetworkTraffic FileAccess)\n\n\n        CONFIG NoFileAccess HAS (NetworkTraffic)\n\n\n    END\n\n\n    TESTCASE T001 BEGIN\n\n\n        USES S001 WITH HeavyNetworkTraffic\n\n\n        NEEDS (NetworkTraffic)\n\n\n    END\n\n\n    TESTCASE T002 BEGIN\n\n\n        //USES S001 WITH NoNetworkTraffic // Error\n\n\n        USES S002 WITH NoFileAccess\n\n\n        NEEDS (NetworkTraffic)\n\n\n    END\n\n\n'''\n)\n\n\n\nmodel_export\n(\nmodel\n,\n \n'model.dot'\n)",
            "title": "TextX Intro"
        },
        {
            "location": "/textx_intro/#textx-intro",
            "text": "TextX is a Python library to allow an easy creation of\nDSL validators and artifact generators:   Reading model files (grammar based parsing, reference resolution and post processing).  Validating the model.  Generating output artifacts (e.g., code).   A fundamental difference to Xtext is that the\nmeta model classes (describing the model elements)\nare dynamically generated instead of generating code\nfrom them. Thus, a grammar in TextX in interpreted dynamically \nand not compiled.  TextX has only few dependencies and very compact \nprojects can be created. Details see (Dejanovi\u0107 et al. 2017) \nand the \"TextX project page\", see  (TextX) .  Normally, a similar modularization as for Xtext projects \nis employed to separate different responsibilities across\nsoftware modules (e.g. modules for the \ngrammar, validation, and code generation). \nHowever, it is possible to put an entire project\nincluding grammar and the validation into one file:\nthe following code illustrates a meta model with an example model\nwhich is validated (similar to the example in the  introductory example of validation ).   from   textx   import   metamodel_from_str  from   textx.scoping.providers   import   RelativeName ,   FQN  from   textx.export   import   model_export  # ------------------------------------  # GRAMMAR  #  meta_model   =   metamodel_from_str ( '''      Model: aspects+=Aspect scenarios+=Scenario testcases+=Testcase;      Scenario: 'SCENARIO' name=ID 'BEGIN'           configs+=Config      'END';      Config: 'CONFIG' name=ID 'HAS' '(' haves*=[Aspect] ')';      Aspect: 'ASPECT' name=ID;      Testcase: 'TESTCASE' name=ID 'BEGIN'          'USES' scenario=[Scenario] 'WITH' config=[Config]          'NEEDS' '(' needs*=[Aspect] ')'      'END';      Comment: /\\/\\/.*/;  ''' )  # ------------------------------------  # SCOPING  #  meta_model . register_scope_providers ({ \n     '*.*' :   FQN (), \n     'Testcase.config' :   RelativeName ( 'scenario.configs' )  })  # ------------------------------------  # VALIDATION  #  def   check_testcase ( testcase ): \n     \"\"\"      checks that the config used by the testcase fulfills its needs      \"\"\" \n     for   need   in   testcase . needs : \n         if   need   not   in   testcase . config . haves : \n             raise   Exception ( \"{}: {} not found in {}.{}\" . format ( \n                     testcase . name , \n                     need . name ,  \n                     testcase . scenario . name , \n                     testcase . config . name \n                     ))  meta_model . register_obj_processors ({ \n         'Testcase' :   check_testcase  })  # ------------------------------------  # EXAMPLE  #  model   =   meta_model . model_from_str ( '''      ASPECT NetworkTraffic      ASPECT FileAccess      SCENARIO S001 BEGIN          CONFIG HeavyNetworkTraffic HAS (NetworkTraffic)          CONFIG NoNetworkTraffic HAS ()      END      SCENARIO S002 BEGIN          CONFIG WithFileAccess HAS (NetworkTraffic FileAccess)          CONFIG NoFileAccess HAS (NetworkTraffic)      END      TESTCASE T001 BEGIN          USES S001 WITH HeavyNetworkTraffic          NEEDS (NetworkTraffic)      END      TESTCASE T002 BEGIN          //USES S001 WITH NoNetworkTraffic // Error          USES S002 WITH NoFileAccess          NEEDS (NetworkTraffic)      END  ''' )  model_export ( model ,   'model.dot' )",
            "title": "TextX Intro"
        },
        {
            "location": "/textx_project_setup/",
            "text": "TextX Project Setup\n\n\nWe give a guide to create a simple\ncommand line tool to load and validate a\nmodel and to generate some artifact.\n\n\nIn this example, we propose different models for\nthe \nmeta model structure\n (grammar), the \nscoping\n,\nand the \n artifact generation\n. Moreover, a \n\nmain\n and a \nsetup\n script are added to control\nthe software.\n\n\nFor this example we use Python 3. You need to install \n\n\n\n\nTextX (see \nreferences\n).\n\n\nArpeggio (see TextX in \nreferences\n)\n\n\npytest (for unittests)\n\n\n\n\nUsing pip you can:\n\n\npip3 install --upgrade textx arpeggio pytest\n\n\n\n\n\nFile structure\n\n\nAlthough everything can be packed within one file\n(see \n\"TextX Intro\"\n), the code\nis better structured into different modules \nwith individual responsibilities into different files.\n\n\n\u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 simple_dsl\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 codegen.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 console\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 validate.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 metamodel.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 validation.py\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 models\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 model_not_ok.dsl\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 model_ok.dsl\n    \u2514\u2500\u2500 test_validation.py\n\n\n\n\n\nWe have chosen a distribution as follows:\n\n\n\n\nsetup.py is the standard python project configuration\n\n\nsimple_dsl contain all dsl related logic:\n\n\ncodegen.py: code generation.\n\n\nmetamodel.py: the meta model (grammar, scoping and validation config;\n  the user classes are also stored herem but could be moved\n  elsewhere for more complex projects.   \n\n\nvalidation.py: validation logic.\n\n\nconsole/*.py: console programs (configured in setup.py).\n\n\n__init__.py represent module entry points.\n\n\n\n\n\n\ntests contains unittests.\n\n\n\n\nFile: metamodel.py\n\n\nHere, we define the grammar. We allocate the scope providers to\nindividual elements, and register validation code.\n\n\nfrom\n \ntextx\n \nimport\n \nmetamodel_from_str\n\n\nfrom\n \ntextx.scoping.providers\n \nimport\n \nRelativeName\n,\n \nFQN\n\n\nimport\n \nsimple_dsl.validation\n \nas\n \nvalidation\n\n\n\ndef\n \nget_metamodel\n():\n\n    \n# GRAMMAR\n\n    \n# (you also use metamodel_from_file with a *.tx file)\n\n    \nmeta_model\n \n=\n \nmetamodel_from_str\n(\n'''\n\n\n        Model: aspects+=Aspect scenarios+=Scenario testcases+=Testcase;\n\n\n        Scenario: 'SCENARIO' name=ID 'BEGIN' \n\n\n            configs+=Config\n\n\n        'END';\n\n\n        Config: 'CONFIG' name=ID 'HAS' '(' haves*=[Aspect] ')';\n\n\n        Aspect: 'ASPECT' name=ID;\n\n\n        Testcase: 'TESTCASE' name=ID 'BEGIN'\n\n\n            'USES' scenario=[Scenario] 'WITH' config=[Config]\n\n\n            'NEEDS' '(' needs*=[Aspect] ')'\n\n\n        'END';\n\n\n        Comment: /\\/\\/.*/;\n\n\n    '''\n)\n\n\n    \n# SCOPING\n\n    \nmeta_model\n.\nregister_scope_providers\n({\n\n        \n'*.*'\n:\n \nFQN\n(),\n\n        \n'Testcase.config'\n:\n \nRelativeName\n(\n'scenario.configs'\n)\n\n    \n})\n\n\n    \n# ADD VALIDATION\n\n    \nmeta_model\n.\nregister_obj_processors\n({\n\n            \n'Testcase'\n:\n \nvalidation\n.\ncheck_testcase\n\n    \n})\n\n\n    \nreturn\n \nmeta_model\n\n\n\n\n\n\nFile:: validation.py\n\n\nThis file contains validation functions registered in the meta model.\n\n\nfrom\n \ntextx.exceptions\n \nimport\n \nTextXError\n\n\nfrom\n \ntextx.scoping.tools\n \nimport\n \nget_location\n\n\n\ndef\n \ncheck_testcase\n(\ntestcase\n):\n\n    \n\"\"\"\n\n\n    checks that the config used by the testcase fulfills its needs\n\n\n    \"\"\"\n\n    \nfor\n \nneed\n \nin\n \ntestcase\n.\nneeds\n:\n\n        \nif\n \nneed\n \nnot\n \nin\n \ntestcase\n.\nconfig\n.\nhaves\n:\n\n            \nraise\n \n(\nTextXError\n(\n\"{}: {} not found in {}.{}\"\n.\nformat\n(\n\n                    \ntestcase\n.\nname\n,\n\n                    \nneed\n.\nname\n,\n \n                    \ntestcase\n.\nscenario\n.\nname\n,\n\n                    \ntestcase\n.\nconfig\n.\nname\n\n                    \n),\n\n                \n**\nget_location\n(\ntestcase\n)\n \n# unpack location info\n\n            \n))\n\n\n\n\n\n\nFile: tests/test_validation.py\n\n\nThis file is a unittest using the metamodel \n(exposed via __init__.py) and checks the\ncorrect functionality of the validation code.\n\n\nfrom\n \npytest\n \nimport\n \nraises\n\n\nfrom\n \nsimple_dsl\n \nimport\n \nget_metamodel\n\n\nfrom\n \nos.path\n \nimport\n \ndirname\n,\n \njoin\n\n\nfrom\n \ntextx\n \nimport\n \nget_children_of_type\n\n\n\ndef\n \ntest_validation_ok\n():\n\n    \nmm\n \n=\n \nget_metamodel\n()\n\n    \nm\n \n=\n \nmm\n.\nmodel_from_file\n(\njoin\n(\ndirname\n(\n__file__\n),\n\n                            \n'models'\n,\n\n                            \n'model_ok.dsl'\n))\n\n    \nassert\n \n2\n==\nlen\n(\nget_children_of_type\n(\n'Aspect'\n,\nm\n))\n\n\n\ndef\n \ntest_validation_not_ok\n():\n\n    \nmm\n \n=\n \nget_metamodel\n()\n\n    \nwith\n \nraises\n(\nException\n,\n\n                \nmatch\n=\nr\n'NetworkTraffic.*not found.*S001.*NoNetworkTraffic'\n):\n\n        \n_\n \n=\n \nmm\n.\nmodel_from_file\n(\njoin\n(\ndirname\n(\n__file__\n),\n\n                                \n'models'\n,\n\n                                \n'model_not_ok.dsl'\n))\n\n\n\n\n\n\nThe two model files used in this tests are shown in the following \nsubsections.\n\n\nModel: tests/models/model_ok.dsl\n\n\nASPECT\n \nNetworkTraffic\n\n\nASPECT\n \nFileAccess\n\n\nSCENARIO\n \nS001\n \nBEGIN\n\n    \nCONFIG\n \nHeavyNetworkTraffic\n \nHAS\n \n(\nNetworkTraffic\n)\n\n    \nCONFIG\n \nNoNetworkTraffic\n \nHAS\n \n()\n\n\nEND\n\n\nSCENARIO\n \nS002\n \nBEGIN\n\n    \nCONFIG\n \nWithFileAccess\n \nHAS\n \n(\nNetworkTraffic\n \nFileAccess\n)\n\n    \nCONFIG\n \nNoFileAccess\n \nHAS\n \n(\nNetworkTraffic\n)\n\n\nEND\n\n\nTESTCASE\n \nT001\n \nBEGIN\n\n    \nUSES\n \nS001\n \nWITH\n \nHeavyNetworkTraffic\n\n    \nNEEDS\n \n(\nNetworkTraffic\n)\n\n\nEND\n\n\nTESTCASE\n \nT002\n \nBEGIN\n\n    \nUSES\n \nS001\n \nWITH\n \nNoNetworkTraffic\n \n// Error\n\n    \n//USES S002 WITH NoFileAccess\n\n    \nNEEDS\n \n(\nNetworkTraffic\n)\n\n\nEND\n\n\n\n\n\n\nModel: tests/models/model_not_ok.dsl\n\n\nASPECT\n \nNetworkTraffic\n\n\nASPECT\n \nFileAccess\n\n\nSCENARIO\n \nS001\n \nBEGIN\n\n    \nCONFIG\n \nHeavyNetworkTraffic\n \nHAS\n \n(\nNetworkTraffic\n)\n\n    \nCONFIG\n \nNoNetworkTraffic\n \nHAS\n \n()\n\n\nEND\n\n\nSCENARIO\n \nS002\n \nBEGIN\n\n    \nCONFIG\n \nWithFileAccess\n \nHAS\n \n(\nNetworkTraffic\n \nFileAccess\n)\n\n    \nCONFIG\n \nNoFileAccess\n \nHAS\n \n(\nNetworkTraffic\n)\n\n\nEND\n\n\nTESTCASE\n \nT001\n \nBEGIN\n\n    \nUSES\n \nS001\n \nWITH\n \nHeavyNetworkTraffic\n\n    \nNEEDS\n \n(\nNetworkTraffic\n)\n\n\nEND\n\n\nTESTCASE\n \nT002\n \nBEGIN\n\n    \n//USES S001 WITH NoNetworkTraffic // Error\n\n    \nUSES\n \nS002\n \nWITH\n \nNoFileAccess\n\n    \nNEEDS\n \n(\nNetworkTraffic\n)\n\n\nEND\n\n\n\n\n\n\nEdit, Run and Test\n\n\nUse an appropriate IDE (e.g., PyCharm) to run the tests and, thus, test and debug your \nnew language.\n\n\nInstall/Uninstall the Language\n\n\nAfter all tests passed you can try to install your language.\nDo not forget to adapt setup.py:\n\n\nfrom\n \nsetuptools\n \nimport\n \nsetup\n,\nfind_packages\n\n\n\nsetup\n(\nname\n=\n'simple_dsl'\n,\n\n      \nversion\n=\n'0.1'\n,\n\n      \ndescription\n=\n'a simple model validator and artifact compiler'\n,\n\n      \nurl\n=\n''\n,\n\n      \nauthor\n=\n'YOUR NAME'\n,\n\n      \nauthor_email\n=\n'YOUR.NAME@ADDRESS'\n,\n\n      \nlicense\n=\n'TODO'\n,\n\n      \npackages\n=\nfind_packages\n(),\n\n      \npackage_data\n=\n{\n''\n:\n \n[\n'*.tx'\n,\n \n'*.template'\n,\n \n'support_*_code/**/*'\n]},\n\n      \ninstall_requires\n=\n[\n\"textx\"\n,\n\"arpeggio\"\n],\n\n      \ntests_require\n=\n[\n\n          \n'pytest'\n,\n\n      \n],\n\n      \nkeywords\n=\n\"parser meta-language meta-model language DSL\"\n,\n\n      \nentry_points\n=\n{\n\n          \n'console_scripts'\n:\n \n[\n\n              \n'simple_dsl_validate=simple_dsl.console.validate:validate'\n,\n\n          \n]\n\n      \n},\n\n      \n)\n\n\n\n\n# to play around without installing: do \"export PYTHONPATH=.\"\n\n\n\n\n\n\nThe registered console command (validate.py) contains:\n\n\nimport\n \nargparse\n\n\nfrom\n \nsimple_dsl\n \nimport\n \nget_metamodel\n\n\n\ndef\n \nvalidate\n():\n\n    \nmm\n \n=\n \nget_metamodel\n()\n\n    \nparser\n \n=\n \nargparse\n.\nArgumentParser\n(\ndescription\n=\n'validate simple_dsl files.'\n)\n\n    \nparser\n.\nadd_argument\n(\n'model_files'\n,\n \nmetavar\n=\n'model_files'\n,\n \ntype\n=\nstr\n,\n\n                        \nnargs\n=\n'+'\n,\n\n                        \nhelp\n=\n'model filenames'\n)\n\n    \nargs\n \n=\n \nparser\n.\nparse_args\n()\n\n\n    \nfor\n \nfilename\n \nin\n \nargs\n.\nmodel_files\n:\n\n        \ntry\n:\n\n            \nprint\n(\n'validating {}'\n.\nformat\n(\nfilename\n))\n\n            \n_\n \n=\n \nmm\n.\nmodel_from_file\n(\nfilename\n)\n\n        \nexcept\n \nBaseException\n \nas\n \ne\n:\n\n            \nprint\n(\n'  WARNING/ERROR: {}'\n.\nformat\n(\ne\n))\n\n\n\n\nif\n \n__name__\n==\n'__main__'\n:\n\n    \nvalidate\n()\n\n\n\n\n\n\nInstallation\n\n\nInstall\n the software \npermanently for all users\n (change directory\nto the folder with the setup.py file):\n\n\nsudo -H pip3 install --upgrade .\n\n\n\n\n\nYou can now start the new commands defined in the setup.py: \n\n\nsimple_dsl_validate --help\n\n\n\n\n\nUninstallation\n\n\nUninstall\n the software:\n\n\nsudo -H pip3 uninstall simple_dsl",
            "title": "TextX Project Setup"
        },
        {
            "location": "/textx_project_setup/#textx-project-setup",
            "text": "We give a guide to create a simple\ncommand line tool to load and validate a\nmodel and to generate some artifact.  In this example, we propose different models for\nthe  meta model structure  (grammar), the  scoping ,\nand the   artifact generation . Moreover, a  main  and a  setup  script are added to control\nthe software.  For this example we use Python 3. You need to install    TextX (see  references ).  Arpeggio (see TextX in  references )  pytest (for unittests)   Using pip you can:  pip3 install --upgrade textx arpeggio pytest",
            "title": "TextX Project Setup"
        },
        {
            "location": "/textx_project_setup/#file-structure",
            "text": "Although everything can be packed within one file\n(see  \"TextX Intro\" ), the code\nis better structured into different modules \nwith individual responsibilities into different files.  \u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 simple_dsl\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 codegen.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 console\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 validate.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 metamodel.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 validation.py\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 models\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 model_not_ok.dsl\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 model_ok.dsl\n    \u2514\u2500\u2500 test_validation.py  We have chosen a distribution as follows:   setup.py is the standard python project configuration  simple_dsl contain all dsl related logic:  codegen.py: code generation.  metamodel.py: the meta model (grammar, scoping and validation config;\n  the user classes are also stored herem but could be moved\n  elsewhere for more complex projects.     validation.py: validation logic.  console/*.py: console programs (configured in setup.py).  __init__.py represent module entry points.    tests contains unittests.",
            "title": "File structure"
        },
        {
            "location": "/textx_project_setup/#file-metamodelpy",
            "text": "Here, we define the grammar. We allocate the scope providers to\nindividual elements, and register validation code.  from   textx   import   metamodel_from_str  from   textx.scoping.providers   import   RelativeName ,   FQN  import   simple_dsl.validation   as   validation  def   get_metamodel (): \n     # GRAMMAR \n     # (you also use metamodel_from_file with a *.tx file) \n     meta_model   =   metamodel_from_str ( '''          Model: aspects+=Aspect scenarios+=Scenario testcases+=Testcase;          Scenario: 'SCENARIO' name=ID 'BEGIN'               configs+=Config          'END';          Config: 'CONFIG' name=ID 'HAS' '(' haves*=[Aspect] ')';          Aspect: 'ASPECT' name=ID;          Testcase: 'TESTCASE' name=ID 'BEGIN'              'USES' scenario=[Scenario] 'WITH' config=[Config]              'NEEDS' '(' needs*=[Aspect] ')'          'END';          Comment: /\\/\\/.*/;      ''' ) \n\n     # SCOPING \n     meta_model . register_scope_providers ({ \n         '*.*' :   FQN (), \n         'Testcase.config' :   RelativeName ( 'scenario.configs' ) \n     }) \n\n     # ADD VALIDATION \n     meta_model . register_obj_processors ({ \n             'Testcase' :   validation . check_testcase \n     }) \n\n     return   meta_model",
            "title": "File: metamodel.py"
        },
        {
            "location": "/textx_project_setup/#file-validationpy",
            "text": "This file contains validation functions registered in the meta model.  from   textx.exceptions   import   TextXError  from   textx.scoping.tools   import   get_location  def   check_testcase ( testcase ): \n     \"\"\"      checks that the config used by the testcase fulfills its needs      \"\"\" \n     for   need   in   testcase . needs : \n         if   need   not   in   testcase . config . haves : \n             raise   ( TextXError ( \"{}: {} not found in {}.{}\" . format ( \n                     testcase . name , \n                     need . name ,  \n                     testcase . scenario . name , \n                     testcase . config . name \n                     ), \n                 ** get_location ( testcase )   # unpack location info \n             ))",
            "title": "File:: validation.py"
        },
        {
            "location": "/textx_project_setup/#file-teststest_validationpy",
            "text": "This file is a unittest using the metamodel \n(exposed via __init__.py) and checks the\ncorrect functionality of the validation code.  from   pytest   import   raises  from   simple_dsl   import   get_metamodel  from   os.path   import   dirname ,   join  from   textx   import   get_children_of_type  def   test_validation_ok (): \n     mm   =   get_metamodel () \n     m   =   mm . model_from_file ( join ( dirname ( __file__ ), \n                             'models' , \n                             'model_ok.dsl' )) \n     assert   2 == len ( get_children_of_type ( 'Aspect' , m ))  def   test_validation_not_ok (): \n     mm   =   get_metamodel () \n     with   raises ( Exception , \n                 match = r 'NetworkTraffic.*not found.*S001.*NoNetworkTraffic' ): \n         _   =   mm . model_from_file ( join ( dirname ( __file__ ), \n                                 'models' , \n                                 'model_not_ok.dsl' ))   The two model files used in this tests are shown in the following \nsubsections.",
            "title": "File: tests/test_validation.py"
        },
        {
            "location": "/textx_project_setup/#model-testsmodelsmodel_okdsl",
            "text": "ASPECT   NetworkTraffic  ASPECT   FileAccess  SCENARIO   S001   BEGIN \n     CONFIG   HeavyNetworkTraffic   HAS   ( NetworkTraffic ) \n     CONFIG   NoNetworkTraffic   HAS   ()  END  SCENARIO   S002   BEGIN \n     CONFIG   WithFileAccess   HAS   ( NetworkTraffic   FileAccess ) \n     CONFIG   NoFileAccess   HAS   ( NetworkTraffic )  END  TESTCASE   T001   BEGIN \n     USES   S001   WITH   HeavyNetworkTraffic \n     NEEDS   ( NetworkTraffic )  END  TESTCASE   T002   BEGIN \n     USES   S001   WITH   NoNetworkTraffic   // Error \n     //USES S002 WITH NoFileAccess \n     NEEDS   ( NetworkTraffic )  END",
            "title": "Model: tests/models/model_ok.dsl"
        },
        {
            "location": "/textx_project_setup/#model-testsmodelsmodel_not_okdsl",
            "text": "ASPECT   NetworkTraffic  ASPECT   FileAccess  SCENARIO   S001   BEGIN \n     CONFIG   HeavyNetworkTraffic   HAS   ( NetworkTraffic ) \n     CONFIG   NoNetworkTraffic   HAS   ()  END  SCENARIO   S002   BEGIN \n     CONFIG   WithFileAccess   HAS   ( NetworkTraffic   FileAccess ) \n     CONFIG   NoFileAccess   HAS   ( NetworkTraffic )  END  TESTCASE   T001   BEGIN \n     USES   S001   WITH   HeavyNetworkTraffic \n     NEEDS   ( NetworkTraffic )  END  TESTCASE   T002   BEGIN \n     //USES S001 WITH NoNetworkTraffic // Error \n     USES   S002   WITH   NoFileAccess \n     NEEDS   ( NetworkTraffic )  END",
            "title": "Model: tests/models/model_not_ok.dsl"
        },
        {
            "location": "/textx_project_setup/#edit-run-and-test",
            "text": "Use an appropriate IDE (e.g., PyCharm) to run the tests and, thus, test and debug your \nnew language.",
            "title": "Edit, Run and Test"
        },
        {
            "location": "/textx_project_setup/#installuninstall-the-language",
            "text": "After all tests passed you can try to install your language.\nDo not forget to adapt setup.py:  from   setuptools   import   setup , find_packages  setup ( name = 'simple_dsl' , \n       version = '0.1' , \n       description = 'a simple model validator and artifact compiler' , \n       url = '' , \n       author = 'YOUR NAME' , \n       author_email = 'YOUR.NAME@ADDRESS' , \n       license = 'TODO' , \n       packages = find_packages (), \n       package_data = { '' :   [ '*.tx' ,   '*.template' ,   'support_*_code/**/*' ]}, \n       install_requires = [ \"textx\" , \"arpeggio\" ], \n       tests_require = [ \n           'pytest' , \n       ], \n       keywords = \"parser meta-language meta-model language DSL\" , \n       entry_points = { \n           'console_scripts' :   [ \n               'simple_dsl_validate=simple_dsl.console.validate:validate' , \n           ] \n       }, \n       )  # to play around without installing: do \"export PYTHONPATH=.\"   The registered console command (validate.py) contains:  import   argparse  from   simple_dsl   import   get_metamodel  def   validate (): \n     mm   =   get_metamodel () \n     parser   =   argparse . ArgumentParser ( description = 'validate simple_dsl files.' ) \n     parser . add_argument ( 'model_files' ,   metavar = 'model_files' ,   type = str , \n                         nargs = '+' , \n                         help = 'model filenames' ) \n     args   =   parser . parse_args () \n\n     for   filename   in   args . model_files : \n         try : \n             print ( 'validating {}' . format ( filename )) \n             _   =   mm . model_from_file ( filename ) \n         except   BaseException   as   e : \n             print ( '  WARNING/ERROR: {}' . format ( e ))  if   __name__ == '__main__' : \n     validate ()",
            "title": "Install/Uninstall the Language"
        },
        {
            "location": "/textx_project_setup/#installation",
            "text": "Install  the software  permanently for all users  (change directory\nto the folder with the setup.py file):  sudo -H pip3 install --upgrade .  You can now start the new commands defined in the setup.py:   simple_dsl_validate --help",
            "title": "Installation"
        },
        {
            "location": "/textx_project_setup/#uninstallation",
            "text": "Uninstall  the software:  sudo -H pip3 uninstall simple_dsl",
            "title": "Uninstallation"
        },
        {
            "location": "/textx_by_examples/",
            "text": "TextX by Examples\n\n\nThe TextX project page gives a nice introduction \nto the concepts of TextX \n(TextX)\n.\nRead the docs to explore different aspects, like\nthe grammar or scoping. The unittests are\nalso a great source of information, because they contain\nmany examples for different topics.\n\n\nNote: validators are implemented as so-called object_processors.\nThese object_processors are meant to post process the\nparsed model (possibly modifying the model). They can also\nbe used to raise exceptions in order to indicate a logical\ndomain error (as in the \ninitial example\n).",
            "title": "TextX by Examples"
        },
        {
            "location": "/textx_by_examples/#textx-by-examples",
            "text": "The TextX project page gives a nice introduction \nto the concepts of TextX  (TextX) .\nRead the docs to explore different aspects, like\nthe grammar or scoping. The unittests are\nalso a great source of information, because they contain\nmany examples for different topics.  Note: validators are implemented as so-called object_processors.\nThese object_processors are meant to post process the\nparsed model (possibly modifying the model). They can also\nbe used to raise exceptions in order to indicate a logical\ndomain error (as in the  initial example ).",
            "title": "TextX by Examples"
        },
        {
            "location": "/references/",
            "text": "References\n\n\nMany websites, books and persons influenced this work.\nThe references are summarized in the following sections.\n\n\nToolsets / Language Workbenches\n\n\n\n\n (Xtext) \nXtext\n - a grammar based language workbench for java/Xtend/eclipse.\n\n\n (TextX) \nTextX\n - a grammar based language workbench for Python.\n\n\n\n\nProgramming languages\n\n\n\n\nXtend\n - a statically types language (translates to Java).\n\n\nPython\n - a dynamically types language.\n\n\n\n\nGeneral information\n\n\n\n\n (Tomassetti, 2017) F. Tomassetti: \n\"The complete guide to (external) Domain Specific Languages\"\n (06/2018)\n\n\n\n\nXtext related stuff\n\n\n\n\n (Bettini, 2016) L. Bettini: \"Implementing Domain-Specific Languages with Xtext and Xtend - Second Edition\u201c (Packt Publishing; 2nd Revised edition, 31. August 2016).\n\n\n (Mooij et al, 2017a) A. Mooij, J. Hooman: \n\"Creating a Domain Specific Language (DSL) with Xtext\"\n (2017/06)\n\n\n (Mooij et al, 2017b) A. Mooij, K. Triantafyllidis, J. Hooman: \n\"Advanced Xtext Manual on Modularity\"\n (2017/06)\n\n\n (Rentz-Reichert, 2017) H. Rentz-Reichert (Protos Software): \"Entwicklung dom\u00e4nenspezifischer Sprachen und Code-Generatoren mit Xtext und Xtend\" (german course, Regensburg, 2017/05;\n    architect of \neTrice (ROOM based modeling tool)\n (2017/06)\n\n\n\n\nTextX related stuff\n\n\n\n\n (Dejanovi\u0107 et al. 2017) Dejanovi\u0107 I., Vaderna R., Milosavljevi\u0107 G., Vukovi\u0107 \u017d. (2017). TextX: A Python tool for Domain-Specific Languages implementation. Knowledge-Based Systems, 115, 1-4.",
            "title": "References"
        },
        {
            "location": "/references/#references",
            "text": "Many websites, books and persons influenced this work.\nThe references are summarized in the following sections.",
            "title": "References"
        },
        {
            "location": "/references/#toolsets-language-workbenches",
            "text": "(Xtext)  Xtext  - a grammar based language workbench for java/Xtend/eclipse.   (TextX)  TextX  - a grammar based language workbench for Python.",
            "title": "Toolsets / Language Workbenches"
        },
        {
            "location": "/references/#programming-languages",
            "text": "Xtend  - a statically types language (translates to Java).  Python  - a dynamically types language.",
            "title": "Programming languages"
        },
        {
            "location": "/references/#general-information",
            "text": "(Tomassetti, 2017) F. Tomassetti:  \"The complete guide to (external) Domain Specific Languages\"  (06/2018)",
            "title": "General information"
        },
        {
            "location": "/references/#xtext-related-stuff",
            "text": "(Bettini, 2016) L. Bettini: \"Implementing Domain-Specific Languages with Xtext and Xtend - Second Edition\u201c (Packt Publishing; 2nd Revised edition, 31. August 2016).   (Mooij et al, 2017a) A. Mooij, J. Hooman:  \"Creating a Domain Specific Language (DSL) with Xtext\"  (2017/06)   (Mooij et al, 2017b) A. Mooij, K. Triantafyllidis, J. Hooman:  \"Advanced Xtext Manual on Modularity\"  (2017/06)   (Rentz-Reichert, 2017) H. Rentz-Reichert (Protos Software): \"Entwicklung dom\u00e4nenspezifischer Sprachen und Code-Generatoren mit Xtext und Xtend\" (german course, Regensburg, 2017/05;\n    architect of  eTrice (ROOM based modeling tool)  (2017/06)",
            "title": "Xtext related stuff"
        },
        {
            "location": "/references/#textx-related-stuff",
            "text": "(Dejanovi\u0107 et al. 2017) Dejanovi\u0107 I., Vaderna R., Milosavljevi\u0107 G., Vukovi\u0107 \u017d. (2017). TextX: A Python tool for Domain-Specific Languages implementation. Knowledge-Based Systems, 115, 1-4.",
            "title": "TextX related stuff"
        }
    ]
}