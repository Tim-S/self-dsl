{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to self-dsl\n\n\nThis is a tutorial site for the creation of domain specific languages.\n\n\n\n\n\n\nMotivation\n:\n    Why using a DSL? What is the value of it? What is MDSD?\n\n\n\n\n\n\nBasics of meta modeling\n\n    What is meta modeled?\n\n\n\n\n\n\nTutorial-like topics for Xtext and TextX (see sidebar).\n\n\n\n\n\n\nReferences\n\n\n\n\n\n\nEmployed software to generate this documentation\n\n\n\n\nWe use \nMkDocs\n to build these\npages (using the \nRead the Docs\n\ntheme).\n\n\nWe employ \nPlantUML\n to produce UML graphics\n(together with a \nplugin\n\nworking together with  \nMkDocs\n).",
            "title": "Welcome to self-dsl"
        },
        {
            "location": "/#welcome-to-self-dsl",
            "text": "This is a tutorial site for the creation of domain specific languages.    Motivation :\n    Why using a DSL? What is the value of it? What is MDSD?    Basics of meta modeling \n    What is meta modeled?    Tutorial-like topics for Xtext and TextX (see sidebar).    References",
            "title": "Welcome to self-dsl"
        },
        {
            "location": "/#employed-software-to-generate-this-documentation",
            "text": "We use  MkDocs  to build these\npages (using the  Read the Docs \ntheme).  We employ  PlantUML  to produce UML graphics\n(together with a  plugin \nworking together with   MkDocs ).",
            "title": "Employed software to generate this documentation"
        },
        {
            "location": "/motivation/",
            "text": "Motivation\n\n\nThe problem to be solved is two-fold: avoid problems with\n\ncommunication\n and \nconsistency\n.\nA \ncommon language\n will be defined to ease \ncommunication\n within and\nbetween teams. A \nsingle source\n of information implies \nconsistency\n,\nand in turn, prevents misunderstandings.\n\n\n\n\nA very good introduction to domain modeling is\n\n(Tomassetti, 2017)\n.\n\n\nMDSD and DSLs\n\n\nModel driven software development (MDSD)\n allows\nintroducing a supplementary layer of\nabstraction above the code: This additional complexity can be employed to\nreplace traditional model traditional model based design approaches, and\nthus represents a significant design element of a software architecture.\nSuch model driven approaches often also refer to\n\ndomain specific languages (DSL)\n.\nThese languages make the design easy to communicate (defined language at\ndesign level) and at the same time the design itself constitutes of actual\nsoftware artefacts, since code is directly generated from it (single\nsource of information).\n\n\nMeta-model, model, and all that\n\n\nThe meta modeling toolsets utilized on this site typically allow to define\n\n(1) a meta model definition\n, which defines what is modeled, e.g.,\nthe basic layout of a data structure in terms of structures which have\nattributes. This meta model can be compared to a \ndata base layout\n.\nIt also can be compared to \nglossary\n for a given domain.\nUsing the meta model \n(2) model data\n can be defined by a user.\nThis model data represents the concrete \ndata structures for a given domain\n.\n\n(3) Validation\n: importantly, the meta model definition allows to validate\nand check concrete models. Finally, \n(4) code generators and\nmodel transformations\n represent primary end user tools to allow mass\nproduction based on a \nsingle source\n of information (the model).\n\n\nReal value for a project\n\n\nNotably, if a model represents a real abstraction of a software\naspect - something people talk about and which hides important\ndetails - we get a big impact in productivity. From the one and\nsingle source of specification (the model data) we can extract\ndocumentation, plan and archive changes (in the models) and at\nthe same time guarantee the consistency of model and multiple code artefacts.\n\n\nThe \nreal value\n in terms of working hours is not the meta model, the code\ngenerator or the editor of a model, but the \nmodel data\n itself. The\nrest of the employed toolset and definitions (e.g. the meta model) further\nincrease this value, by allowing to validate, transform or\nevaluate the model data.\n\n\nKeeping this in mind, one should keep in  mind to be able to parse and\nunderstand the model data in, say, 10 years. Also think about wht happens if\nmultiple users create conflicts in model files. One should be able to repair\nsuch situations. This is easier if the model stored on disk resembles the\nmodel entered by the user, than if an alternative representation is used\nwith, e.g., binary data representations or machine generated IDs which are\ndifficult to understand. Such a simple representation on disk also allows to\neasily analyze a model with a traditional text search tool (grep) and to\nmake quick modifications to the model with a simple editor.\n\n\nMoreover, the interoperability of employed toolsets is of crucial importancy:\nthe ability to define inter-model relations eases large scale model\ndriven approaches and the IDE integration increases end user acceptance.",
            "title": "Motivation"
        },
        {
            "location": "/motivation/#motivation",
            "text": "The problem to be solved is two-fold: avoid problems with communication  and  consistency .\nA  common language  will be defined to ease  communication  within and\nbetween teams. A  single source  of information implies  consistency ,\nand in turn, prevents misunderstandings.   A very good introduction to domain modeling is (Tomassetti, 2017) .",
            "title": "Motivation"
        },
        {
            "location": "/motivation/#mdsd-and-dsls",
            "text": "Model driven software development (MDSD)  allows\nintroducing a supplementary layer of\nabstraction above the code: This additional complexity can be employed to\nreplace traditional model traditional model based design approaches, and\nthus represents a significant design element of a software architecture.\nSuch model driven approaches often also refer to domain specific languages (DSL) .\nThese languages make the design easy to communicate (defined language at\ndesign level) and at the same time the design itself constitutes of actual\nsoftware artefacts, since code is directly generated from it (single\nsource of information).",
            "title": "MDSD and DSLs"
        },
        {
            "location": "/motivation/#meta-model-model-and-all-that",
            "text": "The meta modeling toolsets utilized on this site typically allow to define (1) a meta model definition , which defines what is modeled, e.g.,\nthe basic layout of a data structure in terms of structures which have\nattributes. This meta model can be compared to a  data base layout .\nIt also can be compared to  glossary  for a given domain.\nUsing the meta model  (2) model data  can be defined by a user.\nThis model data represents the concrete  data structures for a given domain . (3) Validation : importantly, the meta model definition allows to validate\nand check concrete models. Finally,  (4) code generators and\nmodel transformations  represent primary end user tools to allow mass\nproduction based on a  single source  of information (the model).",
            "title": "Meta-model, model, and all that"
        },
        {
            "location": "/motivation/#real-value-for-a-project",
            "text": "Notably, if a model represents a real abstraction of a software\naspect - something people talk about and which hides important\ndetails - we get a big impact in productivity. From the one and\nsingle source of specification (the model data) we can extract\ndocumentation, plan and archive changes (in the models) and at\nthe same time guarantee the consistency of model and multiple code artefacts.  The  real value  in terms of working hours is not the meta model, the code\ngenerator or the editor of a model, but the  model data  itself. The\nrest of the employed toolset and definitions (e.g. the meta model) further\nincrease this value, by allowing to validate, transform or\nevaluate the model data.  Keeping this in mind, one should keep in  mind to be able to parse and\nunderstand the model data in, say, 10 years. Also think about wht happens if\nmultiple users create conflicts in model files. One should be able to repair\nsuch situations. This is easier if the model stored on disk resembles the\nmodel entered by the user, than if an alternative representation is used\nwith, e.g., binary data representations or machine generated IDs which are\ndifficult to understand. Such a simple representation on disk also allows to\neasily analyze a model with a traditional text search tool (grep) and to\nmake quick modifications to the model with a simple editor.  Moreover, the interoperability of employed toolsets is of crucial importancy:\nthe ability to define inter-model relations eases large scale model\ndriven approaches and the IDE integration increases end user acceptance.",
            "title": "Real value for a project"
        },
        {
            "location": "/basics/",
            "text": "Basics of meta modeling for domain models\n\n\nIn this section we describe typical meta modeling tasks.\nMeta modeling is the creation of a meta model.\nThis defines what can be modeled in a model for that given meta model.\n\n\nAll aspects identified here can be found in a tutorial style\nin corresponding sections for TextX and Xtext of this documentation.\n\n\nIntroductory example\n\n\nAn example: A meta model for a programming language defines that, e.g.,\nvariables can be defined. The model, in turn, is a concrete programm\nwith many variable definitions.\n\n\nA meta model may, thus, be sketched as follows:\n\n\n\n\nA program (domain model) may look as follows:\n\n\n\n\nOverview: aspects of meta modeling\n\n\nA summary of different aspects to be specified by the meta model is given\nas follows. This list is inspired by the grammar based toolset\n\nXtext\n\nand \nTextX\n.\n\n\n\n\nWhich \ndomain objects\n exist (\nglossary\n)?\n\n\nHow are objects identified (\nnamed\n)?\n\n\nWhich \nattributes\n do objects have?\n\n\nWhat objects are \ncomposed\n of other objects?\n\n\nWhat objects \naggregates\n other objects?\n\n\nHow do objects \nreference\n each other (including context effects/\nscoping\n)?\n\n\nHow can I \nspecialize\n objects?\n\n\nHow can I \nconnect\n objects?\n\n\nModularization\n: How can an object reference another object from another model\n    (form the same meta model or a different one)?\n\n\nInteroperability\n: How can an object reference something from outside\n    the toolset scope (inter-tool operability)?\n\n\nValidation\n: How can custom rules be checked automatically?\n\n\n\n\nDomain objects: identification and attributes\n\n\nDomain objects represent a central part of a \nglossary\n. Thus,\ndefining such objects is a central part of any software specification\nand must be using through its design.\n\n\nDomain objects\n can represent things, like \"Customers\", \"Computers\",\n\"State machines\". In our context they can also represent activities\nand relationships,  like \"owns\" (a customers owns a computer) or\n\"runs\" (a computer runs a state machine).\nDomain objects may have \nattributes\n, some of them optional. These attributes\nmay have a \nscalar\n value or represent a \nlist\n of entries. The value of the\nattributes can be specified to represent some \nbasic type\n (like a string or a\nnumber) or \nother domain\n objects.\n\n\nImportantly, some domain objects need to be identified by a name (like a\n\"Customer\"), while other objects do not (like the \"Birthday\" in our\nexample below).\n\n\n\n\nNote: Domain objects in the meta model represent a blueprint or a class of a\nconcrete instances of such objects in a concrete model.\n\n\nComposing objects\n\n\nDomain objects may be composed of other domain objects. Such a relationship\ncan be described by an attribute with a domain object type (like in the last\nsection). An alternative representation is illustrated as follows, but\ndescribes exactly the same thing:\n\n\n\n\nNote: in this example, a Customer is composed of a Birthday object.\nThe Birthday object cannot exist without the Customer. This relationship\nis called \ncomposition\n and has clear \nownership\n semantics.\n\n\nReferences and Aggregation\n\n\nSome domain objects need to reference identifiable objects without\nhaving their ownership. This happens, e.g.,\nwhen describing domain object relationships within the model (e.g. a\nCustomer owns a Computer; relationship \"own\"). Such relationships themselves\ncan own additional attributes (e.g. \"owns since date\").\n\n\n\n\nNote: non-owning knowlegde of other objects is called \naggregation\n. Simple\nrelationships can be presented by a simple link (without attributes and without\nown rule/class definition).\n\n\nScoping\n\n\nScoping is relevant to \ndescribe what objects are identifiable\n when \nreferencing\nother objects\n. This is especially of importance, when some default visibility\nis not valid (most default scoping mechanisms allow all identifiable objects to be\nreferenced globally).\n\n\nAssume the following meta model snippet, where a \"Scenario\" is composed of\n\"Configurations\" and a \"Testcase\" references \"Scenarios\" and \"Configurations\":\n\n\n\n\nIn this case, we want that \nonly \"Configurations\" of the \"Scenario\"\nreferenced by a \"Testcase\" are visible to the \"Testcase\"\n. This\nrestriction is context specific (to the context of the \"Testcase\" described\nby the referenced \"Scenario\"). Scoping mechanisms allow to define this scope.\n\n\nSpecialization (base classes/base rules)\n\n\nSometimes it happens that some domain object is too generic and needs to\nbe specialized. This may happen when the language evolves.\nDuring the initial design commonalities are identified which lead to\nthe same pattern (base class and specialization).\n\n\n\n\nModularization\n\n\nThis happens when a model is splitted  in multiple submodels\n(e.g., different files).\n\n\n\n\nCombining meta models\n\n\nTo foster modularization, meta models can be splitted and still allow to\nreference domain objects of one meta model from the other meta model. In our last example\nwe could define a meta model for \"Testcases\" and one meta model for\n\"Scenarios\". This feature is more demanding to the underlying technology but\nallows a \nmodularization of the meta model and, thus, the glossary\n.\n\n\nInteroperability with other toolsets or software components\n\n\nIn larger projects external databases or models may need to be referenced.\nSuch external sources of information may be, e.g., am existing database of\nrequirements, some JSON or XML file or similar things. Interoperability with\nthese sources of information allow to link the model to that source.\n\n\n\n\nValidation\n\n\nThe validation of a model consists of \nadditional checks on top of structural\nconsistency\n defined by the grammar and scoping.\n\n\n\n\nError in the structure\n    result in classical syntax errors (\"\nexpected\n 'XY' instead of 'AB'\").\n\n\nScoping, in turn, defines the possible references in some context and,\n    thus, yields errors of the catergory \"referenced element 'XY' \nnot found\n.\".\n\n\nThe \nvalidation\n described in this section is about additional\n    \nlogical checks\n, once the model is correctly parsed and all\n    references resolved. This additional checks typically have a\n    \nstrong relation to the domain\n.\n\n\n\n\nExample:\n Assume a model where \"testcases\" reference \"configurations of\nscenarios\" which have certain \"aspects\". On the other hand a \"testcase\" may\nneed certain aspects. If any of the \"Aspects\" required by a \"testcase\" is not\navailabe in the referenced \"configuration\", a logical error is reported\n(validation error).\n\n\nRationale\n for choosing a validation over a scoping solution in this case:\nWhen modeling a situation where a \"configuration\" is chosen by a \"testcase\"\nwithout providing the correct \"aspects\", one would not like to get a\n\"configuration ot found\", which would result if only \"configurations\" with matching\n\"aspects\" are defined in the \nscope\n of a \"testcase\". In contrast, the\n\nvalidation\n will allow all \"configurations\" of the selected \"scenario\" of\na \"testcase\" to be visible, but some of them will produce a\n\nmeaningful domain error\n, such as\n\"configuration 'config_B' does not provide the aspect 'aspect_X' required\nby testcase 'test_T1'\".\n\n\nThe structure defined in the meta model is shown as follows:\n\n\n\n\nA model with validation error (\n\"configuration 'config_B' does not provide the aspect 'aspect_X' required\nby testcase 'test_T1'\"\n) is shown as follows:\n\n\nscenario scenario_001 {\n    configuration config_A has {aspect_X}\n    configuration config_B has {aspect_Y}\n}\ntestcase test_T1 {\n    use scenario_001 with config_B\n    and needs {aspect_X}\n}\n\n\n\n\n\n\n\nA model without validation error is shown as follows:\n\n\nscenario scenario_001 {\n    configuration config_A has {aspect_X}\n    configuration config_B has {aspect_Y, aspect_X}\n}\ntestcase test_T1 {\n    use scenario_001 with config_B\n    and needs {aspect_X}\n}",
            "title": "Basics of meta modeling for domain models"
        },
        {
            "location": "/basics/#basics-of-meta-modeling-for-domain-models",
            "text": "In this section we describe typical meta modeling tasks.\nMeta modeling is the creation of a meta model.\nThis defines what can be modeled in a model for that given meta model.  All aspects identified here can be found in a tutorial style\nin corresponding sections for TextX and Xtext of this documentation.",
            "title": "Basics of meta modeling for domain models"
        },
        {
            "location": "/basics/#introductory-example",
            "text": "An example: A meta model for a programming language defines that, e.g.,\nvariables can be defined. The model, in turn, is a concrete programm\nwith many variable definitions.  A meta model may, thus, be sketched as follows:   A program (domain model) may look as follows:",
            "title": "Introductory example"
        },
        {
            "location": "/basics/#overview-aspects-of-meta-modeling",
            "text": "A summary of different aspects to be specified by the meta model is given\nas follows. This list is inspired by the grammar based toolset Xtext \nand  TextX .   Which  domain objects  exist ( glossary )?  How are objects identified ( named )?  Which  attributes  do objects have?  What objects are  composed  of other objects?  What objects  aggregates  other objects?  How do objects  reference  each other (including context effects/ scoping )?  How can I  specialize  objects?  How can I  connect  objects?  Modularization : How can an object reference another object from another model\n    (form the same meta model or a different one)?  Interoperability : How can an object reference something from outside\n    the toolset scope (inter-tool operability)?  Validation : How can custom rules be checked automatically?",
            "title": "Overview: aspects of meta modeling"
        },
        {
            "location": "/basics/#domain-objects-identification-and-attributes",
            "text": "Domain objects represent a central part of a  glossary . Thus,\ndefining such objects is a central part of any software specification\nand must be using through its design.  Domain objects  can represent things, like \"Customers\", \"Computers\",\n\"State machines\". In our context they can also represent activities\nand relationships,  like \"owns\" (a customers owns a computer) or\n\"runs\" (a computer runs a state machine).\nDomain objects may have  attributes , some of them optional. These attributes\nmay have a  scalar  value or represent a  list  of entries. The value of the\nattributes can be specified to represent some  basic type  (like a string or a\nnumber) or  other domain  objects.  Importantly, some domain objects need to be identified by a name (like a\n\"Customer\"), while other objects do not (like the \"Birthday\" in our\nexample below).   Note: Domain objects in the meta model represent a blueprint or a class of a\nconcrete instances of such objects in a concrete model.",
            "title": "Domain objects: identification and attributes"
        },
        {
            "location": "/basics/#composing-objects",
            "text": "Domain objects may be composed of other domain objects. Such a relationship\ncan be described by an attribute with a domain object type (like in the last\nsection). An alternative representation is illustrated as follows, but\ndescribes exactly the same thing:   Note: in this example, a Customer is composed of a Birthday object.\nThe Birthday object cannot exist without the Customer. This relationship\nis called  composition  and has clear  ownership  semantics.",
            "title": "Composing objects"
        },
        {
            "location": "/basics/#references-and-aggregation",
            "text": "Some domain objects need to reference identifiable objects without\nhaving their ownership. This happens, e.g.,\nwhen describing domain object relationships within the model (e.g. a\nCustomer owns a Computer; relationship \"own\"). Such relationships themselves\ncan own additional attributes (e.g. \"owns since date\").   Note: non-owning knowlegde of other objects is called  aggregation . Simple\nrelationships can be presented by a simple link (without attributes and without\nown rule/class definition).",
            "title": "References and Aggregation"
        },
        {
            "location": "/basics/#scoping",
            "text": "Scoping is relevant to  describe what objects are identifiable  when  referencing\nother objects . This is especially of importance, when some default visibility\nis not valid (most default scoping mechanisms allow all identifiable objects to be\nreferenced globally).  Assume the following meta model snippet, where a \"Scenario\" is composed of\n\"Configurations\" and a \"Testcase\" references \"Scenarios\" and \"Configurations\":   In this case, we want that  only \"Configurations\" of the \"Scenario\"\nreferenced by a \"Testcase\" are visible to the \"Testcase\" . This\nrestriction is context specific (to the context of the \"Testcase\" described\nby the referenced \"Scenario\"). Scoping mechanisms allow to define this scope.",
            "title": "Scoping"
        },
        {
            "location": "/basics/#specialization-base-classesbase-rules",
            "text": "Sometimes it happens that some domain object is too generic and needs to\nbe specialized. This may happen when the language evolves.\nDuring the initial design commonalities are identified which lead to\nthe same pattern (base class and specialization).",
            "title": "Specialization (base classes/base rules)"
        },
        {
            "location": "/basics/#modularization",
            "text": "This happens when a model is splitted  in multiple submodels\n(e.g., different files).",
            "title": "Modularization"
        },
        {
            "location": "/basics/#combining-meta-models",
            "text": "To foster modularization, meta models can be splitted and still allow to\nreference domain objects of one meta model from the other meta model. In our last example\nwe could define a meta model for \"Testcases\" and one meta model for\n\"Scenarios\". This feature is more demanding to the underlying technology but\nallows a  modularization of the meta model and, thus, the glossary .",
            "title": "Combining meta models"
        },
        {
            "location": "/basics/#interoperability-with-other-toolsets-or-software-components",
            "text": "In larger projects external databases or models may need to be referenced.\nSuch external sources of information may be, e.g., am existing database of\nrequirements, some JSON or XML file or similar things. Interoperability with\nthese sources of information allow to link the model to that source.",
            "title": "Interoperability with other toolsets or software components"
        },
        {
            "location": "/basics/#validation",
            "text": "The validation of a model consists of  additional checks on top of structural\nconsistency  defined by the grammar and scoping.   Error in the structure\n    result in classical syntax errors (\" expected  'XY' instead of 'AB'\").  Scoping, in turn, defines the possible references in some context and,\n    thus, yields errors of the catergory \"referenced element 'XY'  not found .\".  The  validation  described in this section is about additional\n     logical checks , once the model is correctly parsed and all\n    references resolved. This additional checks typically have a\n     strong relation to the domain .   Example:  Assume a model where \"testcases\" reference \"configurations of\nscenarios\" which have certain \"aspects\". On the other hand a \"testcase\" may\nneed certain aspects. If any of the \"Aspects\" required by a \"testcase\" is not\navailabe in the referenced \"configuration\", a logical error is reported\n(validation error).  Rationale  for choosing a validation over a scoping solution in this case:\nWhen modeling a situation where a \"configuration\" is chosen by a \"testcase\"\nwithout providing the correct \"aspects\", one would not like to get a\n\"configuration ot found\", which would result if only \"configurations\" with matching\n\"aspects\" are defined in the  scope  of a \"testcase\". In contrast, the validation  will allow all \"configurations\" of the selected \"scenario\" of\na \"testcase\" to be visible, but some of them will produce a meaningful domain error , such as\n\"configuration 'config_B' does not provide the aspect 'aspect_X' required\nby testcase 'test_T1'\".  The structure defined in the meta model is shown as follows:   A model with validation error ( \"configuration 'config_B' does not provide the aspect 'aspect_X' required\nby testcase 'test_T1'\" ) is shown as follows:  scenario scenario_001 {\n    configuration config_A has {aspect_X}\n    configuration config_B has {aspect_Y}\n}\ntestcase test_T1 {\n    use scenario_001 with config_B\n    and needs {aspect_X}\n}   A model without validation error is shown as follows:  scenario scenario_001 {\n    configuration config_A has {aspect_X}\n    configuration config_B has {aspect_Y, aspect_X}\n}\ntestcase test_T1 {\n    use scenario_001 with config_B\n    and needs {aspect_X}\n}",
            "title": "Validation"
        },
        {
            "location": "/xtext_eclipse/",
            "text": "Xtext and Eclipse\n\n\nXtext is integrated in Eclispe.\nTo run this tutorial you need to install Eclipse with the appropriate\nplugins (current version: Oxygen).\n\n\nNote: The parser \"Antlr\" is not distributed with eclipse. You need to install\nit manually \n(itemis update site)\n,\nelse it will be downloaded for every Xtext project you create.\n\n\nDownload and install\n\n\nDownload the package\n\n\"Eclipse Modeling\"\n.\nUnpack the archive to make eclipse available.\n\n\nroot@xtext:~/Download# ls\neclipse-modeling-oxygen-3a-linux-gtk-x86_64.tar.gz\nroot@xtext:~/Download# tar xzf eclipse-modeling-oxygen-3a-linux-gtk-x86_64.tar.gz\nroot@xtext:~/Download# mv eclipse /opt/\nroot@xtext:~/Download# /opt/eclipse/eclipse &\n\n\n\n\n\nTo complete the installation you need \"Install Modeling Components\" from the\n\"Help\" menu entry. Select the \"Xtext\" entry and \"Finish\" the installation by\nrestarting eclipse.",
            "title": "Eclipse"
        },
        {
            "location": "/xtext_eclipse/#xtext-and-eclipse",
            "text": "Xtext is integrated in Eclispe.\nTo run this tutorial you need to install Eclipse with the appropriate\nplugins (current version: Oxygen).  Note: The parser \"Antlr\" is not distributed with eclipse. You need to install\nit manually  (itemis update site) ,\nelse it will be downloaded for every Xtext project you create.",
            "title": "Xtext and Eclipse"
        },
        {
            "location": "/xtext_eclipse/#download-and-install",
            "text": "Download the package \"Eclipse Modeling\" .\nUnpack the archive to make eclipse available.  root@xtext:~/Download# ls\neclipse-modeling-oxygen-3a-linux-gtk-x86_64.tar.gz\nroot@xtext:~/Download# tar xzf eclipse-modeling-oxygen-3a-linux-gtk-x86_64.tar.gz\nroot@xtext:~/Download# mv eclipse /opt/\nroot@xtext:~/Download# /opt/eclipse/eclipse &  To complete the installation you need \"Install Modeling Components\" from the\n\"Help\" menu entry. Select the \"Xtext\" entry and \"Finish\" the installation by\nrestarting eclipse.",
            "title": "Download and install"
        },
        {
            "location": "/xtext_project_setup/",
            "text": "Xtext Project Setup\n\n\nCreate a new Xtext Project\n\n\nIn Eclipse\n\n\n\n\nSelect in the menu \"File\" - \"New\" - \"Project\".\n\n\nSelect \"Xtext Project\" and click \"Next\"\n\n\nSpecify the project name:\n\n\n\"\nProject name\n\": \"course.xtext.dataflow\"\n\n\n\"\nName\n\": \"course.xtext.dataflow.DataFlowDsl\"\n\n\n\"\nExtension\n\": \"dataflow\"\nthen click \"\nNext\n\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn the next step can configure your project.\n    Select \"Maven\" as \"Prefered Build System\".\n\n\n\n\nDo not ignore warnings concerning \"Maven integration for eclipse (m2e)\".\nIf neccessary install \"m2e\" via \"Help\" - \"Install New Software\"\n- \"All Availabe Sites\" and restart Eclipse.\n\n\n\n\n\n\nFinally, some projects are created in your workspace, from which we will\nonly use a few of them at the moment (details: see \n(Mooji et al., 2017a)\n).\nAn example grammar definition is created and opened in the editor.\n\n\n\n\nCompile and Run the Project\n\n\nIn Eclipse (e.g., after a new project is created)\n\n\n\n\nIn the grammar editor right click \"Run As\" / \"Generate Xtext Artifacts\"\n\n\nIn the menu: \"\nRun\n\" - \"\nDebug Configurations\n\"...\n\n\nselect \"\nEclipse Application\n\"\n\n\nclick Icon \"\nNew Launch Configuration\n\"\n\n\noptional: specify configuration \nname\n and \nlocation\n of workspace.\n    (the Xtext create language plugin will run in a new Eclipse instance)\n\n\nclick \"\nDebug\n\"\n\n\n\n\n\n\n\n\nIn the new Eclipse instance the new language can be used:\n\n\n\n\nIn the \"\nPackage Explorer\n\" click \"\nNew Project\n\".\n\n\nSelect \"\nJava Project\n\u201c to create a new Java Project\n    (You can also choose, e.g., a C++ or an Empty Project).\n\n\nCreate a folder \"model\" in this project.\n\n\nIn this folder create a model file: \"\nNew\n\" - \"\nFile\n\"\n    with \"\nFile Name\n\"=\"test1\n.dataflow\n\" (+\"\nFinish\n\").\n    \nNote\n: the file ending is important and must match the file ending\n    specified for your language.\n\n\nClick \"\nYes\n\" when you are prompted\n    \"Do you want to convert ... to an Xtext Project\".\n\n\n\n\nNow you can play with your new language (type CTRL-Space to get auto\ncompletion). Enter the following exmaple:\n\n\n\n\nHello Pierre!\nHello Tim!\nHello Markus!\n\n\n\n\n\nThe grammar for this example (automatically created after project\ninitialization) may look as follows. A \"Model\" contains \"Greetings\".\nEvery \"Greeting\" consists of the Text 'Hello' and a name followed by '!'\n(details later).\n\n\ngrammar\n \norg\n.\nxtext\n.\nexample\n.\nmydsl\n.\nMyDsl\n \nwith\n \norg\n.\neclipse\n.\nxtext\n.\ncommon\n.\nTerminals\n\n\ngenerate\n \nmyDsl\n \n\"http://www.xtext.org/example/mydsl/MyDsl\"\n\n\nModel:\n\n    \ngreetings\n+=\nGreeting\n*;\n\nGreeting:\n\n    \n'Hello'\n \nname\n=\nID\n \n'!'\n;",
            "title": "Xtext Project Setup"
        },
        {
            "location": "/xtext_project_setup/#xtext-project-setup",
            "text": "",
            "title": "Xtext Project Setup"
        },
        {
            "location": "/xtext_project_setup/#create-a-new-xtext-project",
            "text": "In Eclipse   Select in the menu \"File\" - \"New\" - \"Project\".  Select \"Xtext Project\" and click \"Next\"  Specify the project name:  \" Project name \": \"course.xtext.dataflow\"  \" Name \": \"course.xtext.dataflow.DataFlowDsl\"  \" Extension \": \"dataflow\"\nthen click \" Next \"        In the next step can configure your project.\n    Select \"Maven\" as \"Prefered Build System\".   Do not ignore warnings concerning \"Maven integration for eclipse (m2e)\".\nIf neccessary install \"m2e\" via \"Help\" - \"Install New Software\"\n- \"All Availabe Sites\" and restart Eclipse.    Finally, some projects are created in your workspace, from which we will\nonly use a few of them at the moment (details: see  (Mooji et al., 2017a) ).\nAn example grammar definition is created and opened in the editor.",
            "title": "Create a new Xtext Project"
        },
        {
            "location": "/xtext_project_setup/#compile-and-run-the-project",
            "text": "In Eclipse (e.g., after a new project is created)   In the grammar editor right click \"Run As\" / \"Generate Xtext Artifacts\"  In the menu: \" Run \" - \" Debug Configurations \"...  select \" Eclipse Application \"  click Icon \" New Launch Configuration \"  optional: specify configuration  name  and  location  of workspace.\n    (the Xtext create language plugin will run in a new Eclipse instance)  click \" Debug \"     In the new Eclipse instance the new language can be used:   In the \" Package Explorer \" click \" New Project \".  Select \" Java Project \u201c to create a new Java Project\n    (You can also choose, e.g., a C++ or an Empty Project).  Create a folder \"model\" in this project.  In this folder create a model file: \" New \" - \" File \"\n    with \" File Name \"=\"test1 .dataflow \" (+\" Finish \").\n     Note : the file ending is important and must match the file ending\n    specified for your language.  Click \" Yes \" when you are prompted\n    \"Do you want to convert ... to an Xtext Project\".   Now you can play with your new language (type CTRL-Space to get auto\ncompletion). Enter the following exmaple:   Hello Pierre!\nHello Tim!\nHello Markus!  The grammar for this example (automatically created after project\ninitialization) may look as follows. A \"Model\" contains \"Greetings\".\nEvery \"Greeting\" consists of the Text 'Hello' and a name followed by '!'\n(details later).  grammar   org . xtext . example . mydsl . MyDsl   with   org . eclipse . xtext . common . Terminals  generate   myDsl   \"http://www.xtext.org/example/mydsl/MyDsl\"  Model: \n     greetings += Greeting *; Greeting: \n     'Hello'   name = ID   '!' ;",
            "title": "Compile and Run the Project"
        },
        {
            "location": "/xtext_a_first_grammar/",
            "text": "A First Grammar\n\n\nThe goal of this exercise is to define a grammar for a structure as sketched in\nthe image below: A \nModel\n shall contain \nPackages\n. Every \nPackage\n\ncan contain \nComponent\n definitions and \nService\n definitions.\nA Service can \ninstantiate\n the Components.\nMoreover shall a Component definition contain \ninput ports\n\nand \noutput ports\n.\n\n\nAll \nbold\n elements in the text above will be defined in our the grammar of\nour meta model.\n\n\n\n\nFirst steps after project initialization\n\n\nA grammar describes the syntax (more or less without semantic) of our\ndomain language describing domain models.\nInternally, Xtext deduces an ecore model from the grammar, which can be used\nto display the structure of the grammar (like the image in the first part of this\npage).\nThe grammar remains the master (for maintenance) and the ecore model is recreated\nafter every change.\n\n\nNote: Is is also possible to create a grammar based on an ecore model\n(via Eclipse Wizard).\n\n\nAdditional information can be found in the \nreferences list\n or\nin the offline help of Eclipse: \"Help\" - \"Help Contents\".\n\n\nRoot node of a model\n\n\nTake a look at the grammar initially created for our project:\n\n\nModel\n:\n\n\n    \ngreetings\n+=\nGreeting\n*\n;\n\n\nGreeting\n:\n\n\n    \n'Hello'\n \nname\n=\nID\n \n'!'\n;\n\n\n\n\n\n\n\n\nA grammar conists of \nrules\n, starting with the name of the rule,\n    followed by a colon \":\" and the rule itself,\n    and is terminated by a semicolon \";\".\n\n\nThe first rule in the grammar (e.g. \"Model\") is the root of the model.\n\n\nInstead of adding elements to the model of type \"\nGreeting\n\", we will\n    add elements of type \"\nKPackage\n\" (change the name \"Greeting\" to \"KPackage\").\n\n\nSee also \n(Mooji et al., 2017a)\n\n\n\n\nAttributes, Composition\n\n\nA \"KPackage\" element, in turn, shall be composed of \"KComponent\" and \"KService\"\nelements:\n\n\n\n\nThe syntax for the composition is given as follows:\n\n\nKPackage\n:\n \n'package'\n \nname\n=\nID\n \n'{'\n\n\n        \n(\n\n\n            \ncomponents\n \n+=\n \nKComponent\n \n|\n\n\n            \nservices\n \n+=\n \nKService\n\n\n        \n)*\n\n\n    \n'}'\n\n\n;\n\n\n\n\n\n\n\n\n'package', '{', '}'\n\n\nrepresent \nkeywords\n of our language.\n\n\n\n\n\n\nname=ID\n\n\n\"name\" is an \nattribute\n in the meta mode (the attribute \"name\" has\n   a special meaning: it is used to \nindentify\n elements).\n\n\n\"=\" means: this is a scalar value (no list of values).\n\n\nID\n is a \nterminal\n (see grammar, and click \"F3\" on\n  \"org.eclipse.xtext.common.Terminals\" to see definition).\n\n\n\n\n\n\ncomponents += KComponent\n\n\n\"components\" is an attribute in the meta model.\n\n\n\"+=\" means, this is a \nlist of values\n (add one element to this list here)\n\n\n\"KComponent\" and \"KService\" are \nrule definitions\n like \"KPackage\"\n  (need to be added)\n\n\n\n\n\n\n( ... | ... )*\n\n\nEverything with the brackets can be repeated  0 to n times (\"+\" instead\n  of \"*\" means 1 to n times).\n\n\n\"|\" is a logical OR.\n\n\n\n\n\n\n\n\nModify the grammar to allow to enter the following model. Test the\ngrammar with this example (run the grammar as described\n\nin the previous section\n): \"Run As\" -\n\"Xtext Artifacts\". The new Eclipse instance can easily be\nstarted via the Debug icon).\n\n\npackage\n \ntest1\n \n{\n\n    \nComponent\n \nPC\n \n{\n\n    \n}\n\n    \nComponent\n \nDF\n \n{\n\n    \n}\n\n    \nservice\n \nMyService\n \n{\n\n    \n}\n\n\n}\n\n\n\n\n\n\nReferences\n\n\n\n\nKInstance\n:\n \n'instance'\n \nname\n=\nID\n \n':'\n \ntype\n=\n[\nKComponent\n];\n\n\n\n\n\n\n\n\ntype=[KComponent]\n\n\n\"type\" is an attribute in the meta model.\n\n\n\"[KComponent]\" is a \nreference\n to a \"KComponent\" element.\n\n\nFor more inforamtion see the \nreferences list\n.\n\n\n\n\n\n\n\n\nSpecialization\n\n\n\n\nKPort\n:\n\n\n    \nKPortIn\n|\nKPortOut\n\n\n;\n\n\nKPortIn\n:\n\n\n    \n'port_in'\n \nname\n=\nID\n \n'{'\n\n\n    \n'}'\n\n\n;\n\n\nKPortOut\n:\n\n\n    \n'port_out'\n \nname\n=\nID\n \n'{'\n\n\n    \n'}'\n\n\n;\n\n\n\n\n\n\n\n\nBase: SpecialA|SpecialB;\n\n\nDefines a base class (base rule) for the specializations separated\n   by \"|\".\n\n\nCommon attributes are availabe in the base class (here: \"name\")\n\n\nFor more inforamtion see the \nreferences list\n.\n\n\n\n\n\n\n\n\nEditor\n\n\nAfter adding \nports\n (\"KPort\") to the \ncomponents\n (\"KComponent\")\nand \ninstances\n (\"KInstance\") to the \nservices\n (\"KService\"), you can test\nyour langauge with the following snippet:\n\n\npackage\n \ntest1\n \n{\n\n    \nComponent\n \nPC\n \n{\n\n        \nport_in\n \nin\n \n{}\n\n        \nport_out\n \nout\n \n{}\n\n    \n}\n\n    \nComponent\n \nDF\n \n{\n\n        \nport_in\n \nin\n \n{}\n\n        \nport_out\n \nout\n \n{}\n\n        \nport_out\n \ndebug\n \n{}\n\n    \n}\n\n    \nservice\n \nMyService\n \n{\n\n        \ninstance\n \npc\n \n:\n \nPC\n\n        \ninstance\n \ndf\n \n:\n \nDF\n\n    \n}\n\n\n}\n\n\n\n\n\n\nYou can also edit the model with a \ntree editor\n:\nopen wthe file with \"Open With...\" - \"Sample Ecore Model Editor\".\n\n\n\n\nWhen editing the model graph, the model text is changed accordingly: \nsee \nAuto Formatting\n.\n\n\nMore grammar stuff...\n\n\nThere is much more not covered here. You can start with\n\n(Mooji et al., 2017a)\n.\n\n\nOf special interest could be\n  * Optional parts of the grammar with \"?\".\n  * Enums (initially set to the first enum state).\n\n\nVisualize the meta model\n\n\nThe ecore model deduced from the grammar can be visualized:\nsee \n(Mooji et al., 2017a)\n,\nsection \"Optional: Ecore diagram\" (\u201eInitialize Ecore Diagram ...\u201c).\nMoreover a syntax tree can be rendered from the grammar:\nsee \n(Mooji et al., 2017a)\n,\nsection \"Optional: View Diagram of Xtext Grammar\"\n(Window/Show View/Other.../Xtext/Xtext Syntax Graph).",
            "title": "A First Grammar"
        },
        {
            "location": "/xtext_a_first_grammar/#a-first-grammar",
            "text": "The goal of this exercise is to define a grammar for a structure as sketched in\nthe image below: A  Model  shall contain  Packages . Every  Package \ncan contain  Component  definitions and  Service  definitions.\nA Service can  instantiate  the Components.\nMoreover shall a Component definition contain  input ports \nand  output ports .  All  bold  elements in the text above will be defined in our the grammar of\nour meta model.",
            "title": "A First Grammar"
        },
        {
            "location": "/xtext_a_first_grammar/#first-steps-after-project-initialization",
            "text": "A grammar describes the syntax (more or less without semantic) of our\ndomain language describing domain models.\nInternally, Xtext deduces an ecore model from the grammar, which can be used\nto display the structure of the grammar (like the image in the first part of this\npage).\nThe grammar remains the master (for maintenance) and the ecore model is recreated\nafter every change.  Note: Is is also possible to create a grammar based on an ecore model\n(via Eclipse Wizard).  Additional information can be found in the  references list  or\nin the offline help of Eclipse: \"Help\" - \"Help Contents\".",
            "title": "First steps after project initialization"
        },
        {
            "location": "/xtext_a_first_grammar/#root-node-of-a-model",
            "text": "Take a look at the grammar initially created for our project:  Model :       greetings += Greeting * ;  Greeting :       'Hello'   name = ID   '!' ;    A grammar conists of  rules , starting with the name of the rule,\n    followed by a colon \":\" and the rule itself,\n    and is terminated by a semicolon \";\".  The first rule in the grammar (e.g. \"Model\") is the root of the model.  Instead of adding elements to the model of type \" Greeting \", we will\n    add elements of type \" KPackage \" (change the name \"Greeting\" to \"KPackage\").  See also  (Mooji et al., 2017a)",
            "title": "Root node of a model"
        },
        {
            "location": "/xtext_a_first_grammar/#attributes-composition",
            "text": "A \"KPackage\" element, in turn, shall be composed of \"KComponent\" and \"KService\"\nelements:   The syntax for the composition is given as follows:  KPackage :   'package'   name = ID   '{'           (               components   +=   KComponent   |               services   +=   KService           )*       '}'  ;    'package', '{', '}'  represent  keywords  of our language.    name=ID  \"name\" is an  attribute  in the meta mode (the attribute \"name\" has\n   a special meaning: it is used to  indentify  elements).  \"=\" means: this is a scalar value (no list of values).  ID  is a  terminal  (see grammar, and click \"F3\" on\n  \"org.eclipse.xtext.common.Terminals\" to see definition).    components += KComponent  \"components\" is an attribute in the meta model.  \"+=\" means, this is a  list of values  (add one element to this list here)  \"KComponent\" and \"KService\" are  rule definitions  like \"KPackage\"\n  (need to be added)    ( ... | ... )*  Everything with the brackets can be repeated  0 to n times (\"+\" instead\n  of \"*\" means 1 to n times).  \"|\" is a logical OR.     Modify the grammar to allow to enter the following model. Test the\ngrammar with this example (run the grammar as described in the previous section ): \"Run As\" -\n\"Xtext Artifacts\". The new Eclipse instance can easily be\nstarted via the Debug icon).  package   test1   { \n     Component   PC   { \n     } \n     Component   DF   { \n     } \n     service   MyService   { \n     }  }",
            "title": "Attributes, Composition"
        },
        {
            "location": "/xtext_a_first_grammar/#references",
            "text": "KInstance :   'instance'   name = ID   ':'   type = [ KComponent ];    type=[KComponent]  \"type\" is an attribute in the meta model.  \"[KComponent]\" is a  reference  to a \"KComponent\" element.  For more inforamtion see the  references list .",
            "title": "References"
        },
        {
            "location": "/xtext_a_first_grammar/#specialization",
            "text": "KPort :       KPortIn | KPortOut  ;  KPortIn :       'port_in'   name = ID   '{'       '}'  ;  KPortOut :       'port_out'   name = ID   '{'       '}'  ;    Base: SpecialA|SpecialB;  Defines a base class (base rule) for the specializations separated\n   by \"|\".  Common attributes are availabe in the base class (here: \"name\")  For more inforamtion see the  references list .",
            "title": "Specialization"
        },
        {
            "location": "/xtext_a_first_grammar/#editor",
            "text": "After adding  ports  (\"KPort\") to the  components  (\"KComponent\")\nand  instances  (\"KInstance\") to the  services  (\"KService\"), you can test\nyour langauge with the following snippet:  package   test1   { \n     Component   PC   { \n         port_in   in   {} \n         port_out   out   {} \n     } \n     Component   DF   { \n         port_in   in   {} \n         port_out   out   {} \n         port_out   debug   {} \n     } \n     service   MyService   { \n         instance   pc   :   PC \n         instance   df   :   DF \n     }  }   You can also edit the model with a  tree editor :\nopen wthe file with \"Open With...\" - \"Sample Ecore Model Editor\".   When editing the model graph, the model text is changed accordingly: \nsee  Auto Formatting .",
            "title": "Editor"
        },
        {
            "location": "/xtext_a_first_grammar/#more-grammar-stuff",
            "text": "There is much more not covered here. You can start with (Mooji et al., 2017a) .  Of special interest could be\n  * Optional parts of the grammar with \"?\".\n  * Enums (initially set to the first enum state).",
            "title": "More grammar stuff..."
        },
        {
            "location": "/xtext_a_first_grammar/#visualize-the-meta-model",
            "text": "The ecore model deduced from the grammar can be visualized:\nsee  (Mooji et al., 2017a) ,\nsection \"Optional: Ecore diagram\" (\u201eInitialize Ecore Diagram ...\u201c).\nMoreover a syntax tree can be rendered from the grammar:\nsee  (Mooji et al., 2017a) ,\nsection \"Optional: View Diagram of Xtext Grammar\"\n(Window/Show View/Other.../Xtext/Xtext Syntax Graph).",
            "title": "Visualize the meta model"
        },
        {
            "location": "/xtext_auto_formatting/",
            "text": "Auto Formatting\n\n\nWhen you change the model (e.g. using the \n\ntree editor\n)\nand you save your changes, you will notice that the\nmodel text is updated, but does not contain any line breaks.\nAlso, when invooking the auto-formatter of Eclipse \n(CTRL-SHIFT-F in the text editor of Eclipse), the same\neffect occurs. This behavior can be controlled in Xtext\nwith a special Xtext Formatter.\n\n\nXtext Formatter\n\n\nCreate a new class \"kurs.xtext.dataflow.formatting.MyFormatter\"\nin your Xtext project, which inherits from\n\"org.eclipse.xtext.formatting.impl.AbstractDeclarativeFormatter\".\n\n\n\n\nIn this class you can control, e.g., the formatting\naround '{' and '}'. More Information: e.g., \n\nJavaDoc of FormattingConfig\n.\n\n\nimport\n \norg.eclipse.xtext.Keyword\n;\n\n\nimport\n \norg.eclipse.xtext.formatting.impl.AbstractDeclarativeFormatter\n;\n\n\nimport\n \norg.eclipse.xtext.formatting.impl.FormattingConfig\n;\n\n\nimport\n \norg.eclipse.xtext.util.Pair\n;\n\n\n\nimport\n \nkurs.xtext.dataflow.services.DataFlowDslGrammarAccess\n;\n\n\n\npublic\n \nclass\n \nMyFormatter\n \nextends\n \nAbstractDeclarativeFormatter\n \n{\n\n\n    \n@Override\n\n    \nprotected\n \nvoid\n \nconfigureFormatting\n(\nFormattingConfig\n \nconfig\n)\n \n{\n\n\n        \nDataFlowDslGrammarAccess\n \nga\n \n=\n \n(\nDataFlowDslGrammarAccess\n)\n \ngetGrammarAccess\n();\n\n\n        \nfor\n \n(\nPair\n<\nKeyword\n,\n \nKeyword\n>\n \npair\n \n:\n \nga\n.\nfindKeywordPairs\n(\n\"{\"\n,\n \n\"}\"\n))\n \n{\n\n            \nconfig\n.\nsetLinewrap\n().\nafter\n(\npair\n.\ngetFirst\n());\n\n            \nconfig\n.\nsetIndentationIncrement\n().\nafter\n(\npair\n.\ngetFirst\n());\n\n            \nconfig\n.\nsetLinewrap\n().\nbefore\n(\npair\n.\ngetSecond\n());\n\n            \nconfig\n.\nsetIndentationDecrement\n().\nbefore\n(\npair\n.\ngetSecond\n());\n\n            \nconfig\n.\nsetLinewrap\n().\nafter\n(\npair\n.\ngetSecond\n());\n\n        \n}\n       \n        \nconfig\n.\nsetLinewrap\n(\n1\n,\n \n1\n,\n \n1\n).\nafter\n(\nga\n.\ngetKInstanceRule\n());\n       \n    \n}\n\n\n\n}\n\n\n\n\n\n\nThis new formatter must be registered for your meta model:\nedit the *RuntimeModule\"-file\n\"kurs.xtext.dataflow.DataFlowDslRuntimeModule.xtend\" \nand add the following code:\n\n\noverride\n \nbindIFormatter\n()\n \n{\n\n    \nMyFormatter\n\n\n}\n\n\n\n\n\n\n(Note: Xtend is a language which translates to Java.\nThus, every Xtend class can also be written in Java.)\n\n\nRestart your Eclipse Runtime Workbench and test the new \nformatter (CTRL-SHIFT-F).",
            "title": "Auto Formatting"
        },
        {
            "location": "/xtext_auto_formatting/#auto-formatting",
            "text": "When you change the model (e.g. using the  tree editor )\nand you save your changes, you will notice that the\nmodel text is updated, but does not contain any line breaks.\nAlso, when invooking the auto-formatter of Eclipse \n(CTRL-SHIFT-F in the text editor of Eclipse), the same\neffect occurs. This behavior can be controlled in Xtext\nwith a special Xtext Formatter.",
            "title": "Auto Formatting"
        },
        {
            "location": "/xtext_auto_formatting/#xtext-formatter",
            "text": "Create a new class \"kurs.xtext.dataflow.formatting.MyFormatter\"\nin your Xtext project, which inherits from\n\"org.eclipse.xtext.formatting.impl.AbstractDeclarativeFormatter\".   In this class you can control, e.g., the formatting\naround '{' and '}'. More Information: e.g.,  JavaDoc of FormattingConfig .  import   org.eclipse.xtext.Keyword ;  import   org.eclipse.xtext.formatting.impl.AbstractDeclarativeFormatter ;  import   org.eclipse.xtext.formatting.impl.FormattingConfig ;  import   org.eclipse.xtext.util.Pair ;  import   kurs.xtext.dataflow.services.DataFlowDslGrammarAccess ;  public   class   MyFormatter   extends   AbstractDeclarativeFormatter   { \n\n     @Override \n     protected   void   configureFormatting ( FormattingConfig   config )   { \n\n         DataFlowDslGrammarAccess   ga   =   ( DataFlowDslGrammarAccess )   getGrammarAccess (); \n\n         for   ( Pair < Keyword ,   Keyword >   pair   :   ga . findKeywordPairs ( \"{\" ,   \"}\" ))   { \n             config . setLinewrap (). after ( pair . getFirst ()); \n             config . setIndentationIncrement (). after ( pair . getFirst ()); \n             config . setLinewrap (). before ( pair . getSecond ()); \n             config . setIndentationDecrement (). before ( pair . getSecond ()); \n             config . setLinewrap (). after ( pair . getSecond ()); \n         }        \n         config . setLinewrap ( 1 ,   1 ,   1 ). after ( ga . getKInstanceRule ());        \n     }  }   This new formatter must be registered for your meta model:\nedit the *RuntimeModule\"-file\n\"kurs.xtext.dataflow.DataFlowDslRuntimeModule.xtend\" \nand add the following code:  override   bindIFormatter ()   { \n     MyFormatter  }   (Note: Xtend is a language which translates to Java.\nThus, every Xtend class can also be written in Java.)  Restart your Eclipse Runtime Workbench and test the new \nformatter (CTRL-SHIFT-F).",
            "title": "Xtext Formatter"
        },
        {
            "location": "/xtext_model_validation/",
            "text": "Model Validation\n\n\nA model can be validated according certain validation rules.\nThese rules have to be define by the meta modeller\nin the meta model. Error and warning messages can be reported\nand attached to model elements or text location. These\nmessages are displayed in the Eclipse model text editor.\nMore Information, see \n(Mooji et al., 2017a)\n.\n\n\n(Renz-Reichert, 2017)\n\nsuggested to put as little as possible semantics into\nthe grammar (e.g. \"+\" instead of \"*\") and to add this \nsemantics to the validation code. This often allows\nto generate more meaningful domain errors.\n\n\nValidation Example\n\n\nOpen the *Validator.xtend\" file (automatically generated for\na new project), e.g., \n\"kurs.xtext.dataflow.validation.DataFlowDslValidator.xtend\".\nActivate the commented code and modify it:\n\n\npackage\n \nkurs\n.\nxtext\n.\ndataflow\n.\nvalidation\n\n\n\nimport\n \norg.eclipse.xtext.validation.Check\n\n\nimport\n \nkurs.xtext.dataflow.dataFlowDsl.KComponent\n\n\nimport\n \nkurs.xtext.dataflow.dataFlowDsl.DataFlowDslPackage\n\n\n\nclass\n \nDataFlowDslValidator\n \nextends\n \nAbstractDataFlowDslValidator\n \n{\n\n\n    \npublic\n \nstatic\n \nval\n \nINVALID_NAME\n \n=\n \n'invalidName'\n\n\n    \n@Check\n\n    \ndef\n \ncheckComponentStartsWithCapital\n(\nKComponent\n \nc\n)\n \n{\n\n        \nif\n \n(!\nCharacter\n.\nisUpperCase\n(\nc\n.\nname\n.\ncharAt\n(\n0\n)))\n \n{\n\n            \nwarning\n(\n'Name should start with a capital'\n,\n \n                    \nDataFlowDslPackage\n.\nLiterals\n.\nKCOMPONENT__NAME\n,\n\n                    \nINVALID_NAME\n)\n\n        \n}\n\n    \n}\n   \n\n}\n\n\n\n\n\n\nTry your validator for your language in the Eclipse Runtime model editor.\n\n\n\nNotes:\n\n\n\n\nA validation rule is marked as such with the annotation \"@Check\". \n     The argument is a model element of the type to be checked.\n\n\nThe rule is checked during typing in the editor \n     (@Check allows to control if a rule is checked during \n     typing, when saving, or upon explicit request\n     (see: org.eclipse.xtext.validation.CheckType; \n     press \"F3\" when having the cursor on @Check)\n\n\nThe rule above checks elements of type \"KComponent\". \n     Errors/warning, if present, are attached to this model element.\n\n\nA rule can generate \"errors\", \"warnings\" und \"infos\".\n     The ID (in our case \"INVALID_NAME\") allows a rule to \n     be identified later, e.g., when\n     implementing HotFixes for specific validation violations.",
            "title": "Model Validation"
        },
        {
            "location": "/xtext_model_validation/#model-validation",
            "text": "A model can be validated according certain validation rules.\nThese rules have to be define by the meta modeller\nin the meta model. Error and warning messages can be reported\nand attached to model elements or text location. These\nmessages are displayed in the Eclipse model text editor.\nMore Information, see  (Mooji et al., 2017a) .  (Renz-Reichert, 2017) \nsuggested to put as little as possible semantics into\nthe grammar (e.g. \"+\" instead of \"*\") and to add this \nsemantics to the validation code. This often allows\nto generate more meaningful domain errors.",
            "title": "Model Validation"
        },
        {
            "location": "/xtext_model_validation/#validation-example",
            "text": "Open the *Validator.xtend\" file (automatically generated for\na new project), e.g., \n\"kurs.xtext.dataflow.validation.DataFlowDslValidator.xtend\".\nActivate the commented code and modify it:  package   kurs . xtext . dataflow . validation  import   org.eclipse.xtext.validation.Check  import   kurs.xtext.dataflow.dataFlowDsl.KComponent  import   kurs.xtext.dataflow.dataFlowDsl.DataFlowDslPackage  class   DataFlowDslValidator   extends   AbstractDataFlowDslValidator   { \n\n     public   static   val   INVALID_NAME   =   'invalidName' \n\n     @Check \n     def   checkComponentStartsWithCapital ( KComponent   c )   { \n         if   (! Character . isUpperCase ( c . name . charAt ( 0 )))   { \n             warning ( 'Name should start with a capital' ,  \n                     DataFlowDslPackage . Literals . KCOMPONENT__NAME , \n                     INVALID_NAME ) \n         } \n     }     }   Try your validator for your language in the Eclipse Runtime model editor.  Notes:   A validation rule is marked as such with the annotation \"@Check\". \n     The argument is a model element of the type to be checked.  The rule is checked during typing in the editor \n     (@Check allows to control if a rule is checked during \n     typing, when saving, or upon explicit request\n     (see: org.eclipse.xtext.validation.CheckType; \n     press \"F3\" when having the cursor on @Check)  The rule above checks elements of type \"KComponent\". \n     Errors/warning, if present, are attached to this model element.  A rule can generate \"errors\", \"warnings\" und \"infos\".\n     The ID (in our case \"INVALID_NAME\") allows a rule to \n     be identified later, e.g., when\n     implementing HotFixes for specific validation violations.",
            "title": "Validation Example"
        },
        {
            "location": "/xtext_quickfixes/",
            "text": "Quickfixes\n\n\nOpen the *QuickfixProvider.xtend file of your ui-project, e.g.,\n\"kurs.xtext.dataflow.ui.quickfix.DataFlowDslQuickfixProvider.xtend\".\nHere you can implement Quickfixes.\n\n\nThe example provided as commented code can be activated\nfor our \ninitial example\n more or\nless without modifications:\n\n\n@Fix\n(\nDataFlowDslValidator\n.\nINVALID_NAME\n)\n\n\ndef\n \ncapitalizeName\n(\nIssue\n \nissue\n,\n \nIssueResolutionAcceptor\n \nacceptor\n)\n \n{\n\n    \nacceptor\n.\naccept\n(\nissue\n,\n \n'Capitalize name'\n,\n \n'Capitalize the name.'\n,\n \n'upcase.png'\n)\n \n[\n\n        \ncontext\n \n|\n\n        \nval\n \nxtextDocument\n \n=\n \ncontext\n.\nxtextDocument\n\n        \nval\n \nfirstLetter\n \n=\n \nxtextDocument\n.\nget\n(\nissue\n.\noffset\n,\n \n1\n)\n\n        \nxtextDocument\n.\nreplace\n(\nissue\n.\noffset\n,\n \n1\n,\n \nfirstLetter\n.\ntoUpperCase\n)\n\n    \n]\n\n\n}\n\n\n\n\n\n\nThe \nID of the validation\n \n(here \"INVALID_NAME\") allows to identify the type of the\nissue to be fixed. \n\n\nIn the last example, the Quickfix uses direct access\nto the model text. Alternatively, the model itself can\nbe modified:\n\n\n@Fix\n(\nDataFlowDslValidator\n.\nINVALID_NAME\n)\n\n\ndef\n \ncapitalizeName2\n(\nIssue\n \nissue\n,\n \nIssueResolutionAcceptor\n \nacceptor\n)\n \n{\n\n    \nacceptor\n.\naccept\n(\nissue\n,\n \n'Capitalize name 2'\n,\n \n'Capitalize the name.'\n,\n \n'upcase.png'\n)\n \n[\n\n        \nelement\n,\n \ncontext\n \n|\n\n        \nval\n \nc\n=\nelement\n \nas\n \nKComponent\n\n        \nc\n.\nname\n \n=\n \nc\n.\nname\n.\ntoFirstUpper\n\n    \n]\n\n\n}\n\n\n\n\n\n\nThe annotation \"@Fix\" marks a method as Quickfix-method and\ncontrols the mapping to the validation ID.\n\n\nNote: relevant details concerning Xtend are discussed in\n\nthis section\n\n(e.g., the meaning of \u201eval\u201c, \u201eas\u201c, etc.).",
            "title": "Quickfixes"
        },
        {
            "location": "/xtext_quickfixes/#quickfixes",
            "text": "Open the *QuickfixProvider.xtend file of your ui-project, e.g.,\n\"kurs.xtext.dataflow.ui.quickfix.DataFlowDslQuickfixProvider.xtend\".\nHere you can implement Quickfixes.  The example provided as commented code can be activated\nfor our  initial example  more or\nless without modifications:  @Fix ( DataFlowDslValidator . INVALID_NAME )  def   capitalizeName ( Issue   issue ,   IssueResolutionAcceptor   acceptor )   { \n     acceptor . accept ( issue ,   'Capitalize name' ,   'Capitalize the name.' ,   'upcase.png' )   [ \n         context   | \n         val   xtextDocument   =   context . xtextDocument \n         val   firstLetter   =   xtextDocument . get ( issue . offset ,   1 ) \n         xtextDocument . replace ( issue . offset ,   1 ,   firstLetter . toUpperCase ) \n     ]  }   The  ID of the validation  \n(here \"INVALID_NAME\") allows to identify the type of the\nissue to be fixed.   In the last example, the Quickfix uses direct access\nto the model text. Alternatively, the model itself can\nbe modified:  @Fix ( DataFlowDslValidator . INVALID_NAME )  def   capitalizeName2 ( Issue   issue ,   IssueResolutionAcceptor   acceptor )   { \n     acceptor . accept ( issue ,   'Capitalize name 2' ,   'Capitalize the name.' ,   'upcase.png' )   [ \n         element ,   context   | \n         val   c = element   as   KComponent \n         c . name   =   c . name . toFirstUpper \n     ]  }   The annotation \"@Fix\" marks a method as Quickfix-method and\ncontrols the mapping to the validation ID.  Note: relevant details concerning Xtend are discussed in this section \n(e.g., the meaning of \u201eval\u201c, \u201eas\u201c, etc.).",
            "title": "Quickfixes"
        },
        {
            "location": "/xtext_code_generation_xtend/",
            "text": "Code Generation (with Xtend)\n\n\nXtend is highly optimized to be used\nfor code generation. It has a optimzed template engine (e.g., with\nautomatic indentation support) and\nis fully integrated in the Eclipse IDE (auto completition\nfor model data).\n\n\nExample\n\n\nOpne the *Generator.xtend file in your project, e.g.,\nkurs.xtext.dataflow.generator.DataFlowDslGenerator.xtend. \nHere, you can implement your first code generator:\nYou have model access (parameter \"resource\") and file system access\n(parameter \"fsa\").\n\n\noverride\n \nvoid\n \ndoGenerate\n(\nResource\n \nresource\n,\n \nIFileSystemAccess2\n \nfsa\n,\n \n        \nIGeneratorContext\n \ncontext\n)\n \n{\n\n    \n// -------------------------------------------\n\n    \n// Option 1:\n\n    \nvar\n \ntxt\n \n=\n \n\"\"\n\n    \nfor\n \n(\nobj:\n \nresource\n.\nallContents\n.\ntoIterable\n)\n \n{\n\n        \nif\n \n(\nobj\n \ninstanceof\n \nKComponent\n)\n \n{\n \n// inside this \"if\" obj is a KComponent\n\n            \nif\n \n(\ntxt\n.\nlength\n>\n0\n)\n \ntxt\n \n=\n \ntxt\n \n+\n \n\", \"\n\n            \ntxt\n \n=\n \ntxt\n \n+\n \nobj\n.\nname\n;\n\n        \n}\n\n    \n}\n\n    \nfsa\n.\ngenerateFile\n(\n'Components1.txt'\n,\n \n'Component declarations: '\n \n+\n \ntxt\n);\n\n\n    \n// -------------------------------------------\n\n    \n// Option 2:\n\n    \nfsa\n.\ngenerateFile\n(\n'Components2.txt'\n,\n \n'Component declarations: '\n \n+\n \n        \nresource\n.\nallContents\n\n            \n.\nfilter\n[\n \nobj\n \n|\n \nobj\n \ninstanceof\n \nKComponent\n]\n\n            \n.\nmap\n[\n \nobj\n \n|\n \nreturn\n \n(\nobj\n \nas\n \nKComponent\n).\nname\n \n]\n\n            \n.\njoin\n(\n', '\n))\n\n\n    \n// -------------------------------------------\n\n    \n// Option 3:\n\n    \nfsa\n.\ngenerateFile\n(\n'Components3.txt'\n,\n \n'Component declarations: '\n \n+\n \n        \nresource\n.\nallContents\n.\nfilter\n(\nKComponent\n).\nmap\n[\nname\n].\njoin\n(\n', '\n))\n\n\n}\n\n\n\n\n\n\nTODO\nxxx",
            "title": "Code Generation (with Xtend)"
        },
        {
            "location": "/xtext_code_generation_xtend/#code-generation-with-xtend",
            "text": "Xtend is highly optimized to be used\nfor code generation. It has a optimzed template engine (e.g., with\nautomatic indentation support) and\nis fully integrated in the Eclipse IDE (auto completition\nfor model data).",
            "title": "Code Generation (with Xtend)"
        },
        {
            "location": "/xtext_code_generation_xtend/#example",
            "text": "Opne the *Generator.xtend file in your project, e.g.,\nkurs.xtext.dataflow.generator.DataFlowDslGenerator.xtend. \nHere, you can implement your first code generator:\nYou have model access (parameter \"resource\") and file system access\n(parameter \"fsa\").  override   void   doGenerate ( Resource   resource ,   IFileSystemAccess2   fsa ,  \n         IGeneratorContext   context )   { \n     // ------------------------------------------- \n     // Option 1: \n     var   txt   =   \"\" \n     for   ( obj:   resource . allContents . toIterable )   { \n         if   ( obj   instanceof   KComponent )   {   // inside this \"if\" obj is a KComponent \n             if   ( txt . length > 0 )   txt   =   txt   +   \", \" \n             txt   =   txt   +   obj . name ; \n         } \n     } \n     fsa . generateFile ( 'Components1.txt' ,   'Component declarations: '   +   txt ); \n\n     // ------------------------------------------- \n     // Option 2: \n     fsa . generateFile ( 'Components2.txt' ,   'Component declarations: '   +  \n         resource . allContents \n             . filter [   obj   |   obj   instanceof   KComponent ] \n             . map [   obj   |   return   ( obj   as   KComponent ). name   ] \n             . join ( ', ' )) \n\n     // ------------------------------------------- \n     // Option 3: \n     fsa . generateFile ( 'Components3.txt' ,   'Component declarations: '   +  \n         resource . allContents . filter ( KComponent ). map [ name ]. join ( ', ' ))  }   TODO\nxxx",
            "title": "Example"
        },
        {
            "location": "/textx_project_setup/",
            "text": "TextX Project Setup\n\n\nxxx",
            "title": "TextX Project Setup"
        },
        {
            "location": "/textx_project_setup/#textx-project-setup",
            "text": "xxx",
            "title": "TextX Project Setup"
        },
        {
            "location": "/references/",
            "text": "References\n\n\nMany websites, books and persons influenced this work.\nThe references are summarized in the following sections.\n\n\nToolsets / Language Workbenches\n\n\n\n\nXtext\n - a grammar based language workbench for java/Xtend/eclipse.\n\n\nTextX\n - a grammar based language workbench for Python.\n\n\n\n\nProgramming languages\n\n\n\n\nXtend\n - a statically types language (translates to Java).\n\n\nPython\n - a dynamically types language.\n\n\n\n\nGeneral information\n\n\n\n\n (Tomassetti, 2017) F. Tomassetti: \n\"The complete guide to (external) Domain Specific Languages\"\n (06/2018)\n\n\n\n\nXtext related stuff\n\n\n\n\n(Bettini, 2016) L. Bettini: \"Implementing Domain-Specific Languages with Xtext and Xtend - Second Edition\u201c (Packt Publishing; 2nd Revised edition, 31. August 2016).\n\n\n (Mooij et al, 2017a) A. Mooij, J. Hooman: \n\"Creating a Domain Specific Language (DSL) with Xtext\"\n (2017/06)\n\n\n (Mooji et al, 2017b) A. Mooij, K. Triantafyllidis, J. Hooman: \n\"Advanced Xtext Manual on Modularity\"\n (2017/06)\n\n\n(Rentz-Reichert, 2017) H. Rentz-Reichert (Protos Software): \"Entwicklung dom\u00e4nenspezifischer Sprachen und Code-Generatoren mit Xtext und Xtend\" (german course, Regensburg, 2017/05;\n    architect of \neTrice (ROOM based modeling tool)\n (2017/06)\n\n\n\n\nTextX related stuff\n\n\n\n\n(Dejanovi\u0107 et al. 2017) Dejanovi\u0107 I., Vaderna R., Milosavljevi\u0107 G., Vukovi\u0107 \u017d. (2017). TextX: A Python tool for Domain-Specific Languages implementation. Knowledge-Based Systems, 115, 1-4.",
            "title": "References"
        },
        {
            "location": "/references/#references",
            "text": "Many websites, books and persons influenced this work.\nThe references are summarized in the following sections.",
            "title": "References"
        },
        {
            "location": "/references/#toolsets-language-workbenches",
            "text": "Xtext  - a grammar based language workbench for java/Xtend/eclipse.  TextX  - a grammar based language workbench for Python.",
            "title": "Toolsets / Language Workbenches"
        },
        {
            "location": "/references/#programming-languages",
            "text": "Xtend  - a statically types language (translates to Java).  Python  - a dynamically types language.",
            "title": "Programming languages"
        },
        {
            "location": "/references/#general-information",
            "text": "(Tomassetti, 2017) F. Tomassetti:  \"The complete guide to (external) Domain Specific Languages\"  (06/2018)",
            "title": "General information"
        },
        {
            "location": "/references/#xtext-related-stuff",
            "text": "(Bettini, 2016) L. Bettini: \"Implementing Domain-Specific Languages with Xtext and Xtend - Second Edition\u201c (Packt Publishing; 2nd Revised edition, 31. August 2016).   (Mooij et al, 2017a) A. Mooij, J. Hooman:  \"Creating a Domain Specific Language (DSL) with Xtext\"  (2017/06)   (Mooji et al, 2017b) A. Mooij, K. Triantafyllidis, J. Hooman:  \"Advanced Xtext Manual on Modularity\"  (2017/06)  (Rentz-Reichert, 2017) H. Rentz-Reichert (Protos Software): \"Entwicklung dom\u00e4nenspezifischer Sprachen und Code-Generatoren mit Xtext und Xtend\" (german course, Regensburg, 2017/05;\n    architect of  eTrice (ROOM based modeling tool)  (2017/06)",
            "title": "Xtext related stuff"
        },
        {
            "location": "/references/#textx-related-stuff",
            "text": "(Dejanovi\u0107 et al. 2017) Dejanovi\u0107 I., Vaderna R., Milosavljevi\u0107 G., Vukovi\u0107 \u017d. (2017). TextX: A Python tool for Domain-Specific Languages implementation. Knowledge-Based Systems, 115, 1-4.",
            "title": "TextX related stuff"
        }
    ]
}