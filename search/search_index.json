{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to self-dsl\n\n\nThis is a tutorial site for the creation of domain specific languages.\n\n\n\n\n\n\nMotivation\n:\n    Why using a DSL? What is the value of it? What is MDSD?\n\n\n\n\n\n\nBasics of meta modeling\n\n    What is meta modeled?\n\n\n\n\n\n\nTutorial-like topics for Xtext and TextX (see sidebar).\n\n\n\n\n\n\nReferences\n\n\n\n\n\n\nDevelopment, Sources, License\n\n\nSee: \ngithub sources\n\n\nEmployed software to generate this documentation\n\n\n\n\nWe use \nMkDocs\n to build these\npages (using the \nRead the Docs\n\ntheme).\n\n\nWe employ \nPlantUML\n to produce UML graphics\n(together with a \nplugin\n\nworking together with  \nMkDocs\n).",
            "title": "Welcome to self-dsl"
        },
        {
            "location": "/#welcome-to-self-dsl",
            "text": "This is a tutorial site for the creation of domain specific languages.    Motivation :\n    Why using a DSL? What is the value of it? What is MDSD?    Basics of meta modeling \n    What is meta modeled?    Tutorial-like topics for Xtext and TextX (see sidebar).    References",
            "title": "Welcome to self-dsl"
        },
        {
            "location": "/#development-sources-license",
            "text": "See:  github sources",
            "title": "Development, Sources, License"
        },
        {
            "location": "/#employed-software-to-generate-this-documentation",
            "text": "We use  MkDocs  to build these\npages (using the  Read the Docs \ntheme).  We employ  PlantUML  to produce UML graphics\n(together with a  plugin \nworking together with   MkDocs ).",
            "title": "Employed software to generate this documentation"
        },
        {
            "location": "/motivation/",
            "text": "Motivation\n\n\nThe problem to be solved is two-fold: avoid problems with\n\ncommunication\n and \nconsistency\n.\nA \ncommon language\n will be defined to ease \ncommunication\n within and\nbetween teams. A \nsingle source\n of information implies \nconsistency\n,\nand in turn, prevents misunderstandings.\n\n\n\n\nA very good introduction to domain modeling is\n\n(Tomassetti, 2017)\n.\n\n\nMDSD and DSLs\n\n\nModel driven software development (MDSD)\n allows\nintroducing a supplementary layer of\nabstraction above the code: This additional complexity can be employed to\nreplace traditional model traditional model based design approaches, and\nthus represents a significant design element of a software architecture.\nSuch model driven approaches often also refer to\n\ndomain specific languages (DSL)\n.\nThese languages make the design easy to communicate (defined language at\ndesign level) and at the same time the design itself constitutes of actual\nsoftware artefacts, since code is directly generated from it (single\nsource of information).\n\n\nMeta-model, model, and all that\n\n\nThe meta modeling toolsets utilized on this site typically allow to define\n\n(1) a meta model definition\n, which defines what is modeled, e.g.,\nthe basic layout of a data structure in terms of structures which have\nattributes. This meta model can be compared to a \ndata base layout\n.\nIt also can be compared to \nglossary\n for a given domain.\nUsing the meta model \n(2) model data\n can be defined by a user.\nThis model data represents the concrete \ndata structures for a given domain\n.\n\n(3) Validation\n: importantly, the meta model definition allows to validate\nand check concrete models. Finally, \n(4) code generators and\nmodel transformations\n represent primary end user tools to allow mass\nproduction based on a \nsingle source\n of information (the model).\n\n\nReal value for a project\n\n\nNotably, if a model represents a real abstraction of a software\naspect - something people talk about and which hides important\ndetails - we get a big impact in productivity. From the one and\nsingle source of specification (the model data) we can extract\ndocumentation, plan and archive changes (in the models) and at\nthe same time guarantee the consistency of model and multiple code artefacts.\n\n\nThe \nreal value\n in terms of working hours is not the meta model, the code\ngenerator or the editor of a model, but the \nmodel data\n itself. The\nrest of the employed toolset and definitions (e.g. the meta model) further\nincrease this value, by allowing to validate, transform or\nevaluate the model data.\n\n\nKeeping this in mind, one should keep in  mind to be able to parse and\nunderstand the model data in, say, 10 years. Also think about wht happens if\nmultiple users create conflicts in model files. One should be able to repair\nsuch situations. This is easier if the model stored on disk resembles the\nmodel entered by the user, than if an alternative representation is used\nwith, e.g., binary data representations or machine generated IDs which are\ndifficult to understand. Such a simple representation on disk also allows to\neasily analyze a model with a traditional text search tool (grep) and to\nmake quick modifications to the model with a simple editor.\n\n\nMoreover, the interoperability of employed toolsets is of crucial importancy:\nthe ability to define inter-model relations eases large scale model\ndriven approaches and the IDE integration increases end user acceptance.",
            "title": "Motivation"
        },
        {
            "location": "/motivation/#motivation",
            "text": "The problem to be solved is two-fold: avoid problems with communication  and  consistency .\nA  common language  will be defined to ease  communication  within and\nbetween teams. A  single source  of information implies  consistency ,\nand in turn, prevents misunderstandings.   A very good introduction to domain modeling is (Tomassetti, 2017) .",
            "title": "Motivation"
        },
        {
            "location": "/motivation/#mdsd-and-dsls",
            "text": "Model driven software development (MDSD)  allows\nintroducing a supplementary layer of\nabstraction above the code: This additional complexity can be employed to\nreplace traditional model traditional model based design approaches, and\nthus represents a significant design element of a software architecture.\nSuch model driven approaches often also refer to domain specific languages (DSL) .\nThese languages make the design easy to communicate (defined language at\ndesign level) and at the same time the design itself constitutes of actual\nsoftware artefacts, since code is directly generated from it (single\nsource of information).",
            "title": "MDSD and DSLs"
        },
        {
            "location": "/motivation/#meta-model-model-and-all-that",
            "text": "The meta modeling toolsets utilized on this site typically allow to define (1) a meta model definition , which defines what is modeled, e.g.,\nthe basic layout of a data structure in terms of structures which have\nattributes. This meta model can be compared to a  data base layout .\nIt also can be compared to  glossary  for a given domain.\nUsing the meta model  (2) model data  can be defined by a user.\nThis model data represents the concrete  data structures for a given domain . (3) Validation : importantly, the meta model definition allows to validate\nand check concrete models. Finally,  (4) code generators and\nmodel transformations  represent primary end user tools to allow mass\nproduction based on a  single source  of information (the model).",
            "title": "Meta-model, model, and all that"
        },
        {
            "location": "/motivation/#real-value-for-a-project",
            "text": "Notably, if a model represents a real abstraction of a software\naspect - something people talk about and which hides important\ndetails - we get a big impact in productivity. From the one and\nsingle source of specification (the model data) we can extract\ndocumentation, plan and archive changes (in the models) and at\nthe same time guarantee the consistency of model and multiple code artefacts.  The  real value  in terms of working hours is not the meta model, the code\ngenerator or the editor of a model, but the  model data  itself. The\nrest of the employed toolset and definitions (e.g. the meta model) further\nincrease this value, by allowing to validate, transform or\nevaluate the model data.  Keeping this in mind, one should keep in  mind to be able to parse and\nunderstand the model data in, say, 10 years. Also think about wht happens if\nmultiple users create conflicts in model files. One should be able to repair\nsuch situations. This is easier if the model stored on disk resembles the\nmodel entered by the user, than if an alternative representation is used\nwith, e.g., binary data representations or machine generated IDs which are\ndifficult to understand. Such a simple representation on disk also allows to\neasily analyze a model with a traditional text search tool (grep) and to\nmake quick modifications to the model with a simple editor.  Moreover, the interoperability of employed toolsets is of crucial importancy:\nthe ability to define inter-model relations eases large scale model\ndriven approaches and the IDE integration increases end user acceptance.",
            "title": "Real value for a project"
        },
        {
            "location": "/basics/",
            "text": "Basics of meta modeling for domain models\n\n\nIn this section we describe typical meta modeling tasks.\nMeta modeling is the creation of a meta model.\nThis defines what can be modeled in a model for that given meta model.\n\n\nAll aspects identified here can be found in a tutorial style\nin corresponding sections for TextX and Xtext of this documentation.\n\n\nIntroductory example\n\n\nAn example: A meta model for a programming language defines that, e.g.,\nvariables can be defined. The model, in turn, is a concrete programm\nwith many variable definitions.\n\n\nA meta model may, thus, be sketched as follows:\n\n\n\n\nA program (domain model) may look as follows:\n\n\n\n\nOverview: aspects of meta modeling\n\n\nA summary of different aspects to be specified by the meta model is given\nas follows. This list is inspired by the grammar based toolset\n\nXtext\n\nand \nTextX\n.\n\n\n\n\nWhich \ndomain objects\n exist (\nglossary\n)?\n\n\nHow are objects identified (\nnamed\n)?\n\n\nWhich \nattributes\n do objects have?\n\n\nWhat objects are \ncomposed\n of other objects?\n\n\nWhat objects \naggregates\n other objects?\n\n\nHow do objects \nreference\n each other (including context effects/\nscoping\n)?\n\n\nHow can I \nspecialize\n objects?\n\n\nHow can I \nconnect\n objects?\n\n\nModularization\n: How can an object reference another object from another model\n    (form the same meta model or a different one)?\n\n\nInteroperability\n: How can an object reference something from outside\n    the toolset scope (inter-tool operability)?\n\n\nValidation\n: How can custom rules be checked automatically?\n\n\n\n\nDomain objects: identification and attributes\n\n\nDomain objects represent a central part of a \nglossary\n. Thus,\ndefining such objects is a central part of any software specification\nand must be using through its design.\n\n\nDomain objects\n can represent things, like \"Customers\", \"Computers\",\n\"State machines\". In our context they can also represent activities\nand relationships,  like \"owns\" (a customers owns a computer) or\n\"runs\" (a computer runs a state machine).\nDomain objects may have \nattributes\n, some of them optional. These attributes\nmay have a \nscalar\n value or represent a \nlist\n of entries. The value of the\nattributes can be specified to represent some \nbasic type\n (like a string or a\nnumber) or \nother domain\n objects.\n\n\nImportantly, some domain objects need to be identified by a name (like a\n\"Customer\"), while other objects do not (like the \"Birthday\" in our\nexample below).\n\n\n\n\nNote: Domain objects in the meta model represent a blueprint or a class of a\nconcrete instances of such objects in a concrete model.\n\n\nSee also:\n\n\n\n\nXtext: \nAttributes\n\n\nTextX: \nmetamodel.py\n\n\n\n\nComposing objects\n\n\nDomain objects may be composed of other domain objects. Such a relationship\ncan be described by an attribute with a domain object type (like in the last\nsection). An alternative representation is illustrated as follows, but\ndescribes exactly the same thing:\n\n\n\n\nNote: in this example, a Customer is composed of a Birthday object.\nThe Birthday object cannot exist without the Customer. This relationship\nis called \ncomposition\n and has clear \nownership\n semantics.\n\n\nSee also:\n\n\n\n\nXtext: \nComposition\n\n\nTextX: \nmetamodel.py\n\n\n\n\nReferences and Aggregation\n\n\nSome domain objects need to reference identifiable objects without\nhaving their ownership. This happens, e.g.,\nwhen describing domain object relationships within the model (e.g. a\nCustomer owns a Computer; relationship \"own\"). Such relationships themselves\ncan own additional attributes (e.g. \"owns since date\").\n\n\n\n\nNote: non-owning knowlegde of other objects is called \naggregation\n. Simple\nrelationships can be presented by a simple link (without attributes and without\nown rule/class definition).\n\n\nSee also:\n\n\n\n\nXtext: \nReferences\n\n\nTextX: \nmetamodel.py\n\n\n\n\nScoping\n\n\nScoping is relevant to \ndescribe what objects are identifiable\n when \nreferencing\nother objects\n. This is especially of importance, when some default visibility\nis not valid (most default scoping mechanisms allow all identifiable objects to be\nreferenced globally).\n\n\nAssume the following meta model snippet, where a \"Scenario\" is composed of\n\"Configurations\" and a \"Testcase\" references \"Scenarios\" and \"Configurations\":\n\n\n\n\nIn this case, we want that \nonly \"Configurations\" of the \"Scenario\"\nreferenced by a \"Testcase\" are visible to the \"Testcase\"\n. This\nrestriction is context specific (to the context of the \"Testcase\" described\nby the referenced \"Scenario\"). Scoping mechanisms allow to define this scope.\n\n\nSee also:\n\n\n\n\nXtext: TODO\n\n\nTextX: \nmetamodel.py\n\n\n\n\nSpecialization (base classes/base rules)\n\n\nSometimes it happens that some domain object is too generic and needs to\nbe specialized. This may happen when the language evolves.\nDuring the initial design commonalities are identified which lead to\nthe same pattern (base class and specialization).\n\n\n\n\nSee also:\n\n\n\n\nXtext: TODO\n\n\nTextX: TODO\n\n\n\n\nModularization\n\n\nThis happens when a model is splitted  in multiple submodels\n(e.g., different files).\n\n\n\n\nSee also:\n\n\n\n\nXtext: TODO\n\n\nTextX: TODO\n\n\n\n\nCombining meta models\n\n\nTo foster modularization, meta models can be splitted and still allow to\nreference domain objects of one meta model from the other meta model. In our last example\nwe could define a meta model for \"Testcases\" and one meta model for\n\"Scenarios\". This feature is more demanding to the underlying technology but\nallows a \nmodularization of the meta model and, thus, the glossary\n.\n\n\nSee also:\n\n\n\n\nXtext: TODO\n\n\nTextX: TODO\n\n\n\n\nInteroperability with other toolsets or software components\n\n\nIn larger projects external databases or models may need to be referenced.\nSuch external sources of information may be, e.g., am existing database of\nrequirements, some JSON or XML file or similar things. Interoperability with\nthese sources of information allow to link the model to that source.\n\n\n\n\n Validation\n\n\nThe validation of a model consists of \nadditional checks on top of structural\nconsistency\n defined by the grammar and scoping.\n\n\n\n\nError in the structure\n    result in classical syntax errors (\"\nexpected\n 'XY' instead of 'AB'\").\n\n\nScoping, in turn, defines the possible references in some context and,\n    thus, yields errors of the catergory \"referenced element 'XY' \nnot found\n.\".\n\n\nThe \nvalidation\n described in this section is about additional\n    \nlogical checks\n, once the model is correctly parsed and all\n    references resolved. This additional checks typically have a\n    \nstrong relation to the domain\n.\n\n\n\n\nExample:\n Assume a model where \"testcases\" reference \"configurations of\nscenarios\" which have certain \"aspects\". On the other hand a \"testcase\" may\nneed certain aspects. If any of the \"Aspects\" required by a \"testcase\" is not\navailabe in the referenced \"configuration\", a logical error is reported\n(validation error).\n\n\nRationale\n for choosing a validation over a scoping solution in this case:\nWhen modeling a situation where a \"configuration\" is chosen by a \"testcase\"\nwithout providing the correct \"aspects\", one would not like to get a\n\"configuration not found\", which would result if only \"configurations\" with matching\n\"aspects\" are defined in the \nscope\n of a \"testcase\". In contrast, the\n\nvalidation\n will allow all \"configurations\" of the selected \"scenario\" of\na \"testcase\" to be visible, but some of them will produce a\n\nmeaningful domain error\n, such as\n\"configuration 'config_B' does not provide the aspect 'aspect_X' required\nby testcase 'test_T1'\".\n\n\nThe structure defined in the meta model is shown as follows:\n\n\n\n\nA model with validation error (\n\"configuration 'config_B' does not provide the aspect 'aspect_X' required\nby testcase 'test_T1'\"\n) is shown as follows:\n\n\nscenario\n \nscenario_001\n \n{\n\n    \nconfiguration\n \nconfig_A\n \nhas\n \n{\naspect_X\n}\n\n    \nconfiguration\n \nconfig_B\n \nhas\n \n{\naspect_Y\n}\n\n\n}\n\n\ntestcase\n \ntest_T1\n \n{\n\n    \nuse\n \nscenario_001\n \nwith\n \nconfig_B\n\n    \nand\n \nneeds\n \n{\naspect_X\n}\n\n\n}\n\n\n\n\n\n\n\n\nA model without validation error is shown as follows:\n\n\nscenario\n \nscenario_001\n \n{\n\n    \nconfiguration\n \nconfig_A\n \nhas\n \n{\naspect_X\n}\n\n    \nconfiguration\n \nconfig_B\n \nhas\n \n{\naspect_Y\n,\n \naspect_X\n}\n\n\n}\n\n\ntestcase\n \ntest_T1\n \n{\n\n    \nuse\n \nscenario_001\n \nwith\n \nconfig_B\n\n    \nand\n \nneeds\n \n{\naspect_X\n}\n\n\n}\n\n\n\n\n\n\n\n\nSee also:\n\n\n\n\nXtext: \nValidation\n\n\nTextX: \nvalidation.py",
            "title": "Basics of meta modeling for domain models"
        },
        {
            "location": "/basics/#basics-of-meta-modeling-for-domain-models",
            "text": "In this section we describe typical meta modeling tasks.\nMeta modeling is the creation of a meta model.\nThis defines what can be modeled in a model for that given meta model.  All aspects identified here can be found in a tutorial style\nin corresponding sections for TextX and Xtext of this documentation.",
            "title": "Basics of meta modeling for domain models"
        },
        {
            "location": "/basics/#introductory-example",
            "text": "An example: A meta model for a programming language defines that, e.g.,\nvariables can be defined. The model, in turn, is a concrete programm\nwith many variable definitions.  A meta model may, thus, be sketched as follows:   A program (domain model) may look as follows:",
            "title": "Introductory example"
        },
        {
            "location": "/basics/#overview-aspects-of-meta-modeling",
            "text": "A summary of different aspects to be specified by the meta model is given\nas follows. This list is inspired by the grammar based toolset Xtext \nand  TextX .   Which  domain objects  exist ( glossary )?  How are objects identified ( named )?  Which  attributes  do objects have?  What objects are  composed  of other objects?  What objects  aggregates  other objects?  How do objects  reference  each other (including context effects/ scoping )?  How can I  specialize  objects?  How can I  connect  objects?  Modularization : How can an object reference another object from another model\n    (form the same meta model or a different one)?  Interoperability : How can an object reference something from outside\n    the toolset scope (inter-tool operability)?  Validation : How can custom rules be checked automatically?",
            "title": "Overview: aspects of meta modeling"
        },
        {
            "location": "/basics/#domain-objects-identification-and-attributes",
            "text": "Domain objects represent a central part of a  glossary . Thus,\ndefining such objects is a central part of any software specification\nand must be using through its design.  Domain objects  can represent things, like \"Customers\", \"Computers\",\n\"State machines\". In our context they can also represent activities\nand relationships,  like \"owns\" (a customers owns a computer) or\n\"runs\" (a computer runs a state machine).\nDomain objects may have  attributes , some of them optional. These attributes\nmay have a  scalar  value or represent a  list  of entries. The value of the\nattributes can be specified to represent some  basic type  (like a string or a\nnumber) or  other domain  objects.  Importantly, some domain objects need to be identified by a name (like a\n\"Customer\"), while other objects do not (like the \"Birthday\" in our\nexample below).   Note: Domain objects in the meta model represent a blueprint or a class of a\nconcrete instances of such objects in a concrete model.  See also:   Xtext:  Attributes  TextX:  metamodel.py",
            "title": "Domain objects: identification and attributes"
        },
        {
            "location": "/basics/#composing-objects",
            "text": "Domain objects may be composed of other domain objects. Such a relationship\ncan be described by an attribute with a domain object type (like in the last\nsection). An alternative representation is illustrated as follows, but\ndescribes exactly the same thing:   Note: in this example, a Customer is composed of a Birthday object.\nThe Birthday object cannot exist without the Customer. This relationship\nis called  composition  and has clear  ownership  semantics.  See also:   Xtext:  Composition  TextX:  metamodel.py",
            "title": "Composing objects"
        },
        {
            "location": "/basics/#references-and-aggregation",
            "text": "Some domain objects need to reference identifiable objects without\nhaving their ownership. This happens, e.g.,\nwhen describing domain object relationships within the model (e.g. a\nCustomer owns a Computer; relationship \"own\"). Such relationships themselves\ncan own additional attributes (e.g. \"owns since date\").   Note: non-owning knowlegde of other objects is called  aggregation . Simple\nrelationships can be presented by a simple link (without attributes and without\nown rule/class definition).  See also:   Xtext:  References  TextX:  metamodel.py",
            "title": "References and Aggregation"
        },
        {
            "location": "/basics/#scoping",
            "text": "Scoping is relevant to  describe what objects are identifiable  when  referencing\nother objects . This is especially of importance, when some default visibility\nis not valid (most default scoping mechanisms allow all identifiable objects to be\nreferenced globally).  Assume the following meta model snippet, where a \"Scenario\" is composed of\n\"Configurations\" and a \"Testcase\" references \"Scenarios\" and \"Configurations\":   In this case, we want that  only \"Configurations\" of the \"Scenario\"\nreferenced by a \"Testcase\" are visible to the \"Testcase\" . This\nrestriction is context specific (to the context of the \"Testcase\" described\nby the referenced \"Scenario\"). Scoping mechanisms allow to define this scope.  See also:   Xtext: TODO  TextX:  metamodel.py",
            "title": "Scoping"
        },
        {
            "location": "/basics/#specialization-base-classesbase-rules",
            "text": "Sometimes it happens that some domain object is too generic and needs to\nbe specialized. This may happen when the language evolves.\nDuring the initial design commonalities are identified which lead to\nthe same pattern (base class and specialization).   See also:   Xtext: TODO  TextX: TODO",
            "title": "Specialization (base classes/base rules)"
        },
        {
            "location": "/basics/#modularization",
            "text": "This happens when a model is splitted  in multiple submodels\n(e.g., different files).   See also:   Xtext: TODO  TextX: TODO",
            "title": "Modularization"
        },
        {
            "location": "/basics/#combining-meta-models",
            "text": "To foster modularization, meta models can be splitted and still allow to\nreference domain objects of one meta model from the other meta model. In our last example\nwe could define a meta model for \"Testcases\" and one meta model for\n\"Scenarios\". This feature is more demanding to the underlying technology but\nallows a  modularization of the meta model and, thus, the glossary .  See also:   Xtext: TODO  TextX: TODO",
            "title": "Combining meta models"
        },
        {
            "location": "/basics/#interoperability-with-other-toolsets-or-software-components",
            "text": "In larger projects external databases or models may need to be referenced.\nSuch external sources of information may be, e.g., am existing database of\nrequirements, some JSON or XML file or similar things. Interoperability with\nthese sources of information allow to link the model to that source.",
            "title": "Interoperability with other toolsets or software components"
        },
        {
            "location": "/xtext_eclipse/",
            "text": "Xtext and Eclipse\n\n\nXtext is integrated in Eclispe.\nTo run this tutorial (using Xtext) you need to install Eclipse with the \nappropriate plugins.\n\n\nNote: The parser \"Antlr\" is not distributed with eclipse. You need to install\nit manually \n(itemis update site)\n,\nelse it will be downloaded for every Xtext project you create.\n\n\nDownload and install\n\n\nDownload the package\n\n\"Eclipse Modeling\"\n.\nUnpack the archive to make eclipse available.\n\n\nroot@xtext:~/Download# ls\neclipse-modeling-xxx-linux-gtk-x86_64.tar.gz\nroot@xtext:~/Download# tar xzf eclipse-modeling-xxx-linux-gtk-x86_64.tar.gz\nroot@xtext:~/Download# mv eclipse /opt/\nroot@xtext:~/Download# /opt/eclipse/eclipse \n&\n\n\n\n\n\n\nTo complete the installation you need \"Install Modeling Components\" from the\n\"Help\" menu entry. Select the \"Xtext\" entry and \"Finish\" the installation by\nrestarting eclipse.",
            "title": "Eclipse"
        },
        {
            "location": "/xtext_eclipse/#xtext-and-eclipse",
            "text": "Xtext is integrated in Eclispe.\nTo run this tutorial (using Xtext) you need to install Eclipse with the \nappropriate plugins.  Note: The parser \"Antlr\" is not distributed with eclipse. You need to install\nit manually  (itemis update site) ,\nelse it will be downloaded for every Xtext project you create.",
            "title": "Xtext and Eclipse"
        },
        {
            "location": "/xtext_eclipse/#download-and-install",
            "text": "Download the package \"Eclipse Modeling\" .\nUnpack the archive to make eclipse available.  root@xtext:~/Download# ls\neclipse-modeling-xxx-linux-gtk-x86_64.tar.gz\nroot@xtext:~/Download# tar xzf eclipse-modeling-xxx-linux-gtk-x86_64.tar.gz\nroot@xtext:~/Download# mv eclipse /opt/\nroot@xtext:~/Download# /opt/eclipse/eclipse  &   To complete the installation you need \"Install Modeling Components\" from the\n\"Help\" menu entry. Select the \"Xtext\" entry and \"Finish\" the installation by\nrestarting eclipse.",
            "title": "Download and install"
        },
        {
            "location": "/xtext_project_setup/",
            "text": "Xtext Project Setup\n\n\nCreate a new Xtext Project\n\n\nFollow section \"Create A New Xtext Project\"\nin \n(Xtext 15 Minutes Tutorial)\n.\n\n\nIn addition to the information from the tutorial we\nsuggest the following details for the other examples\ndiscussed on this site:\n\n\n\nThe example grammar (automatically created after project\ninitialization) defines a \"Model\" consisting of \n\"Greetings\" is shown in the following. A \"Model\" contains \"Greetings\".\nEvery \"Greeting\" consists of the Text 'Hello' and a name followed by '!'\n(details below).\n\n\ngrammar\n \norg.example.domainmodel.Domainmodel\n \nwith\n\n\n                                  \norg.eclipse.xtext.common.Terminals\n\n\ngenerate\n \ndomainmodel\n \n\"http\n:\n//www.example.org/domainmodel/Domainmodel\"\n\n\n\nModel\n:\n\n\n    \ngreetings\n+=\nGreeting\n*\n;\n\n\n\nGreeting\n:\n\n\n    \n'Hello'\n \nname\n=\nID\n \n'!'\n;\n\n\n\n\n\n\n\n\nNotes:\n\n\n\n\n\"+=\" denotes the owner relationship of one Model containing many Greetings \n    (\ncomposition\n).\n\n\n\"name=ID\" defines an attribute \"name\" of the Rule \"Greeting\" (allowing to \n    define model elements of the type \"Greeting\"; \nattributes\n of \n    \nmodel elements\n).\n\n\nThe attribute name has a special meaning by default, to denote the \n    identifier of the Rule (\nidentification of model elements\n).\n\n\nID is a terminal (like INT, STRING, etc.; see grammar, and click \"F3\" on\n      \"org.eclipse.xtext.common.Terminals\" to see definition).\n   \"name=ID\" means that the attribute \"name\" is parsed as \"ID\" (which in turn\n   is - more or less - an alphanumerical word staring with no number)\n\n\n\n\nTODO Note: Use \"Team -> Git -> Project for \"Automatically ignore derived resources\"\nto add an appropriate .gitignore file to your project (when using git).\n\n\n Compile and Run the Project\n\n\nWithout modifing the grammar (or anything else), follow the steps in\nsection \"Generate Language Artifacts\" in \n\n(Xtext 15 Minutes Tutorial)\n.\n\n\nAfter this, you can use explore the editor and enter a model according to \nthe example meta model grammar provided by the Xtext project setup. \n\n\nNow you can play with your new language (type CTRL-Space to get auto\ncompletion). Enter the following example:\n\n\nHello Pierre!\n\n\nHello Tim!\n\n\nHello Markus!\n\n\n\n\n\n\nBuild meta model using maven\n\n\nWhen maven is selected as build tool, you can also use maven (instead of\neclipse) to build your project on the command line: Go to the \"parent\" \nproject and run \"mvn package\".\n\n\nMaven will download all required packages in \"~/.m2\" (locally) and then build \nyour subprojects. The output is located in the folder \"target\" of each \nsubproject.\n\n\nSee also: \n(Maven)\n.",
            "title": "Xtext Project Setup"
        },
        {
            "location": "/xtext_project_setup/#xtext-project-setup",
            "text": "",
            "title": "Xtext Project Setup"
        },
        {
            "location": "/xtext_project_setup/#create-a-new-xtext-project",
            "text": "Follow section \"Create A New Xtext Project\"\nin  (Xtext 15 Minutes Tutorial) .  In addition to the information from the tutorial we\nsuggest the following details for the other examples\ndiscussed on this site:  The example grammar (automatically created after project\ninitialization) defines a \"Model\" consisting of \n\"Greetings\" is shown in the following. A \"Model\" contains \"Greetings\".\nEvery \"Greeting\" consists of the Text 'Hello' and a name followed by '!'\n(details below).  grammar   org.example.domainmodel.Domainmodel   with                                     org.eclipse.xtext.common.Terminals  generate   domainmodel   \"http : //www.example.org/domainmodel/Domainmodel\"  Model :       greetings += Greeting * ;  Greeting :       'Hello'   name = ID   '!' ;    Notes:   \"+=\" denotes the owner relationship of one Model containing many Greetings \n    ( composition ).  \"name=ID\" defines an attribute \"name\" of the Rule \"Greeting\" (allowing to \n    define model elements of the type \"Greeting\";  attributes  of \n     model elements ).  The attribute name has a special meaning by default, to denote the \n    identifier of the Rule ( identification of model elements ).  ID is a terminal (like INT, STRING, etc.; see grammar, and click \"F3\" on\n      \"org.eclipse.xtext.common.Terminals\" to see definition).\n   \"name=ID\" means that the attribute \"name\" is parsed as \"ID\" (which in turn\n   is - more or less - an alphanumerical word staring with no number)   TODO Note: Use \"Team -> Git -> Project for \"Automatically ignore derived resources\"\nto add an appropriate .gitignore file to your project (when using git).",
            "title": "Create a new Xtext Project"
        },
        {
            "location": "/xtext_project_setup/#build-meta-model-using-maven",
            "text": "When maven is selected as build tool, you can also use maven (instead of\neclipse) to build your project on the command line: Go to the \"parent\" \nproject and run \"mvn package\".  Maven will download all required packages in \"~/.m2\" (locally) and then build \nyour subprojects. The output is located in the folder \"target\" of each \nsubproject.  See also:  (Maven) .",
            "title": "Build meta model using maven"
        },
        {
            "location": "/xtext_a_first_grammar/",
            "text": "A First Grammar\n\n\nHere we highlight some information when walking through\n\n(Xtext 15 Minutes Tutorial)\n.\n\n\nStep 1: Create and run an Xtext project\n\n\nTake your time for this tutorial now and continue reading afterwards.\nYou may \nstop before \"Second Iteration\"\n where \"packages\"\nare added to the model.\n\n\nStep 2: Lessons learned\n\n\nCheck if you understood thw following points:\n\n\n\n\nWhat is the role of the \nstart rule\n of a grammar in a meta model?\n\n\nWhat is the meaning of \"Type: DataType | Entity;\" in terms of inheritance? \n    Explore the generated Java Interfaces for the classes Type, DataType, \n    Entity in  src-gen/org/example/domainmodel/domainmodel in your main \n    project.\n\n\nHow do you typically add keywords to your language (like \"entity\")?\n\n\nWhat is the difference between \"x=Rule1\" and \"x=[Rule1]\" \n    \n Attributes, \n    \n References?\n\n\nHow can you model the following?\n\n\n\"a \nnamed\n \nUniversity\n aggregates \nnamed\n \nStudents\n\".\n\n\n\"a \nHouse\n is composed of \nRooms\n\" \n    \n Composition.\n\n\n\n\n\n\nExplain the role of \"?\" in the following examples: \n\n\n(x=INT)?\n\n\nenabled?='enabled'\n\n\n\n\n\n\n\n\nNote:\n\n\n\n\nOptional attributes can be defined using \"?\". Note: some types, like \n references, are null if not set. Others have default values (like an empty\n String for STRING, \"0\" for INT or the first enum value defined for enums).\n\n\n\n\nEditor\n\n\nIn addition to the text editor,\nyou can also edit the model with a \ntree editor\n:\nopen wthe file with \"Open With...\" - \"Sample Ecore Model Editor\".\n\n\nWhen editing the model graph, the model text is changed accordingly: \nsee \nAuto Formatting\n.\n\n\nVisualize the meta model\n\n\nThe \necore model\n  deduced from the grammar can be \nvisualized\n:\nsee \n(Mooij et al, 2017a)\n,\nsection \"Optional: Ecore diagram\" (\u201eInitialize Ecore Diagram ...\u201c).\n\n\nMoreover a \nsyntax tree\n can be rendered from the grammar:\nsee \n(Mooij et al, 2017a)\n,\nsection \"Optional: View Diagram of Xtext Grammar\"\n(Window/Show View/Other.../Xtext/Xtext Syntax Graph).",
            "title": "A First Grammar"
        },
        {
            "location": "/xtext_a_first_grammar/#a-first-grammar",
            "text": "Here we highlight some information when walking through (Xtext 15 Minutes Tutorial) .",
            "title": "A First Grammar"
        },
        {
            "location": "/xtext_a_first_grammar/#step-1-create-and-run-an-xtext-project",
            "text": "Take your time for this tutorial now and continue reading afterwards.\nYou may  stop before \"Second Iteration\"  where \"packages\"\nare added to the model.",
            "title": "Step 1: Create and run an Xtext project"
        },
        {
            "location": "/xtext_a_first_grammar/#step-2-lessons-learned",
            "text": "Check if you understood thw following points:   What is the role of the  start rule  of a grammar in a meta model?  What is the meaning of \"Type: DataType | Entity;\" in terms of inheritance? \n    Explore the generated Java Interfaces for the classes Type, DataType, \n    Entity in  src-gen/org/example/domainmodel/domainmodel in your main \n    project.  How do you typically add keywords to your language (like \"entity\")?  What is the difference between \"x=Rule1\" and \"x=[Rule1]\" \n      Attributes, \n      References?  How can you model the following?  \"a  named   University  aggregates  named   Students \".  \"a  House  is composed of  Rooms \" \n      Composition.    Explain the role of \"?\" in the following examples:   (x=INT)?  enabled?='enabled'     Note:   Optional attributes can be defined using \"?\". Note: some types, like \n references, are null if not set. Others have default values (like an empty\n String for STRING, \"0\" for INT or the first enum value defined for enums).",
            "title": "Step 2: Lessons learned"
        },
        {
            "location": "/xtext_a_first_grammar/#editor",
            "text": "In addition to the text editor,\nyou can also edit the model with a  tree editor :\nopen wthe file with \"Open With...\" - \"Sample Ecore Model Editor\".  When editing the model graph, the model text is changed accordingly: \nsee  Auto Formatting .",
            "title": "Editor"
        },
        {
            "location": "/xtext_a_first_grammar/#visualize-the-meta-model",
            "text": "The  ecore model   deduced from the grammar can be  visualized :\nsee  (Mooij et al, 2017a) ,\nsection \"Optional: Ecore diagram\" (\u201eInitialize Ecore Diagram ...\u201c).  Moreover a  syntax tree  can be rendered from the grammar:\nsee  (Mooij et al, 2017a) ,\nsection \"Optional: View Diagram of Xtext Grammar\"\n(Window/Show View/Other.../Xtext/Xtext Syntax Graph).",
            "title": "Visualize the meta model"
        },
        {
            "location": "/xtext_model_validation/",
            "text": "Model \n Validation\n\n\nA model can be validated according certain validation rules.\nThese rules have to be define by the meta modeller\nin the meta model. Error and warning messages can be reported\nand attached to model elements or text location. These\nmessages are displayed in the Eclipse model text editor.\nMore Information, see \n(Mooij et al, 2017a)\n.\n\n\n(Rentz-Reichert, 2017)\n\nsuggested to put as little as possible semantics into\nthe grammar (e.g. \"+\" instead of \"*\") and to add this \nsemantics to the validation code. This often allows\nto generate more meaningful domain errors.\n\n\nValidation Example\n\n\nOpen the *Validator.xtend\" file (automatically generated for\na new project), e.g., \n\"kurs.xtext.dataflow.validation.DataFlowDslValidator.xtend\".\nActivate the commented code and modify it:\n\n\npackage\n \nkurs\n.\nxtext\n.\ndataflow\n.\nvalidation\n\n\n\nimport\n \norg.eclipse.xtext.validation.Check\n\n\nimport\n \nkurs.xtext.dataflow.dataFlowDsl.KComponent\n\n\nimport\n \nkurs.xtext.dataflow.dataFlowDsl.DataFlowDslPackage\n\n\n\nclass\n \nDataFlowDslValidator\n \nextends\n \nAbstractDataFlowDslValidator\n \n{\n\n\n    \npublic\n \nstatic\n \nval\n \nINVALID_NAME\n \n=\n \n'invalidName'\n\n\n    \n@Check\n\n    \ndef\n \ncheckComponentStartsWithCapital\n(\nKComponent\n \nc\n)\n \n{\n\n        \nif\n \n(!\nCharacter\n.\nisUpperCase\n(\nc\n.\nname\n.\ncharAt\n(\n0\n)))\n \n{\n\n            \nwarning\n(\n'Name should start with a capital'\n,\n \n                    \nDataFlowDslPackage\n.\nLiterals\n.\nKCOMPONENT__NAME\n,\n\n                    \nINVALID_NAME\n)\n\n        \n}\n\n    \n}\n   \n\n}\n\n\n\n\n\n\nTry your validator for your language in the Eclipse Runtime model editor.\n\n\n\nNotes:\n\n\n\n\nA validation rule is marked as such with the annotation \"@Check\". \n     The argument is a model element of the type to be checked.\n\n\nThe rule is checked during typing in the editor \n     (@Check allows to control if a rule is checked during \n     typing, when saving, or upon explicit request\n     (see: org.eclipse.xtext.validation.CheckType; \n     press \"F3\" when having the cursor on @Check)\n\n\nThe rule above checks elements of type \"KComponent\". \n     Errors/warning, if present, are attached to this model element.\n\n\nA rule can generate \"errors\", \"warnings\" und \"infos\".\n     The ID (in our case \"INVALID_NAME\") allows a rule to \n     be identified later, e.g., when\n     implementing HotFixes for specific validation violations.",
            "title": "Model Validation"
        },
        {
            "location": "/xtext_model_validation/#model-validation",
            "text": "A model can be validated according certain validation rules.\nThese rules have to be define by the meta modeller\nin the meta model. Error and warning messages can be reported\nand attached to model elements or text location. These\nmessages are displayed in the Eclipse model text editor.\nMore Information, see  (Mooij et al, 2017a) .  (Rentz-Reichert, 2017) \nsuggested to put as little as possible semantics into\nthe grammar (e.g. \"+\" instead of \"*\") and to add this \nsemantics to the validation code. This often allows\nto generate more meaningful domain errors.",
            "title": "Model "
        },
        {
            "location": "/xtext_model_validation/#validation-example",
            "text": "Open the *Validator.xtend\" file (automatically generated for\na new project), e.g., \n\"kurs.xtext.dataflow.validation.DataFlowDslValidator.xtend\".\nActivate the commented code and modify it:  package   kurs . xtext . dataflow . validation  import   org.eclipse.xtext.validation.Check  import   kurs.xtext.dataflow.dataFlowDsl.KComponent  import   kurs.xtext.dataflow.dataFlowDsl.DataFlowDslPackage  class   DataFlowDslValidator   extends   AbstractDataFlowDslValidator   { \n\n     public   static   val   INVALID_NAME   =   'invalidName' \n\n     @Check \n     def   checkComponentStartsWithCapital ( KComponent   c )   { \n         if   (! Character . isUpperCase ( c . name . charAt ( 0 )))   { \n             warning ( 'Name should start with a capital' ,  \n                     DataFlowDslPackage . Literals . KCOMPONENT__NAME , \n                     INVALID_NAME ) \n         } \n     }     }   Try your validator for your language in the Eclipse Runtime model editor.  Notes:   A validation rule is marked as such with the annotation \"@Check\". \n     The argument is a model element of the type to be checked.  The rule is checked during typing in the editor \n     (@Check allows to control if a rule is checked during \n     typing, when saving, or upon explicit request\n     (see: org.eclipse.xtext.validation.CheckType; \n     press \"F3\" when having the cursor on @Check)  The rule above checks elements of type \"KComponent\". \n     Errors/warning, if present, are attached to this model element.  A rule can generate \"errors\", \"warnings\" und \"infos\".\n     The ID (in our case \"INVALID_NAME\") allows a rule to \n     be identified later, e.g., when\n     implementing HotFixes for specific validation violations.",
            "title": "Validation Example"
        },
        {
            "location": "/xtext_quickfixes/",
            "text": "Quickfixes\n\n\nOpen the *QuickfixProvider.xtend file of your ui-project, e.g.,\n\"kurs.xtext.dataflow.ui.quickfix.DataFlowDslQuickfixProvider.xtend\".\nHere you can implement Quickfixes.\n\n\nThe example provided as commented code can be activated\nfor our \ninitial example\n more or\nless without modifications:\n\n\n@Fix\n(\nDataFlowDslValidator\n.\nINVALID_NAME\n)\n\n\ndef\n \ncapitalizeName\n(\nIssue\n \nissue\n,\n \nIssueResolutionAcceptor\n \nacceptor\n)\n \n{\n\n    \nacceptor\n.\naccept\n(\nissue\n,\n \n'Capitalize name'\n,\n \n'Capitalize the name.'\n,\n \n'upcase.png'\n)\n \n[\n\n        \ncontext\n \n|\n\n        \nval\n \nxtextDocument\n \n=\n \ncontext\n.\nxtextDocument\n\n        \nval\n \nfirstLetter\n \n=\n \nxtextDocument\n.\nget\n(\nissue\n.\noffset\n,\n \n1\n)\n\n        \nxtextDocument\n.\nreplace\n(\nissue\n.\noffset\n,\n \n1\n,\n \nfirstLetter\n.\ntoUpperCase\n)\n\n    \n]\n\n\n}\n\n\n\n\n\n\nThe \nID of the validation\n \n(here \"INVALID_NAME\") allows to identify the type of the\nissue to be fixed. \n\n\nIn the last example, the Quickfix uses direct access\nto the model text. Alternatively, the model itself can\nbe modified:\n\n\n@Fix\n(\nDataFlowDslValidator\n.\nINVALID_NAME\n)\n\n\ndef\n \ncapitalizeName2\n(\nIssue\n \nissue\n,\n \nIssueResolutionAcceptor\n \nacceptor\n)\n \n{\n\n    \nacceptor\n.\naccept\n(\nissue\n,\n \n'Capitalize name 2'\n,\n \n'Capitalize the name.'\n,\n \n'upcase.png'\n)\n \n[\n\n        \nelement\n,\n \ncontext\n \n|\n\n        \nval\n \nc\n=\nelement\n \nas\n \nKComponent\n\n        \nc\n.\nname\n \n=\n \nc\n.\nname\n.\ntoFirstUpper\n\n    \n]\n\n\n}\n\n\n\n\n\n\nThe annotation \"@Fix\" marks a method as Quickfix-method and\ncontrols the mapping to the validation ID.\n\n\nNote: relevant details concerning Xtend are discussed in\n\nthis section\n\n(e.g., the meaning of \u201eval\u201c, \u201eas\u201c, etc.).",
            "title": "Quickfixes"
        },
        {
            "location": "/xtext_quickfixes/#quickfixes",
            "text": "Open the *QuickfixProvider.xtend file of your ui-project, e.g.,\n\"kurs.xtext.dataflow.ui.quickfix.DataFlowDslQuickfixProvider.xtend\".\nHere you can implement Quickfixes.  The example provided as commented code can be activated\nfor our  initial example  more or\nless without modifications:  @Fix ( DataFlowDslValidator . INVALID_NAME )  def   capitalizeName ( Issue   issue ,   IssueResolutionAcceptor   acceptor )   { \n     acceptor . accept ( issue ,   'Capitalize name' ,   'Capitalize the name.' ,   'upcase.png' )   [ \n         context   | \n         val   xtextDocument   =   context . xtextDocument \n         val   firstLetter   =   xtextDocument . get ( issue . offset ,   1 ) \n         xtextDocument . replace ( issue . offset ,   1 ,   firstLetter . toUpperCase ) \n     ]  }   The  ID of the validation  \n(here \"INVALID_NAME\") allows to identify the type of the\nissue to be fixed.   In the last example, the Quickfix uses direct access\nto the model text. Alternatively, the model itself can\nbe modified:  @Fix ( DataFlowDslValidator . INVALID_NAME )  def   capitalizeName2 ( Issue   issue ,   IssueResolutionAcceptor   acceptor )   { \n     acceptor . accept ( issue ,   'Capitalize name 2' ,   'Capitalize the name.' ,   'upcase.png' )   [ \n         element ,   context   | \n         val   c = element   as   KComponent \n         c . name   =   c . name . toFirstUpper \n     ]  }   The annotation \"@Fix\" marks a method as Quickfix-method and\ncontrols the mapping to the validation ID.  Note: relevant details concerning Xtend are discussed in this section \n(e.g., the meaning of \u201eval\u201c, \u201eas\u201c, etc.).",
            "title": "Quickfixes"
        },
        {
            "location": "/xtext_code_generation_xtend/",
            "text": "Code Generation (with Xtend)\n\n\nXtend is highly optimized to be used\nfor code generation. It has a optimzed template engine (e.g., with\nautomatic indentation support) and\nis fully integrated in the Eclipse IDE (auto completition\nfor model data).\n\n\nSimple Example\n\n\nOpen the *Generator.xtend file in your project, e.g.,\nkurs.xtext.dataflow.generator.DataFlowDslGenerator.xtend. \nHere, you can implement your first code generator:\nYou have model access (parameter \"resource\") and file system access\n(parameter \"fsa\").\n\n\noverride\n \nvoid\n \ndoGenerate\n(\nResource\n \nresource\n,\n \nIFileSystemAccess2\n \nfsa\n,\n \n        \nIGeneratorContext\n \ncontext\n)\n \n{\n\n    \n// -------------------------------------------\n\n    \n// Option 1:\n\n    \nvar\n \ntxt\n \n=\n \n\"\"\n\n    \nfor\n \n(\nobj:\n \nresource\n.\nallContents\n.\ntoIterable\n)\n \n{\n\n        \nif\n \n(\nobj\n \ninstanceof\n \nKComponent\n)\n \n{\n \n// inside this \"if\" obj is a KComponent\n\n            \nif\n \n(\ntxt\n.\nlength\n>\n0\n)\n \ntxt\n \n=\n \ntxt\n \n+\n \n\", \"\n\n            \ntxt\n \n=\n \ntxt\n \n+\n \nobj\n.\nname\n;\n\n        \n}\n\n    \n}\n\n    \nfsa\n.\ngenerateFile\n(\n'Components1.txt'\n,\n \n'Component declarations: '\n \n+\n \ntxt\n);\n\n\n    \n// -------------------------------------------\n\n    \n// Option 2:\n\n    \nfsa\n.\ngenerateFile\n(\n'Components2.txt'\n,\n \n'Component declarations: '\n \n+\n \n        \nresource\n.\nallContents\n\n            \n.\nfilter\n[\n \nobj\n \n|\n \nobj\n \ninstanceof\n \nKComponent\n]\n\n            \n.\nmap\n[\n \nobj\n \n|\n \nreturn\n \n(\nobj\n \nas\n \nKComponent\n).\nname\n \n]\n\n            \n.\njoin\n(\n', '\n))\n\n\n    \n// -------------------------------------------\n\n    \n// Option 3:\n\n    \nfsa\n.\ngenerateFile\n(\n'Components3.txt'\n,\n \n'Component declarations: '\n \n+\n \n        \nresource\n.\nallContents\n.\nfilter\n(\nKComponent\n).\nmap\n[\nname\n].\njoin\n(\n', '\n))\n\n\n}\n\n\n\n\n\n\nIn the last example we generate a text describing a list of components on \nthree different manners.\n\n\n\n\nA traditional for-each loop\n\n\nNote: \"auto-casting\" happens; this mean if a type of an inctance is \n  checked (if \u201einstanceof\u201c), \n  the object is automatically casted to that type within the \n  body of the if.\n\n\nSemicolons are optional.\n\n\n\"var\" und \"val\" are used to declare variable (val: final variables).\n\n\n\n\n\n\nA filter/map/join combination with explicit lambda (\u201e[ param | code ]\u201c)\n\n\nThe lambda function is directly defined with square brackets '['...']'.\n\n\nThe brackets '('...')' of the function call are omitted.\n\n\nThe parameter of the lambda function are stated before the \"|\"\n  within the '['..']'.\n\n\n\n\n\n\nA filter/map/join combination with compact lambdas and class filters: \n\n\nfilter(Class) filters according to the passed class \"Class\".\n\n\nmap: here, the parameter is implizit defined (and can be addressed \n  with the name \"it\": e.g., it.name). \n  Moreover, the implicit name of the parameter can be omitted,\n  thus, \"name\" corresponds to \"it.name\" here: \n  \"[a | a.name]\" \u2192 \"[name]\" oder \"[it.name]\"\n\n\n\"return\" can be omitted: The last expression is the return value.\n\n\n\n\n\n\n\n\nThe generated files contain the text:\n\n\nComponent declarations: PC, DF\n\n\n\n\n\n\nXtend template engine\n\n\nXtext and Xtend provide a powerful template engine. With this engine\noutput text and code can be easily mixed. Moreover, indentations\nin this mixed code are separated between output indentation and logical\ntemplate code indentation (see example: the indentation from the nested\nFOR statement are ignored in the output).\n\n\n    ::xtend\n    // -------------------------------------------\n    // Option 4:\n    val model = resource.contents.get(0) as Model\n    fsa.generateFile('Components4.txt', '''\n    The Components of the model are:\n    \u00abFOR p: model.packages\u00bb\n        Package \u00abp.name\u00bb\n        \u00abFOR c: p.components\u00bb\n            KComponent \u00abc.name\u00bb\n            \u00abFOR port: c.ports SEPARATOR \", \"\u00bb \n            - with port \u00abport.name\u00bb\n            \u00abENDFOR\u00bb\n        \u00abENDFOR\u00bb\n    \u00abENDFOR\u00bb\n    ''');\n\n\n\n\n\nSuch templates are defined with a multi line string bounded by\nthree single qutation marks.\nWithin the template special commands (like FOR-loops) can be \nexpressed with text bounded by french quotes.\nThe editor supports many features, such as automatic completition of model\ndata and displaying the actual indentation. \n\n\nNote:\n  * This example als illustrates how to get the\n    root of the model (val model=...).\n  * It also shows how to cast an object: \u201eobj as Type\u201c.\n\n\nOutput (generated artefact; note the indentation in the template is omitted):\n\n\nThe Components of the model are:\n\n\nPackage test1\n\n\nKComponent PC\n\n\n- with port in, \n\n\n- with port out\n\n\nKComponent DF\n\n\n- with port in, \n\n\n- with port out, \n\n\n- with port debug",
            "title": "Code Generation (with Xtend)"
        },
        {
            "location": "/xtext_code_generation_xtend/#code-generation-with-xtend",
            "text": "Xtend is highly optimized to be used\nfor code generation. It has a optimzed template engine (e.g., with\nautomatic indentation support) and\nis fully integrated in the Eclipse IDE (auto completition\nfor model data).",
            "title": "Code Generation (with Xtend)"
        },
        {
            "location": "/xtext_code_generation_xtend/#simple-example",
            "text": "Open the *Generator.xtend file in your project, e.g.,\nkurs.xtext.dataflow.generator.DataFlowDslGenerator.xtend. \nHere, you can implement your first code generator:\nYou have model access (parameter \"resource\") and file system access\n(parameter \"fsa\").  override   void   doGenerate ( Resource   resource ,   IFileSystemAccess2   fsa ,  \n         IGeneratorContext   context )   { \n     // ------------------------------------------- \n     // Option 1: \n     var   txt   =   \"\" \n     for   ( obj:   resource . allContents . toIterable )   { \n         if   ( obj   instanceof   KComponent )   {   // inside this \"if\" obj is a KComponent \n             if   ( txt . length > 0 )   txt   =   txt   +   \", \" \n             txt   =   txt   +   obj . name ; \n         } \n     } \n     fsa . generateFile ( 'Components1.txt' ,   'Component declarations: '   +   txt ); \n\n     // ------------------------------------------- \n     // Option 2: \n     fsa . generateFile ( 'Components2.txt' ,   'Component declarations: '   +  \n         resource . allContents \n             . filter [   obj   |   obj   instanceof   KComponent ] \n             . map [   obj   |   return   ( obj   as   KComponent ). name   ] \n             . join ( ', ' )) \n\n     // ------------------------------------------- \n     // Option 3: \n     fsa . generateFile ( 'Components3.txt' ,   'Component declarations: '   +  \n         resource . allContents . filter ( KComponent ). map [ name ]. join ( ', ' ))  }   In the last example we generate a text describing a list of components on \nthree different manners.   A traditional for-each loop  Note: \"auto-casting\" happens; this mean if a type of an inctance is \n  checked (if \u201einstanceof\u201c), \n  the object is automatically casted to that type within the \n  body of the if.  Semicolons are optional.  \"var\" und \"val\" are used to declare variable (val: final variables).    A filter/map/join combination with explicit lambda (\u201e[ param | code ]\u201c)  The lambda function is directly defined with square brackets '['...']'.  The brackets '('...')' of the function call are omitted.  The parameter of the lambda function are stated before the \"|\"\n  within the '['..']'.    A filter/map/join combination with compact lambdas and class filters:   filter(Class) filters according to the passed class \"Class\".  map: here, the parameter is implizit defined (and can be addressed \n  with the name \"it\": e.g., it.name). \n  Moreover, the implicit name of the parameter can be omitted,\n  thus, \"name\" corresponds to \"it.name\" here: \n  \"[a | a.name]\" \u2192 \"[name]\" oder \"[it.name]\"  \"return\" can be omitted: The last expression is the return value.     The generated files contain the text:  Component declarations: PC, DF",
            "title": "Simple Example"
        },
        {
            "location": "/xtext_code_generation_xtend/#xtend-template-engine",
            "text": "Xtext and Xtend provide a powerful template engine. With this engine\noutput text and code can be easily mixed. Moreover, indentations\nin this mixed code are separated between output indentation and logical\ntemplate code indentation (see example: the indentation from the nested\nFOR statement are ignored in the output).      ::xtend\n    // -------------------------------------------\n    // Option 4:\n    val model = resource.contents.get(0) as Model\n    fsa.generateFile('Components4.txt', '''\n    The Components of the model are:\n    \u00abFOR p: model.packages\u00bb\n        Package \u00abp.name\u00bb\n        \u00abFOR c: p.components\u00bb\n            KComponent \u00abc.name\u00bb\n            \u00abFOR port: c.ports SEPARATOR \", \"\u00bb \n            - with port \u00abport.name\u00bb\n            \u00abENDFOR\u00bb\n        \u00abENDFOR\u00bb\n    \u00abENDFOR\u00bb\n    ''');  Such templates are defined with a multi line string bounded by\nthree single qutation marks.\nWithin the template special commands (like FOR-loops) can be \nexpressed with text bounded by french quotes.\nThe editor supports many features, such as automatic completition of model\ndata and displaying the actual indentation.   Note:\n  * This example als illustrates how to get the\n    root of the model (val model=...).\n  * It also shows how to cast an object: \u201eobj as Type\u201c.  Output (generated artefact; note the indentation in the template is omitted):  The Components of the model are:  Package test1  KComponent PC  - with port in,   - with port out  KComponent DF  - with port in,   - with port out,   - with port debug",
            "title": "Xtend template engine"
        },
        {
            "location": "/xtext_xtend/",
            "text": "Xtend: Selected Aspects\n\n\nIn addition to the features sketched in the\n\n\"code generation with Xtend\" section\n\nthis section provides some selected aspects we found useful for our work.\n\n\nExtension mechanism\n\n\nXtend has its name from the the fact that it allows to extend classes of\nthe language without using inheritance. There are different possibilities\nto achieve this task. One simple example of such an extended class \nis java.lang.String, which was extended by Xtend to provide \na method \"toFirstUpper\".\n\n\nA simple possibility to achieve such an extension is to define a locally\nvisible method \"\nf(\nTypeX x, \n...)\n\" (see \nXtend documentation\n).\nWith this, TypeX is extened by a method \nf(...)\n.\n\n\ndef\n \nprintNTimes\n(\nString\n \ns\n,\n \nint\n \nn\n)\n \n{\n\n    \nfor\n(\nvar\n \ni\n=\n0\n;\ni\n<\nn\n;\ni\n++)\n \nprintln\n(\ns\n)\n\n\n}\n\n\n\n...\n     \n    \n\"Hello\"\n.\nprintNTimes\n(\n3\n)\n\n\n...\n\n\n\n\n\n\nOther possibilities (see \nXtend documentation\n) \nallow to use static methods in a similar way (\"extension imports\") which can\nbe imported by other modules: \n\"import static extension package.Type.printNTimes\".\n\n\nDispatch methods\n\n\nA method (used as extension of not) can be marked with the keyword \n\"\ndispatch\n\". If such a method is defined multiple times with different \nspecialized types as argument, the correct version of the method if called\ndepending what object is passed (runtime polymorphy). The code behaves if\nan \"if obj instanceof TYPE\" is called to determine which version has to be called.\n\n\nMisc\n\n\n\n\n\u201e==\u201c vs. \u201e===\u201c (analog \u201e!=\u201c vs. \u201e!==\u201c):\n\n\n\u201e==\u201c uses the method \"equals\" to determine the result.\n\n\n\u201e===\u201c checks if the identical object is referenced (like a pointer comparison).\n\n\n\n\n\n\nIt is posisble to check if an optional modell element is present or not\n    by comparing it to null.\n\n\nIt is possible to check if a model element is not yet loaded\n    (eIsProxy==true).\n\n\n\n\nEMF Parent Relationship (model mavigation)\n\n\nSometimes (while generating code or validating the model)\nit is useful to navigate to the parent of a model object.\nThis can be done with the attribute \"eContainer\" of every model\nelement. It may be necessary to cast this parent to an appropriate type\n(this can also happen via a dispatch method).",
            "title": "Xtend: Selected Aspects"
        },
        {
            "location": "/xtext_xtend/#xtend-selected-aspects",
            "text": "In addition to the features sketched in the \"code generation with Xtend\" section \nthis section provides some selected aspects we found useful for our work.",
            "title": "Xtend: Selected Aspects"
        },
        {
            "location": "/xtext_xtend/#extension-mechanism",
            "text": "Xtend has its name from the the fact that it allows to extend classes of\nthe language without using inheritance. There are different possibilities\nto achieve this task. One simple example of such an extended class \nis java.lang.String, which was extended by Xtend to provide \na method \"toFirstUpper\".  A simple possibility to achieve such an extension is to define a locally\nvisible method \" f( TypeX x,  ...) \" (see  Xtend documentation ).\nWith this, TypeX is extened by a method  f(...) .  def   printNTimes ( String   s ,   int   n )   { \n     for ( var   i = 0 ; i < n ; i ++)   println ( s )  }  ...      \n     \"Hello\" . printNTimes ( 3 )  ...   Other possibilities (see  Xtend documentation ) \nallow to use static methods in a similar way (\"extension imports\") which can\nbe imported by other modules: \n\"import static extension package.Type.printNTimes\".",
            "title": "Extension mechanism"
        },
        {
            "location": "/xtext_xtend/#dispatch-methods",
            "text": "A method (used as extension of not) can be marked with the keyword \n\" dispatch \". If such a method is defined multiple times with different \nspecialized types as argument, the correct version of the method if called\ndepending what object is passed (runtime polymorphy). The code behaves if\nan \"if obj instanceof TYPE\" is called to determine which version has to be called.",
            "title": "Dispatch methods"
        },
        {
            "location": "/xtext_xtend/#misc",
            "text": "\u201e==\u201c vs. \u201e===\u201c (analog \u201e!=\u201c vs. \u201e!==\u201c):  \u201e==\u201c uses the method \"equals\" to determine the result.  \u201e===\u201c checks if the identical object is referenced (like a pointer comparison).    It is posisble to check if an optional modell element is present or not\n    by comparing it to null.  It is possible to check if a model element is not yet loaded\n    (eIsProxy==true).",
            "title": "Misc"
        },
        {
            "location": "/xtext_xtend/#emf-parent-relationship-model-mavigation",
            "text": "Sometimes (while generating code or validating the model)\nit is useful to navigate to the parent of a model object.\nThis can be done with the attribute \"eContainer\" of every model\nelement. It may be necessary to cast this parent to an appropriate type\n(this can also happen via a dispatch method).",
            "title": "EMF Parent Relationship (model mavigation)"
        },
        {
            "location": "/xtext_deploy_command_line/",
            "text": "Xtext: deploy a command line version of the code generator\n\n\nGenerate a command line version of the code generator\n\n\nAdd the following entries to your mwe2 file (located side-by-side to your \ngrammar; see e.g. \n(Bettini, 2016)\n):\n\n\n...\nlanguage = StandardLanguage {\n    ...\n    generator = {\n        generateJavaMain = true\n    }\n    ...\n}\n...\n\n\n\n\n\nWhen running the mwe2 script (compiling your grammar; \nsee \nCompile and Run the Project\n), a Main.java\nfile is created in the generator namespace side-by-side to your grammar.\n\n\nModify Main.java\n\n\nThe Main-class expects a model file to be processed: parsed, validated and\ngenerated code from the model.\n\n\n\n\nYou can manually set the destination path (\nchange \"src-gen\"\n to something \n    else).\n\n\nThere is no workspace for the model files; you must modify the Main.java \n    file in order to manually \nadd other model files\n (e.g. from some sub folder or \n    specified via the command line). \n    E.g.:\nprotected\n \nvoid\n \nrunGenerator\n(\nString\n \nmain_model_filename\n,\n \nString\n[]\n \nall_other_filenames\n)\n \n{\n\n    \n// Load the resource\n\n    \nResourceSet\n \nset\n \n=\n \nresourceSetProvider\n.\nget\n();\n\n    \nResource\n \nresource\n \n=\n \nset\n.\ngetResource\n(\nURI\n.\ncreateFileURI\n(\nmain_model_filename\n),\n \ntrue\n);\n\n    \nList\n<\nResource\n>\n \nall_resources\n \n=\n \nnew\n \nArrayList\n<\nResource\n>();\n\n    \nall_resources\n.\nadd\n(\nresource\n);\n\n\n    \n// Load all other requried resources\n\n    \nfor\n(\nString\n \nm\n:\nall_other_filenames\n)\n \n{\n\n        \nif\n \n(!\nm\n.\nequals\n(\nmain_model_filename\n))\n \n{\n\n            \nResource\n \nother\n \n=\n \nset\n.\ngetResource\n(\nURI\n.\ncreateFileURI\n(\nm\n),\n \ntrue\n);\n\n            \nall_resources\n.\nadd\n(\nother\n);\n\n        \n}\n\n    \n}\n\n\n    \n// Validate all resources\n\n    \nfor\n \n(\nResource\n \nr\n:\n \nall_resources\n)\n \n{\n\n        \nList\n<\nIssue\n>\n \nlist\n \n=\n \nvalidator\n.\nvalidate\n(\nr\n,\n \nCheckMode\n.\nALL\n,\n \nCancelIndicator\n.\nNullImpl\n);\n\n        \nif\n \n(!\nlist\n.\nisEmpty\n())\n \n{\n\n            \nfor\n \n(\nIssue\n \nissue\n \n:\n \nlist\n)\n \n{\n\n                \nSystem\n.\nerr\n.\nprintln\n(\nissue\n);\n\n            \n}\n\n            \nreturn\n;\n\n        \n}\n\n    \n}\n\n\n    \n// Configure and start the generator\n\n    \nfileAccess\n.\nsetOutputPath\n(\n\"src-gen/\"\n);\n\n    \nGeneratorContext\n \ncontext\n \n=\n \nnew\n \nGeneratorContext\n();\n\n    \ncontext\n.\nsetCancelIndicator\n(\nCancelIndicator\n.\nNullImpl\n);\n\n    \ngenerator\n.\ngenerate\n(\nresource\n,\n \nfileAccess\n,\n \ncontext\n);\n\n\n    \nSystem\n.\nout\n.\nprintln\n(\n\"Code generation finished.\"\n);\n\n\n}\n\n\n\n\n\n\n\n\n\n\nManually create a runnable JAR file with the command line compiler\n\n\nIn eclipse you can \"\nExport\n\" your generator as \"\nRunnable JAR\n\":\n\n\n\n\nCreate a Run Configuration by right-clicking on your Main.java and select \n    \"Run as\" / \"Java Application\".\n\n\nThen right-click on the project containing the Main.java file and select \n    \"Export\", \"Runnable JAR file\".\n\n\nSelect \"Main\" in the \"Launch configurazion\".\n\n\nSelect \"Package requried libraries into generated JAR file\".\n\n\nSpecify your destination JAR file name and click \"Finish\".\n\n\n\n\nCreate the command line compiler with maven\n\n\n\n\nClose eclipse \n\n\nClone \nhttps://github.com/basilfx/xtext-standalone-maven-build\n\n   (There is a good description there what to do)\n\n\nCopy the ...standalone-folder into your ...parent folder (side-by-side \n    to your other projects)\n\n\nRename the folder to match your project name (e.g. \n    \"org.xtext.example.mydsl.standalone\" to \n    \"org.example.domainmodel.standalone\")\n\n\nRename (find/replace) the project name (replace \"org.xtext.example.mydsl\"\n    with \"org.example.domainmodel\") in all files in the copied folder.\n\n\nAdd the new folder/module to the modules list in your master pom.xml file\n    (section \"modules\").\n\n\ntry \"mvn package\" in your master directory and check if the target in\n    the new standalone module is created. The generated JAR file can then be \n    tested as follows (assuming some model files are available):\njava -jar org.example.domainmodel.standalone/target/org.example.domainmodel.standalone-1.0.0-SNAPSHOT.jar *.dmodel\n\n\n\n\n\n\n\n\n\nNote: \n * no need to add (import) the standalone project into the ecplise \n    workspace.\n * You can use the standalone code generator as \"compiler\" in a Makefile\n    (like gcc). It will perform a model syntax check, a model validation and a \n    code generation.",
            "title": "Deploy a command line version"
        },
        {
            "location": "/xtext_deploy_command_line/#xtext-deploy-a-command-line-version-of-the-code-generator",
            "text": "",
            "title": "Xtext: deploy a command line version of the code generator"
        },
        {
            "location": "/xtext_deploy_command_line/#generate-a-command-line-version-of-the-code-generator",
            "text": "Add the following entries to your mwe2 file (located side-by-side to your \ngrammar; see e.g.  (Bettini, 2016) ):  ...\nlanguage = StandardLanguage {\n    ...\n    generator = {\n        generateJavaMain = true\n    }\n    ...\n}\n...  When running the mwe2 script (compiling your grammar; \nsee  Compile and Run the Project ), a Main.java\nfile is created in the generator namespace side-by-side to your grammar.",
            "title": "Generate a command line version of the code generator"
        },
        {
            "location": "/xtext_deploy_command_line/#modify-mainjava",
            "text": "The Main-class expects a model file to be processed: parsed, validated and\ngenerated code from the model.   You can manually set the destination path ( change \"src-gen\"  to something \n    else).  There is no workspace for the model files; you must modify the Main.java \n    file in order to manually  add other model files  (e.g. from some sub folder or \n    specified via the command line). \n    E.g.: protected   void   runGenerator ( String   main_model_filename ,   String []   all_other_filenames )   { \n     // Load the resource \n     ResourceSet   set   =   resourceSetProvider . get (); \n     Resource   resource   =   set . getResource ( URI . createFileURI ( main_model_filename ),   true ); \n     List < Resource >   all_resources   =   new   ArrayList < Resource >(); \n     all_resources . add ( resource ); \n\n     // Load all other requried resources \n     for ( String   m : all_other_filenames )   { \n         if   (! m . equals ( main_model_filename ))   { \n             Resource   other   =   set . getResource ( URI . createFileURI ( m ),   true ); \n             all_resources . add ( other ); \n         } \n     } \n\n     // Validate all resources \n     for   ( Resource   r :   all_resources )   { \n         List < Issue >   list   =   validator . validate ( r ,   CheckMode . ALL ,   CancelIndicator . NullImpl ); \n         if   (! list . isEmpty ())   { \n             for   ( Issue   issue   :   list )   { \n                 System . err . println ( issue ); \n             } \n             return ; \n         } \n     } \n\n     // Configure and start the generator \n     fileAccess . setOutputPath ( \"src-gen/\" ); \n     GeneratorContext   context   =   new   GeneratorContext (); \n     context . setCancelIndicator ( CancelIndicator . NullImpl ); \n     generator . generate ( resource ,   fileAccess ,   context ); \n\n     System . out . println ( \"Code generation finished.\" );  }",
            "title": "Modify Main.java"
        },
        {
            "location": "/xtext_deploy_command_line/#manually-create-a-runnable-jar-file-with-the-command-line-compiler",
            "text": "In eclipse you can \" Export \" your generator as \" Runnable JAR \":   Create a Run Configuration by right-clicking on your Main.java and select \n    \"Run as\" / \"Java Application\".  Then right-click on the project containing the Main.java file and select \n    \"Export\", \"Runnable JAR file\".  Select \"Main\" in the \"Launch configurazion\".  Select \"Package requried libraries into generated JAR file\".  Specify your destination JAR file name and click \"Finish\".",
            "title": "Manually create a runnable JAR file with the command line compiler"
        },
        {
            "location": "/xtext_deploy_command_line/#create-the-command-line-compiler-with-maven",
            "text": "Close eclipse   Clone  https://github.com/basilfx/xtext-standalone-maven-build \n   (There is a good description there what to do)  Copy the ...standalone-folder into your ...parent folder (side-by-side \n    to your other projects)  Rename the folder to match your project name (e.g. \n    \"org.xtext.example.mydsl.standalone\" to \n    \"org.example.domainmodel.standalone\")  Rename (find/replace) the project name (replace \"org.xtext.example.mydsl\"\n    with \"org.example.domainmodel\") in all files in the copied folder.  Add the new folder/module to the modules list in your master pom.xml file\n    (section \"modules\").  try \"mvn package\" in your master directory and check if the target in\n    the new standalone module is created. The generated JAR file can then be \n    tested as follows (assuming some model files are available): java -jar org.example.domainmodel.standalone/target/org.example.domainmodel.standalone-1.0.0-SNAPSHOT.jar *.dmodel    Note: \n * no need to add (import) the standalone project into the ecplise \n    workspace.\n * You can use the standalone code generator as \"compiler\" in a Makefile\n    (like gcc). It will perform a model syntax check, a model validation and a \n    code generation.",
            "title": "Create the command line compiler with maven"
        },
        {
            "location": "/textx_intro/",
            "text": "TextX Intro\n\n\nTextX is a Python library to allow an easy creation of\nDSL validators and artifact generators:\n\n\n\n\nReading model files (grammar based parsing, reference resolution and post processing).\n\n\nValidating the model.\n\n\nGenerating output artifacts (e.g., code).\n\n\n\n\nA fundamental difference to Xtext is that the\nmeta model classes (describing the model elements)\nare dynamically generated instead of generating code\nfrom them. Thus, a grammar in TextX in interpreted dynamically \nand not compiled.\n\n\nTextX has only few dependencies and very compact \nprojects can be created. Details see\n\n(Dejanovi\u0107 et al. 2017)\n\nand the \"TextX project page\", see \n(TextX)\n.\n\n\nNormally, a similar modularization as for Xtext projects \nis employed to separate different responsibilities across\nsoftware modules (e.g. modules for the \ngrammar, validation, and code generation). \nHowever, it is possible to put an entire project\nincluding grammar and the validation into one file:\nthe following code illustrates a meta model with an example model\nwhich is validated (similar to the example in the \n\nintroductory example of validation\n).\n\n\n\n\nfrom\n \ntextx\n \nimport\n \nmetamodel_from_str\n\n\nfrom\n \ntextx.scoping.providers\n \nimport\n \nRelativeName\n,\n \nFQN\n\n\nfrom\n \ntextx.export\n \nimport\n \nmodel_export\n\n\n# ------------------------------------\n\n\n# GRAMMAR\n\n\n#\n\n\nmeta_model\n \n=\n \nmetamodel_from_str\n(\n'''\n\n\n    Model: aspects+=Aspect scenarios+=Scenario testcases+=Testcase;\n\n\n    Scenario: 'SCENARIO' name=ID 'BEGIN' \n\n\n        configs+=Config\n\n\n    'END';\n\n\n    Config: 'CONFIG' name=ID 'HAS' '(' haves*=[Aspect] ')';\n\n\n    Aspect: 'ASPECT' name=ID;\n\n\n    Testcase: 'TESTCASE' name=ID 'BEGIN'\n\n\n        'USES' scenario=[Scenario] 'WITH' config=[Config]\n\n\n        'NEEDS' '(' needs*=[Aspect] ')'\n\n\n    'END';\n\n\n    Comment: /\\/\\/.*/;\n\n\n'''\n)\n\n\n\n# ------------------------------------\n\n\n# SCOPING\n\n\n#\n\n\nmeta_model\n.\nregister_scope_providers\n({\n\n    \n'*.*'\n:\n \nFQN\n(),\n\n    \n'Testcase.config'\n:\n \nRelativeName\n(\n'scenario.configs'\n)\n\n\n})\n\n\n\n# ------------------------------------\n\n\n# VALIDATION\n\n\n#\n\n\ndef\n \ncheck_testcase\n(\ntestcase\n):\n\n    \n\"\"\"\n\n\n    checks that the config used by the testcase fulfills its needs\n\n\n    \"\"\"\n\n    \nfor\n \nneed\n \nin\n \ntestcase\n.\nneeds\n:\n\n        \nif\n \nneed\n \nnot\n \nin\n \ntestcase\n.\nconfig\n.\nhaves\n:\n\n            \nraise\n \nException\n(\n\"{}: {} not found in {}.{}\"\n.\nformat\n(\n\n                    \ntestcase\n.\nname\n,\n\n                    \nneed\n.\nname\n,\n \n                    \ntestcase\n.\nscenario\n.\nname\n,\n\n                    \ntestcase\n.\nconfig\n.\nname\n\n                    \n))\n\n\n\nmeta_model\n.\nregister_obj_processors\n({\n\n        \n'Testcase'\n:\n \ncheck_testcase\n\n\n})\n\n\n\n# ------------------------------------\n\n\n# EXAMPLE\n\n\n#\n\n\nmodel\n \n=\n \nmeta_model\n.\nmodel_from_str\n(\n'''\n\n\n    ASPECT NetworkTraffic\n\n\n    ASPECT FileAccess\n\n\n    SCENARIO S001 BEGIN\n\n\n        CONFIG HeavyNetworkTraffic HAS (NetworkTraffic)\n\n\n        CONFIG NoNetworkTraffic HAS ()\n\n\n    END\n\n\n    SCENARIO S002 BEGIN\n\n\n        CONFIG WithFileAccess HAS (NetworkTraffic FileAccess)\n\n\n        CONFIG NoFileAccess HAS (NetworkTraffic)\n\n\n    END\n\n\n    TESTCASE T001 BEGIN\n\n\n        USES S001 WITH HeavyNetworkTraffic\n\n\n        NEEDS (NetworkTraffic)\n\n\n    END\n\n\n    TESTCASE T002 BEGIN\n\n\n        //USES S001 WITH NoNetworkTraffic // Error\n\n\n        USES S002 WITH NoFileAccess\n\n\n        NEEDS (NetworkTraffic)\n\n\n    END\n\n\n'''\n)\n\n\n\nmodel_export\n(\nmodel\n,\n \n'model.dot'\n)",
            "title": "TextX Intro"
        },
        {
            "location": "/textx_intro/#textx-intro",
            "text": "TextX is a Python library to allow an easy creation of\nDSL validators and artifact generators:   Reading model files (grammar based parsing, reference resolution and post processing).  Validating the model.  Generating output artifacts (e.g., code).   A fundamental difference to Xtext is that the\nmeta model classes (describing the model elements)\nare dynamically generated instead of generating code\nfrom them. Thus, a grammar in TextX in interpreted dynamically \nand not compiled.  TextX has only few dependencies and very compact \nprojects can be created. Details see (Dejanovi\u0107 et al. 2017) \nand the \"TextX project page\", see  (TextX) .  Normally, a similar modularization as for Xtext projects \nis employed to separate different responsibilities across\nsoftware modules (e.g. modules for the \ngrammar, validation, and code generation). \nHowever, it is possible to put an entire project\nincluding grammar and the validation into one file:\nthe following code illustrates a meta model with an example model\nwhich is validated (similar to the example in the  introductory example of validation ).   from   textx   import   metamodel_from_str  from   textx.scoping.providers   import   RelativeName ,   FQN  from   textx.export   import   model_export  # ------------------------------------  # GRAMMAR  #  meta_model   =   metamodel_from_str ( '''      Model: aspects+=Aspect scenarios+=Scenario testcases+=Testcase;      Scenario: 'SCENARIO' name=ID 'BEGIN'           configs+=Config      'END';      Config: 'CONFIG' name=ID 'HAS' '(' haves*=[Aspect] ')';      Aspect: 'ASPECT' name=ID;      Testcase: 'TESTCASE' name=ID 'BEGIN'          'USES' scenario=[Scenario] 'WITH' config=[Config]          'NEEDS' '(' needs*=[Aspect] ')'      'END';      Comment: /\\/\\/.*/;  ''' )  # ------------------------------------  # SCOPING  #  meta_model . register_scope_providers ({ \n     '*.*' :   FQN (), \n     'Testcase.config' :   RelativeName ( 'scenario.configs' )  })  # ------------------------------------  # VALIDATION  #  def   check_testcase ( testcase ): \n     \"\"\"      checks that the config used by the testcase fulfills its needs      \"\"\" \n     for   need   in   testcase . needs : \n         if   need   not   in   testcase . config . haves : \n             raise   Exception ( \"{}: {} not found in {}.{}\" . format ( \n                     testcase . name , \n                     need . name ,  \n                     testcase . scenario . name , \n                     testcase . config . name \n                     ))  meta_model . register_obj_processors ({ \n         'Testcase' :   check_testcase  })  # ------------------------------------  # EXAMPLE  #  model   =   meta_model . model_from_str ( '''      ASPECT NetworkTraffic      ASPECT FileAccess      SCENARIO S001 BEGIN          CONFIG HeavyNetworkTraffic HAS (NetworkTraffic)          CONFIG NoNetworkTraffic HAS ()      END      SCENARIO S002 BEGIN          CONFIG WithFileAccess HAS (NetworkTraffic FileAccess)          CONFIG NoFileAccess HAS (NetworkTraffic)      END      TESTCASE T001 BEGIN          USES S001 WITH HeavyNetworkTraffic          NEEDS (NetworkTraffic)      END      TESTCASE T002 BEGIN          //USES S001 WITH NoNetworkTraffic // Error          USES S002 WITH NoFileAccess          NEEDS (NetworkTraffic)      END  ''' )  model_export ( model ,   'model.dot' )",
            "title": "TextX Intro"
        },
        {
            "location": "/textx_project_setup/",
            "text": "TextX Project Setup\n\n\nWe give a guide to create a simple\ncommand line tool to load and validate a\nmodel and to generate some artifact.\n\n\nIn this example, we propose different models for\nthe \nmeta model structure\n (grammar), the \nscoping\n,\nand the \n artifact generation\n. Moreover, a \n\nmain\n and a \nsetup\n script are added to control\nthe software.\n\n\nFor this example we use Python 3. You need to install \n\n\n\n\nTextX (see \nreferences\n).\n\n\nArpeggio (see TextX in \nreferences\n)\n\n\npytest (for unittests)\n\n\n\n\nUsing pip you can:\n\n\npip3 install --upgrade textx arpeggio pytest\n\n\n\n\n\nFile structure\n\n\nAlthough everything can be packed within one file\n(see \n\"TextX Intro\"\n), the code\nis better structured into different modules \nwith individual responsibilities into different files.\n\n\n\u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 simple_dsl\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 codegen.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 console\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 validate.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 metamodel.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 validation.py\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 models\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 model_not_ok.dsl\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 model_ok.dsl\n    \u2514\u2500\u2500 test_validation.py\n\n\n\n\n\nWe have chosen a distribution as follows:\n\n\n\n\nsetup.py is the standard python project configuration\n\n\nsimple_dsl contain all dsl related logic:\n\n\ncodegen.py: code generation.\n\n\nmetamodel.py: the meta model (grammar, scoping and validation config;\n  the user classes are also stored herem but could be moved\n  elsewhere for more complex projects.   \n\n\nvalidation.py: validation logic.\n\n\nconsole/*.py: console programs (configured in setup.py).\n\n\n__init__.py represent module entry points.\n\n\n\n\n\n\ntests contains unittests.\n\n\n\n\nFile: \n metamodel.py\n\n\nHere, we define the grammar. We allocate the scope providers to\nindividual elements, and register validation code.\n\n\nfrom\n \ntextx\n \nimport\n \nmetamodel_from_str\n\n\nfrom\n \ntextx.scoping.providers\n \nimport\n \nRelativeName\n,\n \nFQN\n\n\nimport\n \nsimple_dsl.validation\n \nas\n \nvalidation\n\n\n\ndef\n \nget_metamodel\n():\n\n    \n# GRAMMAR\n\n    \n# (you also use metamodel_from_file with a *.tx file)\n\n    \nmeta_model\n \n=\n \nmetamodel_from_str\n(\n'''\n\n\n        Model: aspects+=Aspect scenarios+=Scenario testcases+=Testcase;\n\n\n        Scenario: 'SCENARIO' name=ID 'BEGIN' \n\n\n            configs+=Config\n\n\n        'END';\n\n\n        Config: 'CONFIG' name=ID 'HAS' '(' haves*=[Aspect] ')';\n\n\n        Aspect: 'ASPECT' name=ID;\n\n\n        Testcase: 'TESTCASE' name=ID 'BEGIN'\n\n\n            'USES' scenario=[Scenario] 'WITH' config=[Config]\n\n\n            'NEEDS' '(' needs*=[Aspect] ')'\n\n\n        'END';\n\n\n        Comment: /\\/\\/.*/;\n\n\n    '''\n)\n\n\n    \n# SCOPING\n\n    \nmeta_model\n.\nregister_scope_providers\n({\n\n        \n'*.*'\n:\n \nFQN\n(),\n\n        \n'Testcase.config'\n:\n \nRelativeName\n(\n'scenario.configs'\n)\n\n    \n})\n\n\n    \n# ADD VALIDATION\n\n    \nmeta_model\n.\nregister_obj_processors\n({\n\n            \n'Testcase'\n:\n \nvalidation\n.\ncheck_testcase\n\n    \n})\n\n\n    \nreturn\n \nmeta_model\n\n\n\n\n\n\nFile: \n validation.py\n\n\nThis file contains validation functions registered in the meta model.\n\n\nfrom\n \ntextx.exceptions\n \nimport\n \nTextXError\n\n\nfrom\n \ntextx.scoping.tools\n \nimport\n \nget_location\n\n\n\ndef\n \ncheck_testcase\n(\ntestcase\n):\n\n    \n\"\"\"\n\n\n    checks that the config used by the testcase fulfills its needs\n\n\n    \"\"\"\n\n    \nfor\n \nneed\n \nin\n \ntestcase\n.\nneeds\n:\n\n        \nif\n \nneed\n \nnot\n \nin\n \ntestcase\n.\nconfig\n.\nhaves\n:\n\n            \nraise\n \n(\nTextXError\n(\n\"{}: {} not found in {}.{}\"\n.\nformat\n(\n\n                    \ntestcase\n.\nname\n,\n\n                    \nneed\n.\nname\n,\n \n                    \ntestcase\n.\nscenario\n.\nname\n,\n\n                    \ntestcase\n.\nconfig\n.\nname\n\n                    \n),\n\n                \n**\nget_location\n(\ntestcase\n)\n \n# unpack location info\n\n            \n))\n\n\n\n\n\n\nFile: tests/test_validation.py\n\n\nThis file is a unittest using the metamodel \n(exposed via __init__.py) and checks the\ncorrect functionality of the validation code.\n\n\nfrom\n \npytest\n \nimport\n \nraises\n\n\nfrom\n \nsimple_dsl\n \nimport\n \nget_metamodel\n\n\nfrom\n \nos.path\n \nimport\n \ndirname\n,\n \njoin\n\n\nfrom\n \ntextx\n \nimport\n \nget_children_of_type\n\n\n\ndef\n \ntest_validation_ok\n():\n\n    \nmm\n \n=\n \nget_metamodel\n()\n\n    \nm\n \n=\n \nmm\n.\nmodel_from_file\n(\njoin\n(\ndirname\n(\n__file__\n),\n\n                            \n'models'\n,\n\n                            \n'model_ok.dsl'\n))\n\n    \nassert\n \n2\n==\nlen\n(\nget_children_of_type\n(\n'Aspect'\n,\nm\n))\n\n\n\ndef\n \ntest_validation_not_ok\n():\n\n    \nmm\n \n=\n \nget_metamodel\n()\n\n    \nwith\n \nraises\n(\nException\n,\n\n                \nmatch\n=\nr\n'NetworkTraffic.*not found.*S001.*NoNetworkTraffic'\n):\n\n        \n_\n \n=\n \nmm\n.\nmodel_from_file\n(\njoin\n(\ndirname\n(\n__file__\n),\n\n                                \n'models'\n,\n\n                                \n'model_not_ok.dsl'\n))\n\n\n\n\n\n\nThe two model files used in this tests are shown in the following \nsubsections.\n\n\nModel: tests/models/model_ok.dsl\n\n\nASPECT\n \nNetworkTraffic\n\n\nASPECT\n \nFileAccess\n\n\nSCENARIO\n \nS001\n \nBEGIN\n\n    \nCONFIG\n \nHeavyNetworkTraffic\n \nHAS\n \n(\nNetworkTraffic\n)\n\n    \nCONFIG\n \nNoNetworkTraffic\n \nHAS\n \n()\n\n\nEND\n\n\nSCENARIO\n \nS002\n \nBEGIN\n\n    \nCONFIG\n \nWithFileAccess\n \nHAS\n \n(\nNetworkTraffic\n \nFileAccess\n)\n\n    \nCONFIG\n \nNoFileAccess\n \nHAS\n \n(\nNetworkTraffic\n)\n\n\nEND\n\n\nTESTCASE\n \nT001\n \nBEGIN\n\n    \nUSES\n \nS001\n \nWITH\n \nHeavyNetworkTraffic\n\n    \nNEEDS\n \n(\nNetworkTraffic\n)\n\n\nEND\n\n\nTESTCASE\n \nT002\n \nBEGIN\n\n    \nUSES\n \nS001\n \nWITH\n \nNoNetworkTraffic\n \n// Error\n\n    \n//USES S002 WITH NoFileAccess\n\n    \nNEEDS\n \n(\nNetworkTraffic\n)\n\n\nEND\n\n\n\n\n\n\nModel: tests/models/model_not_ok.dsl\n\n\nASPECT\n \nNetworkTraffic\n\n\nASPECT\n \nFileAccess\n\n\nSCENARIO\n \nS001\n \nBEGIN\n\n    \nCONFIG\n \nHeavyNetworkTraffic\n \nHAS\n \n(\nNetworkTraffic\n)\n\n    \nCONFIG\n \nNoNetworkTraffic\n \nHAS\n \n()\n\n\nEND\n\n\nSCENARIO\n \nS002\n \nBEGIN\n\n    \nCONFIG\n \nWithFileAccess\n \nHAS\n \n(\nNetworkTraffic\n \nFileAccess\n)\n\n    \nCONFIG\n \nNoFileAccess\n \nHAS\n \n(\nNetworkTraffic\n)\n\n\nEND\n\n\nTESTCASE\n \nT001\n \nBEGIN\n\n    \nUSES\n \nS001\n \nWITH\n \nHeavyNetworkTraffic\n\n    \nNEEDS\n \n(\nNetworkTraffic\n)\n\n\nEND\n\n\nTESTCASE\n \nT002\n \nBEGIN\n\n    \n//USES S001 WITH NoNetworkTraffic // Error\n\n    \nUSES\n \nS002\n \nWITH\n \nNoFileAccess\n\n    \nNEEDS\n \n(\nNetworkTraffic\n)\n\n\nEND\n\n\n\n\n\n\nEdit, Run and Test\n\n\nUse an appropriate IDE (e.g., PyCharm) to run the tests and, thus, test and debug your \nnew language.\n\n\nInstall/Uninstall the Language\n\n\nAfter all tests passed you can try to install your language.\nDo not forget to adapt setup.py:\n\n\nfrom\n \nsetuptools\n \nimport\n \nsetup\n,\nfind_packages\n\n\n\nsetup\n(\nname\n=\n'simple_dsl'\n,\n\n      \nversion\n=\n'0.1'\n,\n\n      \ndescription\n=\n'a simple model validator and artifact compiler'\n,\n\n      \nurl\n=\n''\n,\n\n      \nauthor\n=\n'YOUR NAME'\n,\n\n      \nauthor_email\n=\n'YOUR.NAME@ADDRESS'\n,\n\n      \nlicense\n=\n'TODO'\n,\n\n      \npackages\n=\nfind_packages\n(),\n\n      \npackage_data\n=\n{\n''\n:\n \n[\n'*.tx'\n,\n \n'*.template'\n,\n \n'support_*_code/**/*'\n]},\n\n      \ninstall_requires\n=\n[\n\"textx\"\n,\n\"arpeggio\"\n],\n\n      \ntests_require\n=\n[\n\n          \n'pytest'\n,\n\n      \n],\n\n      \nkeywords\n=\n\"parser meta-language meta-model language DSL\"\n,\n\n      \nentry_points\n=\n{\n\n          \n'console_scripts'\n:\n \n[\n\n              \n'simple_dsl_validate=simple_dsl.console.validate:validate'\n,\n\n          \n]\n\n      \n},\n\n      \n)\n\n\n\n\n# to play around without installing: do \"export PYTHONPATH=.\"\n\n\n\n\n\n\nThe registered console command (validate.py) contains:\n\n\nimport\n \nargparse\n\n\nfrom\n \nsimple_dsl\n \nimport\n \nget_metamodel\n\n\n\ndef\n \nvalidate\n():\n\n    \nmm\n \n=\n \nget_metamodel\n()\n\n    \nparser\n \n=\n \nargparse\n.\nArgumentParser\n(\ndescription\n=\n'validate simple_dsl files.'\n)\n\n    \nparser\n.\nadd_argument\n(\n'model_files'\n,\n \nmetavar\n=\n'model_files'\n,\n \ntype\n=\nstr\n,\n\n                        \nnargs\n=\n'+'\n,\n\n                        \nhelp\n=\n'model filenames'\n)\n\n    \nargs\n \n=\n \nparser\n.\nparse_args\n()\n\n\n    \nfor\n \nfilename\n \nin\n \nargs\n.\nmodel_files\n:\n\n        \ntry\n:\n\n            \nprint\n(\n'validating {}'\n.\nformat\n(\nfilename\n))\n\n            \n_\n \n=\n \nmm\n.\nmodel_from_file\n(\nfilename\n)\n\n        \nexcept\n \nBaseException\n \nas\n \ne\n:\n\n            \nprint\n(\n'  WARNING/ERROR: {}'\n.\nformat\n(\ne\n))\n\n\n\n\nif\n \n__name__\n==\n'__main__'\n:\n\n    \nvalidate\n()\n\n\n\n\n\n\nInstallation\n\n\nInstall\n the software \npermanently for all users\n (change directory\nto the folder with the setup.py file):\n\n\nsudo -H pip3 install --upgrade .\n\n\n\n\n\nYou can now start the new commands defined in the setup.py: \n\n\nsimple_dsl_validate --help\n\n\n\n\n\nUninstallation\n\n\nUninstall\n the software:\n\n\nsudo -H pip3 uninstall simple_dsl",
            "title": "TextX Project Setup"
        },
        {
            "location": "/textx_project_setup/#textx-project-setup",
            "text": "We give a guide to create a simple\ncommand line tool to load and validate a\nmodel and to generate some artifact.  In this example, we propose different models for\nthe  meta model structure  (grammar), the  scoping ,\nand the   artifact generation . Moreover, a  main  and a  setup  script are added to control\nthe software.  For this example we use Python 3. You need to install    TextX (see  references ).  Arpeggio (see TextX in  references )  pytest (for unittests)   Using pip you can:  pip3 install --upgrade textx arpeggio pytest",
            "title": "TextX Project Setup"
        },
        {
            "location": "/textx_project_setup/#file-structure",
            "text": "Although everything can be packed within one file\n(see  \"TextX Intro\" ), the code\nis better structured into different modules \nwith individual responsibilities into different files.  \u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 simple_dsl\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 codegen.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 console\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 validate.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 metamodel.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 validation.py\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 models\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 model_not_ok.dsl\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 model_ok.dsl\n    \u2514\u2500\u2500 test_validation.py  We have chosen a distribution as follows:   setup.py is the standard python project configuration  simple_dsl contain all dsl related logic:  codegen.py: code generation.  metamodel.py: the meta model (grammar, scoping and validation config;\n  the user classes are also stored herem but could be moved\n  elsewhere for more complex projects.     validation.py: validation logic.  console/*.py: console programs (configured in setup.py).  __init__.py represent module entry points.    tests contains unittests.",
            "title": "File structure"
        },
        {
            "location": "/textx_project_setup/#file-metamodelpy",
            "text": "Here, we define the grammar. We allocate the scope providers to\nindividual elements, and register validation code.  from   textx   import   metamodel_from_str  from   textx.scoping.providers   import   RelativeName ,   FQN  import   simple_dsl.validation   as   validation  def   get_metamodel (): \n     # GRAMMAR \n     # (you also use metamodel_from_file with a *.tx file) \n     meta_model   =   metamodel_from_str ( '''          Model: aspects+=Aspect scenarios+=Scenario testcases+=Testcase;          Scenario: 'SCENARIO' name=ID 'BEGIN'               configs+=Config          'END';          Config: 'CONFIG' name=ID 'HAS' '(' haves*=[Aspect] ')';          Aspect: 'ASPECT' name=ID;          Testcase: 'TESTCASE' name=ID 'BEGIN'              'USES' scenario=[Scenario] 'WITH' config=[Config]              'NEEDS' '(' needs*=[Aspect] ')'          'END';          Comment: /\\/\\/.*/;      ''' ) \n\n     # SCOPING \n     meta_model . register_scope_providers ({ \n         '*.*' :   FQN (), \n         'Testcase.config' :   RelativeName ( 'scenario.configs' ) \n     }) \n\n     # ADD VALIDATION \n     meta_model . register_obj_processors ({ \n             'Testcase' :   validation . check_testcase \n     }) \n\n     return   meta_model",
            "title": "File: "
        },
        {
            "location": "/textx_project_setup/#file-validationpy",
            "text": "This file contains validation functions registered in the meta model.  from   textx.exceptions   import   TextXError  from   textx.scoping.tools   import   get_location  def   check_testcase ( testcase ): \n     \"\"\"      checks that the config used by the testcase fulfills its needs      \"\"\" \n     for   need   in   testcase . needs : \n         if   need   not   in   testcase . config . haves : \n             raise   ( TextXError ( \"{}: {} not found in {}.{}\" . format ( \n                     testcase . name , \n                     need . name ,  \n                     testcase . scenario . name , \n                     testcase . config . name \n                     ), \n                 ** get_location ( testcase )   # unpack location info \n             ))",
            "title": "File: "
        },
        {
            "location": "/textx_project_setup/#file-teststest_validationpy",
            "text": "This file is a unittest using the metamodel \n(exposed via __init__.py) and checks the\ncorrect functionality of the validation code.  from   pytest   import   raises  from   simple_dsl   import   get_metamodel  from   os.path   import   dirname ,   join  from   textx   import   get_children_of_type  def   test_validation_ok (): \n     mm   =   get_metamodel () \n     m   =   mm . model_from_file ( join ( dirname ( __file__ ), \n                             'models' , \n                             'model_ok.dsl' )) \n     assert   2 == len ( get_children_of_type ( 'Aspect' , m ))  def   test_validation_not_ok (): \n     mm   =   get_metamodel () \n     with   raises ( Exception , \n                 match = r 'NetworkTraffic.*not found.*S001.*NoNetworkTraffic' ): \n         _   =   mm . model_from_file ( join ( dirname ( __file__ ), \n                                 'models' , \n                                 'model_not_ok.dsl' ))   The two model files used in this tests are shown in the following \nsubsections.",
            "title": "File: tests/test_validation.py"
        },
        {
            "location": "/textx_project_setup/#model-testsmodelsmodel_okdsl",
            "text": "ASPECT   NetworkTraffic  ASPECT   FileAccess  SCENARIO   S001   BEGIN \n     CONFIG   HeavyNetworkTraffic   HAS   ( NetworkTraffic ) \n     CONFIG   NoNetworkTraffic   HAS   ()  END  SCENARIO   S002   BEGIN \n     CONFIG   WithFileAccess   HAS   ( NetworkTraffic   FileAccess ) \n     CONFIG   NoFileAccess   HAS   ( NetworkTraffic )  END  TESTCASE   T001   BEGIN \n     USES   S001   WITH   HeavyNetworkTraffic \n     NEEDS   ( NetworkTraffic )  END  TESTCASE   T002   BEGIN \n     USES   S001   WITH   NoNetworkTraffic   // Error \n     //USES S002 WITH NoFileAccess \n     NEEDS   ( NetworkTraffic )  END",
            "title": "Model: tests/models/model_ok.dsl"
        },
        {
            "location": "/textx_project_setup/#model-testsmodelsmodel_not_okdsl",
            "text": "ASPECT   NetworkTraffic  ASPECT   FileAccess  SCENARIO   S001   BEGIN \n     CONFIG   HeavyNetworkTraffic   HAS   ( NetworkTraffic ) \n     CONFIG   NoNetworkTraffic   HAS   ()  END  SCENARIO   S002   BEGIN \n     CONFIG   WithFileAccess   HAS   ( NetworkTraffic   FileAccess ) \n     CONFIG   NoFileAccess   HAS   ( NetworkTraffic )  END  TESTCASE   T001   BEGIN \n     USES   S001   WITH   HeavyNetworkTraffic \n     NEEDS   ( NetworkTraffic )  END  TESTCASE   T002   BEGIN \n     //USES S001 WITH NoNetworkTraffic // Error \n     USES   S002   WITH   NoFileAccess \n     NEEDS   ( NetworkTraffic )  END",
            "title": "Model: tests/models/model_not_ok.dsl"
        },
        {
            "location": "/textx_project_setup/#edit-run-and-test",
            "text": "Use an appropriate IDE (e.g., PyCharm) to run the tests and, thus, test and debug your \nnew language.",
            "title": "Edit, Run and Test"
        },
        {
            "location": "/textx_project_setup/#installuninstall-the-language",
            "text": "After all tests passed you can try to install your language.\nDo not forget to adapt setup.py:  from   setuptools   import   setup , find_packages  setup ( name = 'simple_dsl' , \n       version = '0.1' , \n       description = 'a simple model validator and artifact compiler' , \n       url = '' , \n       author = 'YOUR NAME' , \n       author_email = 'YOUR.NAME@ADDRESS' , \n       license = 'TODO' , \n       packages = find_packages (), \n       package_data = { '' :   [ '*.tx' ,   '*.template' ,   'support_*_code/**/*' ]}, \n       install_requires = [ \"textx\" , \"arpeggio\" ], \n       tests_require = [ \n           'pytest' , \n       ], \n       keywords = \"parser meta-language meta-model language DSL\" , \n       entry_points = { \n           'console_scripts' :   [ \n               'simple_dsl_validate=simple_dsl.console.validate:validate' , \n           ] \n       }, \n       )  # to play around without installing: do \"export PYTHONPATH=.\"   The registered console command (validate.py) contains:  import   argparse  from   simple_dsl   import   get_metamodel  def   validate (): \n     mm   =   get_metamodel () \n     parser   =   argparse . ArgumentParser ( description = 'validate simple_dsl files.' ) \n     parser . add_argument ( 'model_files' ,   metavar = 'model_files' ,   type = str , \n                         nargs = '+' , \n                         help = 'model filenames' ) \n     args   =   parser . parse_args () \n\n     for   filename   in   args . model_files : \n         try : \n             print ( 'validating {}' . format ( filename )) \n             _   =   mm . model_from_file ( filename ) \n         except   BaseException   as   e : \n             print ( '  WARNING/ERROR: {}' . format ( e ))  if   __name__ == '__main__' : \n     validate ()",
            "title": "Install/Uninstall the Language"
        },
        {
            "location": "/textx_project_setup/#installation",
            "text": "Install  the software  permanently for all users  (change directory\nto the folder with the setup.py file):  sudo -H pip3 install --upgrade .  You can now start the new commands defined in the setup.py:   simple_dsl_validate --help",
            "title": "Installation"
        },
        {
            "location": "/textx_project_setup/#uninstallation",
            "text": "Uninstall  the software:  sudo -H pip3 uninstall simple_dsl",
            "title": "Uninstallation"
        },
        {
            "location": "/textx_by_examples/",
            "text": "TextX by Examples\n\n\nThe TextX project page gives a nice introduction \nto the concepts of TextX \n(TextX)\n.\nRead the docs to explore different aspects, like\nthe grammar or scoping. The unittests are\nalso a great source of information, because they contain\nmany examples for different topics.\n\n\nNote: validators are implemented as so-called object_processors.\nThese object_processors are meant to post process the\nparsed model (possibly modifying the model). They can also\nbe used to raise exceptions in order to indicate a logical\ndomain error (as in the \ninitial example\n).",
            "title": "TextX by Examples"
        },
        {
            "location": "/textx_by_examples/#textx-by-examples",
            "text": "The TextX project page gives a nice introduction \nto the concepts of TextX  (TextX) .\nRead the docs to explore different aspects, like\nthe grammar or scoping. The unittests are\nalso a great source of information, because they contain\nmany examples for different topics.  Note: validators are implemented as so-called object_processors.\nThese object_processors are meant to post process the\nparsed model (possibly modifying the model). They can also\nbe used to raise exceptions in order to indicate a logical\ndomain error (as in the  initial example ).",
            "title": "TextX by Examples"
        },
        {
            "location": "/references/",
            "text": "References\n\n\nMany websites, books and persons influenced this work.\nThe references are summarized in the following sections.\n\n\nToolsets / Language Workbenches\n\n\n\n\n (Xtext) \nXtext\n - a grammar based language workbench for java/Xtend/eclipse.\n\n\n (TextX) \nTextX\n - a grammar based language workbench for Python.\n\n\n\n\nProgramming languages, Tools\n\n\n\n\n (Maven) \nMaven\n - a build system\n\n\nXtend\n - a statically types language (translates to Java).\n\n\nPython\n - a dynamically types language.\n\n\n\n\nGeneral information\n\n\n\n\n (Tomassetti, 2017) F. Tomassetti: \n\"The complete guide to (external) Domain Specific Languages\"\n (06/2018)\n\n\n\n\nXtext related stuff\n\n\n\n\n (Bettini, 2016) L. Bettini: \"Implementing Domain-Specific Languages with Xtext and Xtend - Second Edition\u201c (Packt Publishing; 2nd Revised edition, 31. August 2016).\n\n\n (Mooij et al, 2017a) A. Mooij, J. Hooman: \n\"Creating a Domain Specific Language (DSL) with Xtext\"\n (2017/06)\n\n\n (Mooij et al, 2017b) A. Mooij, K. Triantafyllidis, J. Hooman: \n\"Advanced Xtext Manual on Modularity\"\n (2017/06)\n\n\n (Rentz-Reichert, 2017) H. Rentz-Reichert (Protos Software): \"Entwicklung dom\u00e4nenspezifischer Sprachen und Code-Generatoren mit Xtext und Xtend\" (german course, Regensburg, 2017/05;\n    architect of \neTrice (ROOM based modeling tool)\n (2017/06)\n\n\n (Xtext 15 Minutes Tutorial) \nXtext 15 Minutes Tutorial\n.\n\n\n\n\nTextX related stuff\n\n\n\n\n (Dejanovi\u0107 et al. 2017) Dejanovi\u0107 I., Vaderna R., Milosavljevi\u0107 G., Vukovi\u0107 \u017d. (2017). TextX: A Python tool for Domain-Specific Languages implementation. Knowledge-Based Systems, 115, 1-4.",
            "title": "References"
        },
        {
            "location": "/references/#references",
            "text": "Many websites, books and persons influenced this work.\nThe references are summarized in the following sections.",
            "title": "References"
        },
        {
            "location": "/references/#toolsets-language-workbenches",
            "text": "(Xtext)  Xtext  - a grammar based language workbench for java/Xtend/eclipse.   (TextX)  TextX  - a grammar based language workbench for Python.",
            "title": "Toolsets / Language Workbenches"
        },
        {
            "location": "/references/#programming-languages-tools",
            "text": "(Maven)  Maven  - a build system  Xtend  - a statically types language (translates to Java).  Python  - a dynamically types language.",
            "title": "Programming languages, Tools"
        },
        {
            "location": "/references/#general-information",
            "text": "(Tomassetti, 2017) F. Tomassetti:  \"The complete guide to (external) Domain Specific Languages\"  (06/2018)",
            "title": "General information"
        },
        {
            "location": "/references/#xtext-related-stuff",
            "text": "(Bettini, 2016) L. Bettini: \"Implementing Domain-Specific Languages with Xtext and Xtend - Second Edition\u201c (Packt Publishing; 2nd Revised edition, 31. August 2016).   (Mooij et al, 2017a) A. Mooij, J. Hooman:  \"Creating a Domain Specific Language (DSL) with Xtext\"  (2017/06)   (Mooij et al, 2017b) A. Mooij, K. Triantafyllidis, J. Hooman:  \"Advanced Xtext Manual on Modularity\"  (2017/06)   (Rentz-Reichert, 2017) H. Rentz-Reichert (Protos Software): \"Entwicklung dom\u00e4nenspezifischer Sprachen und Code-Generatoren mit Xtext und Xtend\" (german course, Regensburg, 2017/05;\n    architect of  eTrice (ROOM based modeling tool)  (2017/06)   (Xtext 15 Minutes Tutorial)  Xtext 15 Minutes Tutorial .",
            "title": "Xtext related stuff"
        },
        {
            "location": "/references/#textx-related-stuff",
            "text": "(Dejanovi\u0107 et al. 2017) Dejanovi\u0107 I., Vaderna R., Milosavljevi\u0107 G., Vukovi\u0107 \u017d. (2017). TextX: A Python tool for Domain-Specific Languages implementation. Knowledge-Based Systems, 115, 1-4.",
            "title": "TextX related stuff"
        }
    ]
}