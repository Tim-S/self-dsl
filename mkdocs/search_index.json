{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to self-dsl\n\n\nThis is a tutorial site for the creation of domain specific languages.\n\n\n\n\n\n\nMotivation\n:\n    Why using a DSL? What is the value of it? What is MDSD?\n\n\n\n\n\n\nBasics of meta modeling\n\n    What is meta modeled?\n\n\n\n\n\n\nReferences\n\n\n\n\n\n\nEmployed software to generate this documentation\n\n\n\n\nWe use \nMkDocs\n to build these\npages (using the \nRead the Docs\n\ntheme).\n\n\nWe employ \nPlantUML\n to produce UML graphics\n(together with a \nplugin\n\nworking together with  \nMkDocs\n).",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-self-dsl",
            "text": "This is a tutorial site for the creation of domain specific languages.    Motivation :\n    Why using a DSL? What is the value of it? What is MDSD?    Basics of meta modeling \n    What is meta modeled?    References",
            "title": "Welcome to self-dsl"
        },
        {
            "location": "/#employed-software-to-generate-this-documentation",
            "text": "We use  MkDocs  to build these\npages (using the  Read the Docs \ntheme).  We employ  PlantUML  to produce UML graphics\n(together with a  plugin \nworking together with   MkDocs ).",
            "title": "Employed software to generate this documentation"
        },
        {
            "location": "/motivation/",
            "text": "Motivation\n\n\nThe problem to be solved is two-fold: avoid problems with\n\ncommunication\n and \nconsistency\n.\nA \ncommon language\n will be defined to ease \ncommunication\n within and\nbetween teams. A \nsingle source\n of information implies consistency, and in\nturn, prevents misunderstandings.\n\n\n\n\nA very good introduction to domain modeling is\n\n(Tomassetti, 2017)\n.\n\n\nMDSD and DSLs\n\n\nModel driven software development (MDSD)\n allows\nintroducing a supplementary layer of\nabstraction above the code: This additional complexity can be employed to\nreplace traditional model traditional model based design approaches, and\nthus represents a significant design element of a software architecture.\nSuch model driven approaches often also refer to\n\ndomain specific languages (DSL)\n.\nThese languages make the design easy to communicate (defined language at\ndesign level) and at the same time the design itself constitutes of actual\nsoftware artefacts, since code is directly generated from it (single\nsource of information).\n\n\nMeta-model, model, and all that\n\n\nThe meta modeling toolsets utilized on this site typically allow to define\n\n(1) a meta model definition\n, which defines what is modeled, e.g.,\nthe basic layout of a data structure in terms of structures which have\nattributes. This meta model can be compared to a \ndata base layout\n.\nIt also can be compared to \nglossary\n for a given domain.\nUsing the meta model \n(2) model data\n can be defined by a user.\nThis model data represents the concrete \ndata structures for a given domain\n.\n\n(3) Validation\n: importantly, the meta model definition allows to validate\nand check concrete models. Finally, \n(4) code generators and\nmodel transformations\n represent primary end user tools to allow mass\nproduction based on a \nsingle source\n of information (the model).\n\n\nReal value for a project\n\n\nNotably, if a model represents a real abstraction of a software\naspect - something people talk about and which hides important\ndetails - we get a big impact in productivity. From the one and\nsingle source of specification (the model data) we can extract\ndocumentation, plan and archive changes (in the models) and at\nthe same time guarantee the consistency of model and multiple code artefacts.\n\n\nThe \nreal value\n in terms of working hours is not the meta model, the code\ngenerator or the editor of a model, but the \nmodel data\n itself. The\nrest of the employed toolset and definitions (e.g. the meta model) further\nincrease this value, by allowing to validate, transform or\nevaluate the model data.\n\n\nKeeping this in mind, one should keep in  mind to be able to parse and\nunderstand the model data in, say, 10 years. Also think about wht happens if\nmultiple users create conflicts in model files. One should be able to repair\nsuch situations. This is easier if the model stored on disk resembles the\nmodel entered by the user, than if an alternative representation is used\nwith, e.g., binary data representations or machine generated IDs which are\ndifficult to understand. Such a simple representation on disk also allows to\neasily analyze a model with a traditional text search tool (grep) and to\nmake quick modifications to the model with a simple editor.\n\n\nMoreover, the interoperability of employed toolsets is of crucial importancy:\nthe ability to define inter-model relations eases large scale model\ndriven approaches and the IDE integration increases end user acceptance.",
            "title": "Motivation"
        },
        {
            "location": "/motivation/#motivation",
            "text": "The problem to be solved is two-fold: avoid problems with communication  and  consistency .\nA  common language  will be defined to ease  communication  within and\nbetween teams. A  single source  of information implies consistency, and in\nturn, prevents misunderstandings.   A very good introduction to domain modeling is (Tomassetti, 2017) .",
            "title": "Motivation"
        },
        {
            "location": "/motivation/#mdsd-and-dsls",
            "text": "Model driven software development (MDSD)  allows\nintroducing a supplementary layer of\nabstraction above the code: This additional complexity can be employed to\nreplace traditional model traditional model based design approaches, and\nthus represents a significant design element of a software architecture.\nSuch model driven approaches often also refer to domain specific languages (DSL) .\nThese languages make the design easy to communicate (defined language at\ndesign level) and at the same time the design itself constitutes of actual\nsoftware artefacts, since code is directly generated from it (single\nsource of information).",
            "title": "MDSD and DSLs"
        },
        {
            "location": "/motivation/#meta-model-model-and-all-that",
            "text": "The meta modeling toolsets utilized on this site typically allow to define (1) a meta model definition , which defines what is modeled, e.g.,\nthe basic layout of a data structure in terms of structures which have\nattributes. This meta model can be compared to a  data base layout .\nIt also can be compared to  glossary  for a given domain.\nUsing the meta model  (2) model data  can be defined by a user.\nThis model data represents the concrete  data structures for a given domain . (3) Validation : importantly, the meta model definition allows to validate\nand check concrete models. Finally,  (4) code generators and\nmodel transformations  represent primary end user tools to allow mass\nproduction based on a  single source  of information (the model).",
            "title": "Meta-model, model, and all that"
        },
        {
            "location": "/motivation/#real-value-for-a-project",
            "text": "Notably, if a model represents a real abstraction of a software\naspect - something people talk about and which hides important\ndetails - we get a big impact in productivity. From the one and\nsingle source of specification (the model data) we can extract\ndocumentation, plan and archive changes (in the models) and at\nthe same time guarantee the consistency of model and multiple code artefacts.  The  real value  in terms of working hours is not the meta model, the code\ngenerator or the editor of a model, but the  model data  itself. The\nrest of the employed toolset and definitions (e.g. the meta model) further\nincrease this value, by allowing to validate, transform or\nevaluate the model data.  Keeping this in mind, one should keep in  mind to be able to parse and\nunderstand the model data in, say, 10 years. Also think about wht happens if\nmultiple users create conflicts in model files. One should be able to repair\nsuch situations. This is easier if the model stored on disk resembles the\nmodel entered by the user, than if an alternative representation is used\nwith, e.g., binary data representations or machine generated IDs which are\ndifficult to understand. Such a simple representation on disk also allows to\neasily analyze a model with a traditional text search tool (grep) and to\nmake quick modifications to the model with a simple editor.  Moreover, the interoperability of employed toolsets is of crucial importancy:\nthe ability to define inter-model relations eases large scale model\ndriven approaches and the IDE integration increases end user acceptance.",
            "title": "Real value for a project"
        },
        {
            "location": "/basics/",
            "text": "Basics of meta modeling for domain models\n\n\nIn this section we describe typical meta modeling tasks.\nMeta modeling is the creation of a meta model.\nThis defines what can be modeled in a model for that given meta model.\n\n\nAll aspects identified here can be found in a tutorial style\nin corresponding sections for TextX and Xtext of this documentation.\n\n\nIntroductory example\n\n\nAn Example: A meta model for a programming language defines that, e.g.,\nvariables can be defined. The model, in turn, is a concrete programm\nwith many variable definitions.\n\n\nA meta model may, thus, be sketched as follows:\n\n\n\n\nA program (domain model) may look as follows:\n\n\n\n\nOverview: aspects of meta modeling\n\n\nA summary of different aspects to be specified by the meta model is given\nas follows. This list is inspired by the grammar based toolset\n\nXtext\n\nand \ntextX\n.\n\n\n\n\nWhich \ndomain objects\n exist (\nglossary\n)?\n\n\nHow are objects identified (\nnamed\n)?\n\n\nWhich \nattributes\n do objects have?\n\n\nWhat objects are \ncomposed\n of other objects?\n\n\nWhat objects \naggregates\n other objects?\n\n\nHow do objects \nreference\n each other (including context effects/\nscoping\n)?\n\n\nHow can I \nspecialize\n objects?\n\n\nHow can I \nconnect\n objects?\n\n\nModularization\n: How can an object reference another object from another model\n    (form the same meta model or a different one)?\n\n\nInteroperability\n: How can an object reference something from outside\n    the toolset scope (inter-tool operability)?\n\n\nValidation\n: How can custom rules be checked automatically?\n\n\n\n\nDomain objects: identification and attributes\n\n\nDomain objects represent a central part of a \nglossary\n. Thus,\ndefining such objects is a central part of any software specification\nand must be using through its design.\n\n\nDomain objects\n can represent things, like \"Customers\", \"Computers\",\n\"State machines\". In our context they can also represent activities\nand relationships,  like \"owns\" (a customers owns a computer) or\n\"runs\" (a computer runs a state machine).\nDomain objects may have \nattributes\n, some of them optional. These attributes\nmay have a \nscalar\n value or represent a \nlist\n of entries. The value of the\nattributes can be specified to represent some \nbasic type\n (like a string or a\nnumber) or \nother domain\n objects.\n\n\nImportantly, some domain objects need to be identified by a name (like a\n\"Customer\"), while other objects do not (like the \"Birthday\" in our\nexample below).\n\n\n\n\nNote: Domain objects in the meta model represent a blueprint or a class of a\nconcrete instances of such objects in a concrete model.\n\n\nComposing objects\n\n\nDomain objects may be composed of other domain objects. Such a relationship\ncan be described by an attribute with a domain object type (like in the last\nsection). An alternative representation is illustrated as follows, but\ndescribes exactly the same thing:\n\n\n\n\nNote: in this example, a Customer is composed of a Birthday object.\nThe Birthday object cannot exist without the Customer. This relationship\nis called \ncomposition\n and has clear \nownership\n semantics.\n\n\nReferences and Aggregation\n\n\nSome domain objects need to reference identifiable objects without\nhaving their ownership. This happens, e.g.,\nwhen describing domain object relationships within the model (e.g. a\nCustomer owns a Computer; relationship \"own\"). Such relationships themselves\ncan own additional attributes (e.g. \"owns since date\").\n\n\n\n\nNote: non-owning knowlegde of other objects is called \naggregation\n. Simple\nrelationships can be presented by a simple link (without attributes and without\nown rule/class definition).\n\n\nScoping\n\n\nScoping is relevant to \ndescribe what objects are identifiable\n when \nreferencing\nother objects\n. This is especially of importance, when some default visibility\nis not valid (most default scoping mechanisms allow all identifiable objects to be\nreferenced globally).\n\n\nAssume the following meta model snippet, where a \"Scenario\" is composed of\n\"Configurations\" and a \"Testcase\" references \"Scenarios\" and \"Configurations\":\n\n\n\n\nIn this case, we want that \nonly \"Configurations\" of the \"Scenario\"\nreferenced by a \"Testcase\" are visible to the \"Testcase\"\n. This\nrestriction is context specific (to the context of the \"Testcase\" described\nby the referenced \"Scenario\"). Scoping mechanisms allow to define this scope.\n\n\nSpecialization (base classes/base rules)\n\n\nSometimes it happens that some domain object is too generic and needs to\nbe specialized. This may happen when the language evolves.\nDuring the initial design commonalities are identified which lead to\nthe same pattern (base class and specialization).\n\n\n\n\nModularization\n\n\nThis happens when a model is splitted  in multiple submodels\n(e.g., different files).\n\n\n\n\nCombining meta models\n\n\nTo foster modularization, meta models can be splitted and still allow to\nreference domain objects of one meta model from the other meta model. In our last example\nwe could define a meta model for \"Testcases\" and one meta model for\n\"Scenarios\". This feature is more demanding to the underlying technology but\nallows a \nmodularization of the meta model and, thus, the glossary\n.\n\n\nInteroperability with other toolsets or software components\n\n\nIn larger projects external databases or models may need to be referenced.\nSuch external sources of information may be, e.g., am existing database of\nrequirements, some JSON or XML file or similar things. Interoperability with\nthese sources of information allow to link the model to that source.\n\n\n\n\nValidation\n\n\nThe validation of a model consists of \nadditional checks on top of structural\nconsistency\n defined by the grammar and scoping. Error in the structure\nresult in classical syntax errors (\"\nexpected\n 'XY' instead of 'AB'\").\nScoping, in turn, defines the possible references in some context and,\nthus, yields errors of the catergory \"referenced element 'XY' \nnot found\n.\".\nThe \nvalidation\n described in this section is about additional\n\nlogical checks\n, once the model is correctly parsed and all\nreferences resolved. This additional checks typically have a\n\nstrong relation to the domain\n.\n\n\nExample:\n Assume a model where \"testcases\" reference \"configurations of\nscenarios\" which have certain \"aspects\". On the other hand a \"testcase\" may\nneed certain aspects. If any of the \"Aspects\" required by a \"testcase\" is not\navailabe in the referenced \"configuration\", a logical error is reported\n(validation error).\n\n\nRationale\n for choosing a validation over a scoping solution in this case:\nWhen modeling a situation where a \"configuration\" is chosen by a \"testcase\"\nwithout providing the correct \"aspects\", one would not like to get a\n\"configuration ot found\", which would result if only \"configurations\" with matching\n\"aspects\" are defined in the \nscope\n of a \"testcase\". In contrast, the\n\nvalidation\n will allow all \"configurations\" of the selected \"scenario\" of\na \"testcase\" to be visible, but some of them will produce a\n\nmeaningful domain error\n, such as\n\"configuration 'config_B' does not provide the aspect 'aspect_A' required\nby testcase 'test_T1'\".\n\n\nThe structure defined in the meta model is shown as follows:\n\n\n\n\nA model with validation error (\n\"configuration 'config_B' does not provide the aspect 'aspect_A' required\nby testcase 'test_T1'\"\n) is shown as follows:\n\n\nscenario scenario_001 {\n    configuration config_A has {aspect_X}\n    configuration config_B has {aspect_Y}\n}\ntestcase test_T1 {\n    use scenario_001 with config_B\n    and needs {aspect_X}\n}\n\n\n\n\n\n\n\nA model without validation error is shown as follows:\n\n\nscenario scenario_001 {\n    configuration config_A has {aspect_X}\n    configuration config_B has {aspect_Y, aspect_X}\n}\ntestcase test_T1 {\n    use scenario_001 with config_B\n    and needs {aspect_X}\n}",
            "title": "Basics"
        },
        {
            "location": "/basics/#basics-of-meta-modeling-for-domain-models",
            "text": "In this section we describe typical meta modeling tasks.\nMeta modeling is the creation of a meta model.\nThis defines what can be modeled in a model for that given meta model.  All aspects identified here can be found in a tutorial style\nin corresponding sections for TextX and Xtext of this documentation.",
            "title": "Basics of meta modeling for domain models"
        },
        {
            "location": "/basics/#introductory-example",
            "text": "An Example: A meta model for a programming language defines that, e.g.,\nvariables can be defined. The model, in turn, is a concrete programm\nwith many variable definitions.  A meta model may, thus, be sketched as follows:   A program (domain model) may look as follows:",
            "title": "Introductory example"
        },
        {
            "location": "/basics/#overview-aspects-of-meta-modeling",
            "text": "A summary of different aspects to be specified by the meta model is given\nas follows. This list is inspired by the grammar based toolset Xtext \nand  textX .   Which  domain objects  exist ( glossary )?  How are objects identified ( named )?  Which  attributes  do objects have?  What objects are  composed  of other objects?  What objects  aggregates  other objects?  How do objects  reference  each other (including context effects/ scoping )?  How can I  specialize  objects?  How can I  connect  objects?  Modularization : How can an object reference another object from another model\n    (form the same meta model or a different one)?  Interoperability : How can an object reference something from outside\n    the toolset scope (inter-tool operability)?  Validation : How can custom rules be checked automatically?",
            "title": "Overview: aspects of meta modeling"
        },
        {
            "location": "/basics/#domain-objects-identification-and-attributes",
            "text": "Domain objects represent a central part of a  glossary . Thus,\ndefining such objects is a central part of any software specification\nand must be using through its design.  Domain objects  can represent things, like \"Customers\", \"Computers\",\n\"State machines\". In our context they can also represent activities\nand relationships,  like \"owns\" (a customers owns a computer) or\n\"runs\" (a computer runs a state machine).\nDomain objects may have  attributes , some of them optional. These attributes\nmay have a  scalar  value or represent a  list  of entries. The value of the\nattributes can be specified to represent some  basic type  (like a string or a\nnumber) or  other domain  objects.  Importantly, some domain objects need to be identified by a name (like a\n\"Customer\"), while other objects do not (like the \"Birthday\" in our\nexample below).   Note: Domain objects in the meta model represent a blueprint or a class of a\nconcrete instances of such objects in a concrete model.",
            "title": "Domain objects: identification and attributes"
        },
        {
            "location": "/basics/#composing-objects",
            "text": "Domain objects may be composed of other domain objects. Such a relationship\ncan be described by an attribute with a domain object type (like in the last\nsection). An alternative representation is illustrated as follows, but\ndescribes exactly the same thing:   Note: in this example, a Customer is composed of a Birthday object.\nThe Birthday object cannot exist without the Customer. This relationship\nis called  composition  and has clear  ownership  semantics.",
            "title": "Composing objects"
        },
        {
            "location": "/basics/#references-and-aggregation",
            "text": "Some domain objects need to reference identifiable objects without\nhaving their ownership. This happens, e.g.,\nwhen describing domain object relationships within the model (e.g. a\nCustomer owns a Computer; relationship \"own\"). Such relationships themselves\ncan own additional attributes (e.g. \"owns since date\").   Note: non-owning knowlegde of other objects is called  aggregation . Simple\nrelationships can be presented by a simple link (without attributes and without\nown rule/class definition).",
            "title": "References and Aggregation"
        },
        {
            "location": "/basics/#scoping",
            "text": "Scoping is relevant to  describe what objects are identifiable  when  referencing\nother objects . This is especially of importance, when some default visibility\nis not valid (most default scoping mechanisms allow all identifiable objects to be\nreferenced globally).  Assume the following meta model snippet, where a \"Scenario\" is composed of\n\"Configurations\" and a \"Testcase\" references \"Scenarios\" and \"Configurations\":   In this case, we want that  only \"Configurations\" of the \"Scenario\"\nreferenced by a \"Testcase\" are visible to the \"Testcase\" . This\nrestriction is context specific (to the context of the \"Testcase\" described\nby the referenced \"Scenario\"). Scoping mechanisms allow to define this scope.",
            "title": "Scoping"
        },
        {
            "location": "/basics/#specialization-base-classesbase-rules",
            "text": "Sometimes it happens that some domain object is too generic and needs to\nbe specialized. This may happen when the language evolves.\nDuring the initial design commonalities are identified which lead to\nthe same pattern (base class and specialization).",
            "title": "Specialization (base classes/base rules)"
        },
        {
            "location": "/basics/#modularization",
            "text": "This happens when a model is splitted  in multiple submodels\n(e.g., different files).",
            "title": "Modularization"
        },
        {
            "location": "/basics/#combining-meta-models",
            "text": "To foster modularization, meta models can be splitted and still allow to\nreference domain objects of one meta model from the other meta model. In our last example\nwe could define a meta model for \"Testcases\" and one meta model for\n\"Scenarios\". This feature is more demanding to the underlying technology but\nallows a  modularization of the meta model and, thus, the glossary .",
            "title": "Combining meta models"
        },
        {
            "location": "/basics/#interoperability-with-other-toolsets-or-software-components",
            "text": "In larger projects external databases or models may need to be referenced.\nSuch external sources of information may be, e.g., am existing database of\nrequirements, some JSON or XML file or similar things. Interoperability with\nthese sources of information allow to link the model to that source.",
            "title": "Interoperability with other toolsets or software components"
        },
        {
            "location": "/basics/#validation",
            "text": "The validation of a model consists of  additional checks on top of structural\nconsistency  defined by the grammar and scoping. Error in the structure\nresult in classical syntax errors (\" expected  'XY' instead of 'AB'\").\nScoping, in turn, defines the possible references in some context and,\nthus, yields errors of the catergory \"referenced element 'XY'  not found .\".\nThe  validation  described in this section is about additional logical checks , once the model is correctly parsed and all\nreferences resolved. This additional checks typically have a strong relation to the domain .  Example:  Assume a model where \"testcases\" reference \"configurations of\nscenarios\" which have certain \"aspects\". On the other hand a \"testcase\" may\nneed certain aspects. If any of the \"Aspects\" required by a \"testcase\" is not\navailabe in the referenced \"configuration\", a logical error is reported\n(validation error).  Rationale  for choosing a validation over a scoping solution in this case:\nWhen modeling a situation where a \"configuration\" is chosen by a \"testcase\"\nwithout providing the correct \"aspects\", one would not like to get a\n\"configuration ot found\", which would result if only \"configurations\" with matching\n\"aspects\" are defined in the  scope  of a \"testcase\". In contrast, the validation  will allow all \"configurations\" of the selected \"scenario\" of\na \"testcase\" to be visible, but some of them will produce a meaningful domain error , such as\n\"configuration 'config_B' does not provide the aspect 'aspect_A' required\nby testcase 'test_T1'\".  The structure defined in the meta model is shown as follows:   A model with validation error ( \"configuration 'config_B' does not provide the aspect 'aspect_A' required\nby testcase 'test_T1'\" ) is shown as follows:  scenario scenario_001 {\n    configuration config_A has {aspect_X}\n    configuration config_B has {aspect_Y}\n}\ntestcase test_T1 {\n    use scenario_001 with config_B\n    and needs {aspect_X}\n}   A model without validation error is shown as follows:  scenario scenario_001 {\n    configuration config_A has {aspect_X}\n    configuration config_B has {aspect_Y, aspect_X}\n}\ntestcase test_T1 {\n    use scenario_001 with config_B\n    and needs {aspect_X}\n}",
            "title": "Validation"
        },
        {
            "location": "/xtext_project_setup/",
            "text": "Xtext Project Setup\n\n\nxxx",
            "title": "Xtext Project Setup"
        },
        {
            "location": "/xtext_project_setup/#xtext-project-setup",
            "text": "xxx",
            "title": "Xtext Project Setup"
        },
        {
            "location": "/textx_project_setup/",
            "text": "TextX Project Setup\n\n\nxxx",
            "title": "TextX Project Setup"
        },
        {
            "location": "/textx_project_setup/#textx-project-setup",
            "text": "xxx",
            "title": "TextX Project Setup"
        },
        {
            "location": "/references/",
            "text": "References\n\n\nMany websites, books and persons influenced this work.\nThe references are summarized in the following sections.\n\n\nToolsets / Language Workbenches\n\n\n\n\nXtext\n - a grammar based language workbench for java/Xtend/eclipse.\n\n\ntextX\n - a grammar based language workbench for Python.\n\n\n\n\nProgramming languages\n\n\n\n\nXtend\n - a statically types language (translates to Java).\n\n\nPython\n - a dynamically types language.\n\n\n\n\nGeneral information\n\n\n\n\n (Tomassetti, 2017) F. Tomassetti: \n\"The complete guide to (external) Domain Specific Languages\"\n (06/2018)\n\n\n\n\nXtext related stuff\n\n\n\n\n(Bettini, 2016) L. Bettini: \"Implementing Domain-Specific Languages with Xtext and Xtend - Second Edition\u201c (Packt Publishing; 2nd Revised edition, 31. August 2016).\n\n\n(Hooman, Mooij, 2017) A. Mooij, J. Hooman: \n\"Creating a Domain Specific Language (DSL) with Xtext\"\n (2017/06)\n\n\n(Hooman, Triantafyllidis, Mooij, 2017) A. Mooij, K. Triantafyllidis, J. Hooman: \n\"Advanced Xtext Manual on Modularity\"\n (2017/06)\n\n\n(Rentz-Reichert, 2017) H. Rentz-Reichert (Protos Software): \"Entwicklung dom\u00e4nenspezifischer Sprachen und Code-Generatoren mit Xtext und Xtend\" (german course, Regensburg, 2017/05;\n    architect of \neTrice (ROOM based modeling tool)\n (2017/06)\n\n\n\n\ntextX related stuff\n\n\n\n\n(Dejanovi\u0107 et al. 2017) Dejanovi\u0107 I., Vaderna R., Milosavljevi\u0107 G., Vukovi\u0107 \u017d. (2017). TextX: A Python tool for Domain-Specific Languages implementation. Knowledge-Based Systems, 115, 1-4.",
            "title": "References"
        },
        {
            "location": "/references/#references",
            "text": "Many websites, books and persons influenced this work.\nThe references are summarized in the following sections.",
            "title": "References"
        },
        {
            "location": "/references/#toolsets-language-workbenches",
            "text": "Xtext  - a grammar based language workbench for java/Xtend/eclipse.  textX  - a grammar based language workbench for Python.",
            "title": "Toolsets / Language Workbenches"
        },
        {
            "location": "/references/#programming-languages",
            "text": "Xtend  - a statically types language (translates to Java).  Python  - a dynamically types language.",
            "title": "Programming languages"
        },
        {
            "location": "/references/#general-information",
            "text": "(Tomassetti, 2017) F. Tomassetti:  \"The complete guide to (external) Domain Specific Languages\"  (06/2018)",
            "title": "General information"
        },
        {
            "location": "/references/#xtext-related-stuff",
            "text": "(Bettini, 2016) L. Bettini: \"Implementing Domain-Specific Languages with Xtext and Xtend - Second Edition\u201c (Packt Publishing; 2nd Revised edition, 31. August 2016).  (Hooman, Mooij, 2017) A. Mooij, J. Hooman:  \"Creating a Domain Specific Language (DSL) with Xtext\"  (2017/06)  (Hooman, Triantafyllidis, Mooij, 2017) A. Mooij, K. Triantafyllidis, J. Hooman:  \"Advanced Xtext Manual on Modularity\"  (2017/06)  (Rentz-Reichert, 2017) H. Rentz-Reichert (Protos Software): \"Entwicklung dom\u00e4nenspezifischer Sprachen und Code-Generatoren mit Xtext und Xtend\" (german course, Regensburg, 2017/05;\n    architect of  eTrice (ROOM based modeling tool)  (2017/06)",
            "title": "Xtext related stuff"
        },
        {
            "location": "/references/#textx-related-stuff",
            "text": "(Dejanovi\u0107 et al. 2017) Dejanovi\u0107 I., Vaderna R., Milosavljevi\u0107 G., Vukovi\u0107 \u017d. (2017). TextX: A Python tool for Domain-Specific Languages implementation. Knowledge-Based Systems, 115, 1-4.",
            "title": "textX related stuff"
        }
    ]
}